/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#import <CHIP/CHIPDevice.h>
#import <CHIP/CHIPError_Internal.h>

#include <cstdint>
#include <string>
#include <type_traits>

#include <app/data-model/DecodableList.h>
#include <commands/clusters/ComplexArgument.h>
#include <commands/clusters/ModelCommandBridge.h>

/*----------------------------------------------------------------------------*\
| Cluster Name                                                        |   ID   |
|---------------------------------------------------------------------+--------|
| PowerConfiguration                                                  | 0x0001 |
| DeviceTemperatureConfiguration                                      | 0x0002 |
| Identify                                                            | 0x0003 |
| Groups                                                              | 0x0004 |
| Scenes                                                              | 0x0005 |
| OnOff                                                               | 0x0006 |
| OnOffSwitchConfiguration                                            | 0x0007 |
| LevelControl                                                        | 0x0008 |
| Alarms                                                              | 0x0009 |
| Time                                                                | 0x000A |
| BinaryInputBasic                                                    | 0x000F |
| PowerProfile                                                        | 0x001A |
| ApplianceControl                                                    | 0x001B |
| PulseWidthModulation                                                | 0x001C |
| Descriptor                                                          | 0x001D |
| Binding                                                             | 0x001E |
| AccessControl                                                       | 0x001F |
| PollControl                                                         | 0x0020 |
| BridgedActions                                                      | 0x0025 |
| Basic                                                               | 0x0028 |
| OtaSoftwareUpdateProvider                                           | 0x0029 |
| OtaSoftwareUpdateRequestor                                          | 0x002A |
| LocalizationConfiguration                                           | 0x002B |
| TimeFormatLocalization                                              | 0x002C |
| UnitLocalization                                                    | 0x002D |
| PowerSourceConfiguration                                            | 0x002E |
| PowerSource                                                         | 0x002F |
| GeneralCommissioning                                                | 0x0030 |
| NetworkCommissioning                                                | 0x0031 |
| DiagnosticLogs                                                      | 0x0032 |
| GeneralDiagnostics                                                  | 0x0033 |
| SoftwareDiagnostics                                                 | 0x0034 |
| ThreadNetworkDiagnostics                                            | 0x0035 |
| WiFiNetworkDiagnostics                                              | 0x0036 |
| EthernetNetworkDiagnostics                                          | 0x0037 |
| TimeSynchronization                                                 | 0x0038 |
| BridgedDeviceBasic                                                  | 0x0039 |
| Switch                                                              | 0x003B |
| AdministratorCommissioning                                          | 0x003C |
| OperationalCredentials                                              | 0x003E |
| GroupKeyManagement                                                  | 0x003F |
| FixedLabel                                                          | 0x0040 |
| UserLabel                                                           | 0x0041 |
| ProxyConfiguration                                                  | 0x0042 |
| ProxyDiscovery                                                      | 0x0043 |
| ProxyValid                                                          | 0x0044 |
| BooleanState                                                        | 0x0045 |
| ModeSelect                                                          | 0x0050 |
| ShadeConfiguration                                                  | 0x0100 |
| DoorLock                                                            | 0x0101 |
| WindowCovering                                                      | 0x0102 |
| BarrierControl                                                      | 0x0103 |
| PumpConfigurationAndControl                                         | 0x0200 |
| Thermostat                                                          | 0x0201 |
| FanControl                                                          | 0x0202 |
| DehumidificationControl                                             | 0x0203 |
| ThermostatUserInterfaceConfiguration                                | 0x0204 |
| ColorControl                                                        | 0x0300 |
| BallastConfiguration                                                | 0x0301 |
| IlluminanceMeasurement                                              | 0x0400 |
| TemperatureMeasurement                                              | 0x0402 |
| PressureMeasurement                                                 | 0x0403 |
| FlowMeasurement                                                     | 0x0404 |
| RelativeHumidityMeasurement                                         | 0x0405 |
| OccupancySensing                                                    | 0x0406 |
| CarbonMonoxideConcentrationMeasurement                              | 0x040C |
| CarbonDioxideConcentrationMeasurement                               | 0x040D |
| EthyleneConcentrationMeasurement                                    | 0x040E |
| EthyleneOxideConcentrationMeasurement                               | 0x040F |
| HydrogenConcentrationMeasurement                                    | 0x0410 |
| HydrogenSulphideConcentrationMeasurement                            | 0x0411 |
| NitricOxideConcentrationMeasurement                                 | 0x0412 |
| NitrogenDioxideConcentrationMeasurement                             | 0x0413 |
| OxygenConcentrationMeasurement                                      | 0x0414 |
| OzoneConcentrationMeasurement                                       | 0x0415 |
| SulfurDioxideConcentrationMeasurement                               | 0x0416 |
| DissolvedOxygenConcentrationMeasurement                             | 0x0417 |
| BromateConcentrationMeasurement                                     | 0x0418 |
| ChloraminesConcentrationMeasurement                                 | 0x0419 |
| ChlorineConcentrationMeasurement                                    | 0x041A |
| FecalColiformAndEColiConcentrationMeasurement                       | 0x041B |
| FluorideConcentrationMeasurement                                    | 0x041C |
| HaloaceticAcidsConcentrationMeasurement                             | 0x041D |
| TotalTrihalomethanesConcentrationMeasurement                        | 0x041E |
| TotalColiformBacteriaConcentrationMeasurement                       | 0x041F |
| TurbidityConcentrationMeasurement                                   | 0x0420 |
| CopperConcentrationMeasurement                                      | 0x0421 |
| LeadConcentrationMeasurement                                        | 0x0422 |
| ManganeseConcentrationMeasurement                                   | 0x0423 |
| SulfateConcentrationMeasurement                                     | 0x0424 |
| BromodichloromethaneConcentrationMeasurement                        | 0x0425 |
| BromoformConcentrationMeasurement                                   | 0x0426 |
| ChlorodibromomethaneConcentrationMeasurement                        | 0x0427 |
| ChloroformConcentrationMeasurement                                  | 0x0428 |
| SodiumConcentrationMeasurement                                      | 0x0429 |
| IasZone                                                             | 0x0500 |
| IasAce                                                              | 0x0501 |
| IasWd                                                               | 0x0502 |
| WakeOnLan                                                           | 0x0503 |
| Channel                                                             | 0x0504 |
| TargetNavigator                                                     | 0x0505 |
| MediaPlayback                                                       | 0x0506 |
| MediaInput                                                          | 0x0507 |
| LowPower                                                            | 0x0508 |
| KeypadInput                                                         | 0x0509 |
| ContentLauncher                                                     | 0x050A |
| AudioOutput                                                         | 0x050B |
| ApplicationLauncher                                                 | 0x050C |
| ApplicationBasic                                                    | 0x050D |
| AccountLogin                                                        | 0x050E |
| TestCluster                                                         | 0x050F |
| Messaging                                                           | 0x0703 |
| ApplianceIdentification                                             | 0x0B00 |
| MeterIdentification                                                 | 0x0B01 |
| ApplianceEventsAndAlert                                             | 0x0B02 |
| ApplianceStatistics                                                 | 0x0B03 |
| ElectricalMeasurement                                               | 0x0B04 |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
| Cluster AccessControl                                               | 0x001F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Acl                                                               | 0x0000 |
| * Extension                                                         | 0x0001 |
| * SubjectsPerAccessControlEntry                                     | 0x0002 |
| * TargetsPerAccessControlEntry                                      | 0x0003 |
| * AccessControlEntriesPerFabric                                     | 0x0004 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * AccessControlEntryChanged                                         | 0x0000 |
| * AccessControlExtensionChanged                                     | 0x0001 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Acl
 */
class ReadAccessControlAcl : public ModelCommand {
public:
    ReadAccessControlAcl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "acl");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAcl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                              NSLog(@"AccessControl.Acl response %@", [value description]);
                              err = [CHIPError errorToCHIPErrorCode:error];

                              ChipLogError(chipTool, "AccessControl Acl Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];
        return err;
    }
};

class WriteAccessControlAcl : public ModelCommand {
public:
    WriteAccessControlAcl()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "acl");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteAccessControlAcl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPAccessControlClusterAccessControlEntry * newElement_0;
                newElement_0 = [CHIPAccessControlClusterAccessControlEntry new];
                newElement_0.privilege = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.privilege)];
                newElement_0.authMode = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.authMode)];
                if (entry_0.subjects.IsNull()) {
                    newElement_0.subjects = nil;
                } else {
                    { // Scope for our temporary variables
                        auto * array_3 = [NSMutableArray new];
                        for (auto & entry_3 : entry_0.subjects.Value()) {
                            NSNumber * newElement_3;
                            newElement_3 = [NSNumber numberWithUnsignedLongLong:entry_3];
                            [array_3 addObject:newElement_3];
                        }
                        newElement_0.subjects = array_3;
                    }
                }
                if (entry_0.targets.IsNull()) {
                    newElement_0.targets = nil;
                } else {
                    { // Scope for our temporary variables
                        auto * array_3 = [NSMutableArray new];
                        for (auto & entry_3 : entry_0.targets.Value()) {
                            CHIPAccessControlClusterTarget * newElement_3;
                            newElement_3 = [CHIPAccessControlClusterTarget new];
                            if (entry_3.cluster.IsNull()) {
                                newElement_3.cluster = nil;
                            } else {
                                newElement_3.cluster = [NSNumber numberWithUnsignedInt:entry_3.cluster.Value()];
                            }
                            if (entry_3.endpoint.IsNull()) {
                                newElement_3.endpoint = nil;
                            } else {
                                newElement_3.endpoint = [NSNumber numberWithUnsignedShort:entry_3.endpoint.Value()];
                            }
                            if (entry_3.deviceType.IsNull()) {
                                newElement_3.deviceType = nil;
                            } else {
                                newElement_3.deviceType = [NSNumber numberWithUnsignedInt:entry_3.deviceType.Value()];
                            }
                            [array_3 addObject:newElement_3];
                        }
                        newElement_0.targets = array_3;
                    }
                }
                newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeAclWithValue:value
                          completionHandler:^(NSError * _Nullable error) {
                              chipError = [CHIPError errorToCHIPErrorCode:error];
                              ChipLogError(chipTool, "AccessControl Acl Error: %s", chip::ErrorStr(chipError));
                              SetCommandExitStatus(chipError);
                          }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>>
        mComplex;
};

class SubscribeAttributeAccessControlAcl : public ModelCommand {
public:
    SubscribeAttributeAccessControlAcl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "acl");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlAcl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAclWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                               params:params
                              subscriptionEstablished:nullptr
                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                            NSLog(@"AccessControl.Acl response %@", [value description]);
                                            if (error || !mWait) {
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }
                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Extension
 */
class ReadAccessControlExtension : public ModelCommand {
public:
    ReadAccessControlExtension()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "extension");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlExtension() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeExtensionWithParams:params
                                completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                    NSLog(@"AccessControl.Extension response %@", [value description]);
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogError(chipTool, "AccessControl Extension Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }
};

class WriteAccessControlExtension : public ModelCommand {
public:
    WriteAccessControlExtension()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "extension");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteAccessControlExtension() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) WriteAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPAccessControlClusterExtensionEntry * newElement_0;
                newElement_0 = [CHIPAccessControlClusterExtensionEntry new];
                newElement_0.data = [NSData dataWithBytes:entry_0.data.data() length:entry_0.data.size()];
                newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeExtensionWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogError(chipTool, "AccessControl Extension Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::ExtensionEntry::Type> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::ExtensionEntry::Type>>
        mComplex;
};

class SubscribeAttributeAccessControlExtension : public ModelCommand {
public:
    SubscribeAttributeAccessControlExtension()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "extension");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlExtension() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeExtensionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"AccessControl.Extension response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SubjectsPerAccessControlEntry
 */
class ReadAccessControlSubjectsPerAccessControlEntry : public ModelCommand {
public:
    ReadAccessControlSubjectsPerAccessControlEntry()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "subjects-per-access-control-entry");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlSubjectsPerAccessControlEntry() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSubjectsPerAccessControlEntryWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.SubjectsPerAccessControlEntry response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl SubjectsPerAccessControlEntry Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlSubjectsPerAccessControlEntry : public ModelCommand {
public:
    SubscribeAttributeAccessControlSubjectsPerAccessControlEntry()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "subjects-per-access-control-entry");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlSubjectsPerAccessControlEntry() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSubjectsPerAccessControlEntryWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"AccessControl.SubjectsPerAccessControlEntry response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetsPerAccessControlEntry
 */
class ReadAccessControlTargetsPerAccessControlEntry : public ModelCommand {
public:
    ReadAccessControlTargetsPerAccessControlEntry()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "targets-per-access-control-entry");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlTargetsPerAccessControlEntry() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTargetsPerAccessControlEntryWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.TargetsPerAccessControlEntry response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl TargetsPerAccessControlEntry Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlTargetsPerAccessControlEntry : public ModelCommand {
public:
    SubscribeAttributeAccessControlTargetsPerAccessControlEntry()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "targets-per-access-control-entry");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlTargetsPerAccessControlEntry() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTargetsPerAccessControlEntryWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"AccessControl.TargetsPerAccessControlEntry response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AccessControlEntriesPerFabric
 */
class ReadAccessControlAccessControlEntriesPerFabric : public ModelCommand {
public:
    ReadAccessControlAccessControlEntriesPerFabric()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "access-control-entries-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAccessControlEntriesPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAccessControlEntriesPerFabricWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.AccessControlEntriesPerFabric response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl AccessControlEntriesPerFabric Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlAccessControlEntriesPerFabric : public ModelCommand {
public:
    SubscribeAttributeAccessControlAccessControlEntriesPerFabric()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "access-control-entries-per-fabric");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlAccessControlEntriesPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAccessControlEntriesPerFabricWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"AccessControl.AccessControlEntriesPerFabric response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadAccessControlGeneratedCommandList : public ModelCommand {
public:
    ReadAccessControlGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAccessControlGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"AccessControl.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadAccessControlAcceptedCommandList : public ModelCommand {
public:
    ReadAccessControlAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeAccessControlAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"AccessControl.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAccessControlAttributeList : public ModelCommand {
public:
    ReadAccessControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeAccessControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AccessControl.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAccessControlClusterRevision : public ModelCommand {
public:
    ReadAccessControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeAccessControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AccessControl.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AccountLogin                                                | 0x050E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GetSetupPIN                                                       |   0x00 |
| * Login                                                             |   0x02 |
| * Logout                                                            |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command GetSetupPIN
 */
class AccountLoginGetSetupPIN : public ModelCommand {
public:
    AccountLoginGetSetupPIN()
        : ModelCommand("get-setup-pin")
    {
        AddArgument("TempAccountIdentifier", &mTempAccountIdentifier);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAccountLoginClusterGetSetupPINParams alloc] init];

        params.tempAccountIdentifier = [[NSString alloc] initWithBytes:mTempAccountIdentifier.data()
                                                                length:mTempAccountIdentifier.size()
                                                              encoding:NSUTF8StringEncoding];
        [cluster getSetupPINWithParams:params
                     completionHandler:^(
                         CHIPAccountLoginClusterGetSetupPINResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    chip::ByteSpan mTempAccountIdentifier;
};

/*
 * Command Login
 */
class AccountLoginLogin : public ModelCommand {
public:
    AccountLoginLogin()
        : ModelCommand("login")
    {
        AddArgument("TempAccountIdentifier", &mTempAccountIdentifier);
        AddArgument("SetupPIN", &mSetupPIN);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAccountLoginClusterLoginParams alloc] init];

        params.tempAccountIdentifier = [[NSString alloc] initWithBytes:mTempAccountIdentifier.data()
                                                                length:mTempAccountIdentifier.size()
                                                              encoding:NSUTF8StringEncoding];

        params.setupPIN = [[NSString alloc] initWithBytes:mSetupPIN.data() length:mSetupPIN.size() encoding:NSUTF8StringEncoding];
        [cluster loginWithParams:params
               completionHandler:^(NSError * _Nullable error) {
                   chipError = [CHIPError errorToCHIPErrorCode:error];
                   ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                   SetCommandExitStatus(chipError);
               }];
        return chipError;
    }

private:
    chip::ByteSpan mTempAccountIdentifier;
    chip::ByteSpan mSetupPIN;
};

/*
 * Command Logout
 */
class AccountLoginLogout : public ModelCommand {
public:
    AccountLoginLogout()
        : ModelCommand("logout")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster logoutWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute GeneratedCommandList
 */
class ReadAccountLoginGeneratedCommandList : public ModelCommand {
public:
    ReadAccountLoginGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccountLogin.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccountLogin GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccountLoginGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAccountLoginGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccountLoginGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"AccountLogin.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadAccountLoginAcceptedCommandList : public ModelCommand {
public:
    ReadAccountLoginAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccountLogin.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccountLogin AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccountLoginAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeAccountLoginAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccountLoginAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"AccountLogin.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAccountLoginAttributeList : public ModelCommand {
public:
    ReadAccountLoginAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccountLogin.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccountLogin AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccountLoginAttributeList : public ModelCommand {
public:
    SubscribeAttributeAccountLoginAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccountLoginAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AccountLogin.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAccountLoginClusterRevision : public ModelCommand {
public:
    ReadAccountLoginClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccountLogin.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccountLogin ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccountLoginClusterRevision : public ModelCommand {
public:
    SubscribeAttributeAccountLoginClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccountLoginClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AccountLogin.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AdministratorCommissioning                                  | 0x003C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * OpenCommissioningWindow                                           |   0x00 |
| * OpenBasicCommissioningWindow                                      |   0x01 |
| * RevokeCommissioning                                               |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * WindowStatus                                                      | 0x0000 |
| * AdminFabricIndex                                                  | 0x0001 |
| * AdminVendorId                                                     | 0x0002 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command OpenBasicCommissioningWindow
 */
class AdministratorCommissioningOpenBasicCommissioningWindow : public ModelCommand {
public:
    AdministratorCommissioningOpenBasicCommissioningWindow()
        : ModelCommand("open-basic-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mCommissioningTimeout);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAdministratorCommissioningClusterOpenBasicCommissioningWindowParams alloc] init];

        params.commissioningTimeout = [NSNumber numberWithUnsignedShort:mCommissioningTimeout];
        [cluster openBasicCommissioningWindowWithParams:params
                                      completionHandler:^(NSError * _Nullable error) {
                                          chipError = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                          SetCommandExitStatus(chipError);
                                      }];
        return chipError;
    }

private:
    uint16_t mCommissioningTimeout;
};

/*
 * Command OpenCommissioningWindow
 */
class AdministratorCommissioningOpenCommissioningWindow : public ModelCommand {
public:
    AdministratorCommissioningOpenCommissioningWindow()
        : ModelCommand("open-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mCommissioningTimeout);
        AddArgument("PAKEVerifier", &mPAKEVerifier);
        AddArgument("Discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("Iterations", 0, UINT32_MAX, &mIterations);
        AddArgument("Salt", &mSalt);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAdministratorCommissioningClusterOpenCommissioningWindowParams alloc] init];

        params.commissioningTimeout = [NSNumber numberWithUnsignedShort:mCommissioningTimeout];

        params.pakeVerifier = [[NSData alloc] initWithBytes:mPAKEVerifier.data() length:mPAKEVerifier.size()];

        params.discriminator = [NSNumber numberWithUnsignedShort:mDiscriminator];

        params.iterations = [NSNumber numberWithUnsignedInt:mIterations];

        params.salt = [[NSData alloc] initWithBytes:mSalt.data() length:mSalt.size()];
        [cluster openCommissioningWindowWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    uint16_t mCommissioningTimeout;
    chip::ByteSpan mPAKEVerifier;
    uint16_t mDiscriminator;
    uint32_t mIterations;
    chip::ByteSpan mSalt;
};

/*
 * Command RevokeCommissioning
 */
class AdministratorCommissioningRevokeCommissioning : public ModelCommand {
public:
    AdministratorCommissioningRevokeCommissioning()
        : ModelCommand("revoke-commissioning")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster revokeCommissioningWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute WindowStatus
 */
class ReadAdministratorCommissioningWindowStatus : public ModelCommand {
public:
    ReadAdministratorCommissioningWindowStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "window-status");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningWindowStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWindowStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.WindowStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning WindowStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningWindowStatus : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningWindowStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "window-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningWindowStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeWindowStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"AdministratorCommissioning.WindowStatus response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AdminFabricIndex
 */
class ReadAdministratorCommissioningAdminFabricIndex : public ModelCommand {
public:
    ReadAdministratorCommissioningAdminFabricIndex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "admin-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAdminFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAdminFabricIndexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AdminFabricIndex response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AdminFabricIndex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningAdminFabricIndex : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningAdminFabricIndex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "admin-fabric-index");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningAdminFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAdminFabricIndexWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"AdministratorCommissioning.AdminFabricIndex response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AdminVendorId
 */
class ReadAdministratorCommissioningAdminVendorId : public ModelCommand {
public:
    ReadAdministratorCommissioningAdminVendorId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "admin-vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAdminVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAdminVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AdminVendorId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AdminVendorId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningAdminVendorId : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningAdminVendorId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "admin-vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningAdminVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAdminVendorIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AdministratorCommissioning.AdminVendorId response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadAdministratorCommissioningGeneratedCommandList : public ModelCommand {
public:
    ReadAdministratorCommissioningGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"AdministratorCommissioning.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadAdministratorCommissioningAcceptedCommandList : public ModelCommand {
public:
    ReadAdministratorCommissioningAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"AdministratorCommissioning.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAdministratorCommissioningAttributeList : public ModelCommand {
public:
    ReadAdministratorCommissioningAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningAttributeList : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AdministratorCommissioning.AttributeList response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAdministratorCommissioningClusterRevision : public ModelCommand {
public:
    ReadAdministratorCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningClusterRevision : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AdministratorCommissioning.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationBasic                                            | 0x050D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * VendorName                                                        | 0x0000 |
| * VendorID                                                          | 0x0001 |
| * ApplicationName                                                   | 0x0002 |
| * ProductID                                                         | 0x0003 |
| * Application                                                       | 0x0004 |
| * Status                                                            | 0x0005 |
| * ApplicationVersion                                                | 0x0006 |
| * AllowedVendorList                                                 | 0x0007 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute VendorName
 */
class ReadApplicationBasicVendorName : public ModelCommand {
public:
    ReadApplicationBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.VendorName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicVendorName : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ApplicationBasic.VendorName response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadApplicationBasicVendorID : public ModelCommand {
public:
    ReadApplicationBasicVendorID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.VendorID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic VendorID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicVendorID : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicVendorID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ApplicationBasic.VendorID response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationName
 */
class ReadApplicationBasicApplicationName : public ModelCommand {
public:
    ReadApplicationBasicApplicationName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeApplicationNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ApplicationName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ApplicationName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicApplicationName : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicApplicationName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicApplicationName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeApplicationNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ApplicationBasic.ApplicationName response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductID
 */
class ReadApplicationBasicProductID : public ModelCommand {
public:
    ReadApplicationBasicProductID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ProductID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ProductID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicProductID : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicProductID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ApplicationBasic.ProductID response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Application
 */
class ReadApplicationBasicApplication : public ModelCommand {
public:
    ReadApplicationBasicApplication()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplication() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeApplicationWithCompletionHandler:^(
            CHIPApplicationBasicClusterApplicationBasicApplication * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.Application response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic Application Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicApplication : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicApplication()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicApplication() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeApplicationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(CHIPApplicationBasicClusterApplicationBasicApplication * _Nullable value,
                                               NSError * _Nullable error) {
                                               NSLog(@"ApplicationBasic.Application response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Status
 */
class ReadApplicationBasicStatus : public ModelCommand {
public:
    ReadApplicationBasicStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "status");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.Status response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic Status Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicStatus : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"ApplicationBasic.Status response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationVersion
 */
class ReadApplicationBasicApplicationVersion : public ModelCommand {
public:
    ReadApplicationBasicApplicationVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application-version");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeApplicationVersionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ApplicationVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ApplicationVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicApplicationVersion : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicApplicationVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicApplicationVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeApplicationVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"ApplicationBasic.ApplicationVersion response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AllowedVendorList
 */
class ReadApplicationBasicAllowedVendorList : public ModelCommand {
public:
    ReadApplicationBasicAllowedVendorList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "allowed-vendor-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAllowedVendorList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAllowedVendorListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.AllowedVendorList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic AllowedVendorList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicAllowedVendorList : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicAllowedVendorList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "allowed-vendor-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicAllowedVendorList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAllowedVendorListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ApplicationBasic.AllowedVendorList response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadApplicationBasicGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationBasicGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ApplicationBasic.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadApplicationBasicAcceptedCommandList : public ModelCommand {
public:
    ReadApplicationBasicAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ApplicationBasic.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadApplicationBasicAttributeList : public ModelCommand {
public:
    ReadApplicationBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicAttributeList : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ApplicationBasic.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationBasicClusterRevision : public ModelCommand {
public:
    ReadApplicationBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicClusterRevision : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ApplicationBasic.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationLauncher                                         | 0x050C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LaunchApp                                                         |   0x00 |
| * StopApp                                                           |   0x01 |
| * HideApp                                                           |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CatalogList                                                       | 0x0000 |
| * CurrentApp                                                        | 0x0001 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command HideApp
 */
class ApplicationLauncherHideApp : public ModelCommand {
public:
    ApplicationLauncherHideApp()
        : ModelCommand("hide-app")
        , mComplex_Application(&mRequest.application)
    {
        AddArgument("Application", &mComplex_Application);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPApplicationLauncherClusterHideAppParams alloc] init];

        params.application = [CHIPApplicationLauncherClusterApplication new];
        params.application.catalogVendorId = [NSNumber numberWithUnsignedShort:mRequest.application.catalogVendorId];
        params.application.applicationId = [[NSString alloc] initWithBytes:mRequest.application.applicationId.data()
                                                                    length:mRequest.application.applicationId.size()
                                                                  encoding:NSUTF8StringEncoding];
        [cluster hideAppWithParams:params
                 completionHandler:^(
                     CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     chipError = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                     SetCommandExitStatus(chipError);
                 }];
        return chipError;
    }

private:
    chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::ApplicationLauncher::Structs::Application::Type> mComplex_Application;
};

/*
 * Command LaunchApp
 */
class ApplicationLauncherLaunchApp : public ModelCommand {
public:
    ApplicationLauncherLaunchApp()
        : ModelCommand("launch-app")
        , mComplex_Application(&mRequest.application)
    {
        AddArgument("Application", &mComplex_Application);
        AddArgument("Data", &mData);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPApplicationLauncherClusterLaunchAppParams alloc] init];

        params.application = [CHIPApplicationLauncherClusterApplication new];
        params.application.catalogVendorId = [NSNumber numberWithUnsignedShort:mRequest.application.catalogVendorId];
        params.application.applicationId = [[NSString alloc] initWithBytes:mRequest.application.applicationId.data()
                                                                    length:mRequest.application.applicationId.size()
                                                                  encoding:NSUTF8StringEncoding];

        params.data = [[NSData alloc] initWithBytes:mData.data() length:mData.size()];
        [cluster launchAppWithParams:params
                   completionHandler:^(
                       CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       chipError = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                       SetCommandExitStatus(chipError);
                   }];
        return chipError;
    }

private:
    chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::ApplicationLauncher::Structs::Application::Type> mComplex_Application;
    chip::ByteSpan mData;
};

/*
 * Command StopApp
 */
class ApplicationLauncherStopApp : public ModelCommand {
public:
    ApplicationLauncherStopApp()
        : ModelCommand("stop-app")
        , mComplex_Application(&mRequest.application)
    {
        AddArgument("Application", &mComplex_Application);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPApplicationLauncherClusterStopAppParams alloc] init];

        params.application = [CHIPApplicationLauncherClusterApplication new];
        params.application.catalogVendorId = [NSNumber numberWithUnsignedShort:mRequest.application.catalogVendorId];
        params.application.applicationId = [[NSString alloc] initWithBytes:mRequest.application.applicationId.data()
                                                                    length:mRequest.application.applicationId.size()
                                                                  encoding:NSUTF8StringEncoding];
        [cluster stopAppWithParams:params
                 completionHandler:^(
                     CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     chipError = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                     SetCommandExitStatus(chipError);
                 }];
        return chipError;
    }

private:
    chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::ApplicationLauncher::Structs::Application::Type> mComplex_Application;
};

/*
 * Attribute CatalogList
 */
class ReadApplicationLauncherCatalogList : public ModelCommand {
public:
    ReadApplicationLauncherCatalogList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "catalog-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherCatalogList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCatalogListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.CatalogList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher CatalogList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherCatalogList : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherCatalogList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "catalog-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherCatalogList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCatalogListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ApplicationLauncher.CatalogList response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentApp
 */
class ReadApplicationLauncherCurrentApp : public ModelCommand {
public:
    ReadApplicationLauncherCurrentApp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-app");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherCurrentApp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentAppWithCompletionHandler:^(
            CHIPApplicationLauncherClusterApplicationEP * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.CurrentApp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher CurrentApp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteApplicationLauncherCurrentApp : public ModelCommand {
public:
    WriteApplicationLauncherCurrentApp()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "current-app");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteApplicationLauncherCurrentApp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) WriteAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        CHIPApplicationLauncherClusterApplicationEP * _Nullable value;
        if (mValue.IsNull()) {
            value = nil;
        } else {
            value = [CHIPApplicationLauncherClusterApplicationEP new];
            value.application = [CHIPApplicationLauncherClusterApplication new];
            value.application.catalogVendorId = [NSNumber numberWithUnsignedShort:mValue.Value().application.catalogVendorId];
            value.application.applicationId = [[NSString alloc] initWithBytes:mValue.Value().application.applicationId.data()
                                                                       length:mValue.Value().application.applicationId.size()
                                                                     encoding:NSUTF8StringEncoding];
            if (mValue.Value().endpoint.HasValue()) {
                value.endpoint = [NSNumber numberWithUnsignedShort:mValue.Value().endpoint.Value()];
            } else {
                value.endpoint = nil;
            }
        }

        [cluster writeAttributeCurrentAppWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "ApplicationLauncher CurrentApp Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEP::Type> mValue;
    TypedComplexArgument<chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEP::Type>>
        mComplex;
};

class SubscribeAttributeApplicationLauncherCurrentApp : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherCurrentApp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-app");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherCurrentApp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentAppWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(CHIPApplicationLauncherClusterApplicationEP * _Nullable value,
                                                   NSError * _Nullable error) {
                                                   NSLog(@"ApplicationLauncher.CurrentApp response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadApplicationLauncherGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationLauncherGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ApplicationLauncher.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadApplicationLauncherAcceptedCommandList : public ModelCommand {
public:
    ReadApplicationLauncherAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ApplicationLauncher.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadApplicationLauncherAttributeList : public ModelCommand {
public:
    ReadApplicationLauncherAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherAttributeList : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ApplicationLauncher.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationLauncherClusterRevision : public ModelCommand {
public:
    ReadApplicationLauncherClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherClusterRevision : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ApplicationLauncher.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AudioOutput                                                 | 0x050B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SelectOutput                                                      |   0x00 |
| * RenameOutput                                                      |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OutputList                                                        | 0x0000 |
| * CurrentOutput                                                     | 0x0001 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RenameOutput
 */
class AudioOutputRenameOutput : public ModelCommand {
public:
    AudioOutputRenameOutput()
        : ModelCommand("rename-output")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        AddArgument("Name", &mName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAudioOutputClusterRenameOutputParams alloc] init];

        params.index = [NSNumber numberWithUnsignedChar:mIndex];

        params.name = [[NSString alloc] initWithBytes:mName.data() length:mName.size() encoding:NSUTF8StringEncoding];
        [cluster renameOutputWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    uint8_t mIndex;
    chip::ByteSpan mName;
};

/*
 * Command SelectOutput
 */
class AudioOutputSelectOutput : public ModelCommand {
public:
    AudioOutputSelectOutput()
        : ModelCommand("select-output")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAudioOutputClusterSelectOutputParams alloc] init];

        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        [cluster selectOutputWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    uint8_t mIndex;
};

/*
 * Attribute OutputList
 */
class ReadAudioOutputOutputList : public ModelCommand {
public:
    ReadAudioOutputOutputList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "output-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputOutputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOutputListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.OutputList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput OutputList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputOutputList : public ModelCommand {
public:
    SubscribeAttributeAudioOutputOutputList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "output-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputOutputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOutputListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"AudioOutput.OutputList response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentOutput
 */
class ReadAudioOutputCurrentOutput : public ModelCommand {
public:
    ReadAudioOutputCurrentOutput()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-output");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputCurrentOutput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentOutputWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.CurrentOutput response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput CurrentOutput Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputCurrentOutput : public ModelCommand {
public:
    SubscribeAttributeAudioOutputCurrentOutput()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-output");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputCurrentOutput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentOutputWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AudioOutput.CurrentOutput response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadAudioOutputGeneratedCommandList : public ModelCommand {
public:
    ReadAudioOutputGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAudioOutputGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AudioOutput.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadAudioOutputAcceptedCommandList : public ModelCommand {
public:
    ReadAudioOutputAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeAudioOutputAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"AudioOutput.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAudioOutputAttributeList : public ModelCommand {
public:
    ReadAudioOutputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputAttributeList : public ModelCommand {
public:
    SubscribeAttributeAudioOutputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AudioOutput.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAudioOutputClusterRevision : public ModelCommand {
public:
    ReadAudioOutputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputClusterRevision : public ModelCommand {
public:
    SubscribeAttributeAudioOutputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AudioOutput.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BarrierControl                                              | 0x0103 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * BarrierControlGoToPercent                                         |   0x00 |
| * BarrierControlStop                                                |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * BarrierMovingState                                                | 0x0001 |
| * BarrierSafetyStatus                                               | 0x0002 |
| * BarrierCapabilities                                               | 0x0003 |
| * BarrierOpenEvents                                                 | 0x0004 |
| * BarrierCloseEvents                                                | 0x0005 |
| * BarrierCommandOpenEvents                                          | 0x0006 |
| * BarrierCommandCloseEvents                                         | 0x0007 |
| * BarrierOpenPeriod                                                 | 0x0008 |
| * BarrierClosePeriod                                                | 0x0009 |
| * BarrierPosition                                                   | 0x000A |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command BarrierControlGoToPercent
 */
class BarrierControlBarrierControlGoToPercent : public ModelCommand {
public:
    BarrierControlBarrierControlGoToPercent()
        : ModelCommand("barrier-control-go-to-percent")
    {
        AddArgument("PercentOpen", 0, UINT8_MAX, &mPercentOpen);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBarrierControlClusterBarrierControlGoToPercentParams alloc] init];

        params.percentOpen = [NSNumber numberWithUnsignedChar:mPercentOpen];
        [cluster barrierControlGoToPercentWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint8_t mPercentOpen;
};

/*
 * Command BarrierControlStop
 */
class BarrierControlBarrierControlStop : public ModelCommand {
public:
    BarrierControlBarrierControlStop()
        : ModelCommand("barrier-control-stop")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster barrierControlStopWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute BarrierMovingState
 */
class ReadBarrierControlBarrierMovingState : public ModelCommand {
public:
    ReadBarrierControlBarrierMovingState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-moving-state");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierMovingState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBarrierMovingStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierMovingState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierMovingState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlBarrierMovingState : public ModelCommand {
public:
    SubscribeAttributeBarrierControlBarrierMovingState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-moving-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlBarrierMovingState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBarrierMovingStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BarrierControl.BarrierMovingState response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierSafetyStatus
 */
class ReadBarrierControlBarrierSafetyStatus : public ModelCommand {
public:
    ReadBarrierControlBarrierSafetyStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBarrierSafetyStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierSafetyStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierSafetyStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlBarrierSafetyStatus : public ModelCommand {
public:
    SubscribeAttributeBarrierControlBarrierSafetyStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlBarrierSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBarrierSafetyStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"BarrierControl.BarrierSafetyStatus response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierCapabilities
 */
class ReadBarrierControlBarrierCapabilities : public ModelCommand {
public:
    ReadBarrierControlBarrierCapabilities()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBarrierCapabilitiesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierCapabilities response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierCapabilities Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlBarrierCapabilities : public ModelCommand {
public:
    SubscribeAttributeBarrierControlBarrierCapabilities()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlBarrierCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBarrierCapabilitiesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"BarrierControl.BarrierCapabilities response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierPosition
 */
class ReadBarrierControlBarrierPosition : public ModelCommand {
public:
    ReadBarrierControlBarrierPosition()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-position");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBarrierPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierPosition response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierPosition Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlBarrierPosition : public ModelCommand {
public:
    SubscribeAttributeBarrierControlBarrierPosition()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlBarrierPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBarrierPositionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BarrierControl.BarrierPosition response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadBarrierControlGeneratedCommandList : public ModelCommand {
public:
    ReadBarrierControlGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBarrierControlGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"BarrierControl.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadBarrierControlAcceptedCommandList : public ModelCommand {
public:
    ReadBarrierControlAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeBarrierControlAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"BarrierControl.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBarrierControlAttributeList : public ModelCommand {
public:
    ReadBarrierControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeBarrierControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BarrierControl.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBarrierControlClusterRevision : public ModelCommand {
public:
    ReadBarrierControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBarrierControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BarrierControl.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Basic                                                       | 0x0028 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MfgSpecificPing                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DataModelRevision                                                 | 0x0000 |
| * VendorName                                                        | 0x0001 |
| * VendorID                                                          | 0x0002 |
| * ProductName                                                       | 0x0003 |
| * ProductID                                                         | 0x0004 |
| * NodeLabel                                                         | 0x0005 |
| * Location                                                          | 0x0006 |
| * HardwareVersion                                                   | 0x0007 |
| * HardwareVersionString                                             | 0x0008 |
| * SoftwareVersion                                                   | 0x0009 |
| * SoftwareVersionString                                             | 0x000A |
| * ManufacturingDate                                                 | 0x000B |
| * PartNumber                                                        | 0x000C |
| * ProductURL                                                        | 0x000D |
| * ProductLabel                                                      | 0x000E |
| * SerialNumber                                                      | 0x000F |
| * LocalConfigDisabled                                               | 0x0010 |
| * Reachable                                                         | 0x0011 |
| * UniqueID                                                          | 0x0012 |
| * CapabilityMinima                                                  | 0x0013 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StartUp                                                           | 0x0000 |
| * ShutDown                                                          | 0x0001 |
| * Leave                                                             | 0x0002 |
| * ReachableChanged                                                  | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute DataModelRevision
 */
class ReadBasicDataModelRevision : public ModelCommand {
public:
    ReadBasicDataModelRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "data-model-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBasicDataModelRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDataModelRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.DataModelRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic DataModelRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicDataModelRevision : public ModelCommand {
public:
    SubscribeAttributeBasicDataModelRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "data-model-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicDataModelRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDataModelRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"Basic.DataModelRevision response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorName
 */
class ReadBasicVendorName : public ModelCommand {
public:
    ReadBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.VendorName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicVendorName : public ModelCommand {
public:
    SubscribeAttributeBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Basic.VendorName response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadBasicVendorID : public ModelCommand {
public:
    ReadBasicVendorID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.VendorID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic VendorID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicVendorID : public ModelCommand {
public:
    SubscribeAttributeBasicVendorID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"Basic.VendorID response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductName
 */
class ReadBasicProductName : public ModelCommand {
public:
    ReadBasicProductName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicProductName : public ModelCommand {
public:
    SubscribeAttributeBasicProductName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Basic.ProductName response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductID
 */
class ReadBasicProductID : public ModelCommand {
public:
    ReadBasicProductID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicProductID : public ModelCommand {
public:
    SubscribeAttributeBasicProductID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"Basic.ProductID response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NodeLabel
 */
class ReadBasicNodeLabel : public ModelCommand {
public:
    ReadBasicNodeLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "node-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNodeLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.NodeLabel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic NodeLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBasicNodeLabel : public ModelCommand {
public:
    WriteBasicNodeLabel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeNodeLabelWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogError(chipTool, "Basic NodeLabel Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeBasicNodeLabel : public ModelCommand {
public:
    SubscribeAttributeBasicNodeLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNodeLabelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"Basic.NodeLabel response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Location
 */
class ReadBasicLocation : public ModelCommand {
public:
    ReadBasicLocation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "location");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLocationWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.Location response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic Location Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBasicLocation : public ModelCommand {
public:
    WriteBasicLocation()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "location");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLocationWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "Basic Location Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeBasicLocation : public ModelCommand {
public:
    SubscribeAttributeBasicLocation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "location");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLocationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"Basic.Location response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersion
 */
class ReadBasicHardwareVersion : public ModelCommand {
public:
    ReadBasicHardwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHardwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.HardwareVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic HardwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicHardwareVersion : public ModelCommand {
public:
    SubscribeAttributeBasicHardwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeHardwareVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Basic.HardwareVersion response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersionString
 */
class ReadBasicHardwareVersionString : public ModelCommand {
public:
    ReadBasicHardwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHardwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.HardwareVersionString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic HardwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicHardwareVersionString : public ModelCommand {
public:
    SubscribeAttributeBasicHardwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeHardwareVersionStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"Basic.HardwareVersionString response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersion
 */
class ReadBasicSoftwareVersion : public ModelCommand {
public:
    ReadBasicSoftwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoftwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SoftwareVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SoftwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicSoftwareVersion : public ModelCommand {
public:
    SubscribeAttributeBasicSoftwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSoftwareVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Basic.SoftwareVersion response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersionString
 */
class ReadBasicSoftwareVersionString : public ModelCommand {
public:
    ReadBasicSoftwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoftwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SoftwareVersionString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SoftwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicSoftwareVersionString : public ModelCommand {
public:
    SubscribeAttributeBasicSoftwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSoftwareVersionStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"Basic.SoftwareVersionString response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ManufacturingDate
 */
class ReadBasicManufacturingDate : public ModelCommand {
public:
    ReadBasicManufacturingDate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "manufacturing-date");
        ModelCommand::AddArguments();
    }

    ~ReadBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeManufacturingDateWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ManufacturingDate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ManufacturingDate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicManufacturingDate : public ModelCommand {
public:
    SubscribeAttributeBasicManufacturingDate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "manufacturing-date");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeManufacturingDateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"Basic.ManufacturingDate response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartNumber
 */
class ReadBasicPartNumber : public ModelCommand {
public:
    ReadBasicPartNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "part-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.PartNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic PartNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicPartNumber : public ModelCommand {
public:
    SubscribeAttributeBasicPartNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "part-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Basic.PartNumber response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductURL
 */
class ReadBasicProductURL : public ModelCommand {
public:
    ReadBasicProductURL()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-url");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductURLWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductURL response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductURL Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicProductURL : public ModelCommand {
public:
    SubscribeAttributeBasicProductURL()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductURLWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Basic.ProductURL response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductLabel
 */
class ReadBasicProductLabel : public ModelCommand {
public:
    ReadBasicProductLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductLabel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicProductLabel : public ModelCommand {
public:
    SubscribeAttributeBasicProductLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductLabelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Basic.ProductLabel response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SerialNumber
 */
class ReadBasicSerialNumber : public ModelCommand {
public:
    ReadBasicSerialNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "serial-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSerialNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SerialNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SerialNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicSerialNumber : public ModelCommand {
public:
    SubscribeAttributeBasicSerialNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "serial-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSerialNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Basic.SerialNumber response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocalConfigDisabled
 */
class ReadBasicLocalConfigDisabled : public ModelCommand {
public:
    ReadBasicLocalConfigDisabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "local-config-disabled");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLocalConfigDisabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.LocalConfigDisabled response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic LocalConfigDisabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBasicLocalConfigDisabled : public ModelCommand {
public:
    WriteBasicLocalConfigDisabled()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster
            writeAttributeLocalConfigDisabledWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "Basic LocalConfigDisabled Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeBasicLocalConfigDisabled : public ModelCommand {
public:
    SubscribeAttributeBasicLocalConfigDisabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLocalConfigDisabledWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Basic.LocalConfigDisabled response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Reachable
 */
class ReadBasicReachable : public ModelCommand {
public:
    ReadBasicReachable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reachable");
        ModelCommand::AddArguments();
    }

    ~ReadBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeReachableWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.Reachable response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic Reachable Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicReachable : public ModelCommand {
public:
    SubscribeAttributeBasicReachable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reachable");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeReachableWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"Basic.Reachable response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UniqueID
 */
class ReadBasicUniqueID : public ModelCommand {
public:
    ReadBasicUniqueID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "unique-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUniqueIDWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.UniqueID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic UniqueID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicUniqueID : public ModelCommand {
public:
    SubscribeAttributeBasicUniqueID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "unique-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUniqueIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"Basic.UniqueID response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CapabilityMinima
 */
class ReadBasicCapabilityMinima : public ModelCommand {
public:
    ReadBasicCapabilityMinima()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "capability-minima");
        ModelCommand::AddArguments();
    }

    ~ReadBasicCapabilityMinima() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCapabilityMinimaWithCompletionHandler:^(
            CHIPBasicClusterCapabilityMinimaStruct * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.CapabilityMinima response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic CapabilityMinima Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicCapabilityMinima : public ModelCommand {
public:
    SubscribeAttributeBasicCapabilityMinima()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "capability-minima");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicCapabilityMinima() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCapabilityMinimaWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(CHIPBasicClusterCapabilityMinimaStruct * _Nullable value,
                                                         NSError * _Nullable error) {
                                                         NSLog(@"Basic.CapabilityMinima response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadBasicGeneratedCommandList : public ModelCommand {
public:
    ReadBasicGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBasicGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"Basic.GeneratedCommandList response %@", [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadBasicAcceptedCommandList : public ModelCommand {
public:
    ReadBasicAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeBasicAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Basic.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBasicAttributeList : public ModelCommand {
public:
    ReadBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicAttributeList : public ModelCommand {
public:
    SubscribeAttributeBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Basic.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBasicClusterRevision : public ModelCommand {
public:
    ReadBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Basic.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BinaryInputBasic                                            | 0x000F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActiveText                                                        | 0x0004 |
| * Description                                                       | 0x001C |
| * InactiveText                                                      | 0x002E |
| * OutOfService                                                      | 0x0051 |
| * Polarity                                                          | 0x0054 |
| * PresentValue                                                      | 0x0055 |
| * Reliability                                                       | 0x0067 |
| * StatusFlags                                                       | 0x006F |
| * ApplicationType                                                   | 0x0100 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute OutOfService
 */
class ReadBinaryInputBasicOutOfService : public ModelCommand {
public:
    ReadBinaryInputBasicOutOfService()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "out-of-service");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x00000051) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOutOfServiceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.OutOfService response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic OutOfService Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBinaryInputBasicOutOfService : public ModelCommand {
public:
    WriteBinaryInputBasicOutOfService()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) WriteAttribute (0x00000051) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeOutOfServiceWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "BinaryInputBasic OutOfService Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeBinaryInputBasicOutOfService : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicOutOfService()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x00000051) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOutOfServiceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BinaryInputBasic.OutOfService response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PresentValue
 */
class ReadBinaryInputBasicPresentValue : public ModelCommand {
public:
    ReadBinaryInputBasicPresentValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "present-value");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x00000055) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePresentValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.PresentValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic PresentValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBinaryInputBasicPresentValue : public ModelCommand {
public:
    WriteBinaryInputBasicPresentValue()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) WriteAttribute (0x00000055) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributePresentValueWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "BinaryInputBasic PresentValue Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeBinaryInputBasicPresentValue : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicPresentValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x00000055) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePresentValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BinaryInputBasic.PresentValue response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StatusFlags
 */
class ReadBinaryInputBasicStatusFlags : public ModelCommand {
public:
    ReadBinaryInputBasicStatusFlags()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "status-flags");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicStatusFlags() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000006F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.StatusFlags response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic StatusFlags Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicStatusFlags : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicStatusFlags()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "status-flags");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicStatusFlags() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000006F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStatusFlagsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"BinaryInputBasic.StatusFlags response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadBinaryInputBasicGeneratedCommandList : public ModelCommand {
public:
    ReadBinaryInputBasicGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"BinaryInputBasic.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadBinaryInputBasicAcceptedCommandList : public ModelCommand {
public:
    ReadBinaryInputBasicAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"BinaryInputBasic.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBinaryInputBasicAttributeList : public ModelCommand {
public:
    ReadBinaryInputBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicAttributeList : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BinaryInputBasic.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBinaryInputBasicClusterRevision : public ModelCommand {
public:
    ReadBinaryInputBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BinaryInputBasic.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Binding                                                     | 0x001E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Binding                                                           | 0x0000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Binding
 */
class ReadBindingBinding : public ModelCommand {
public:
    ReadBindingBinding()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "binding");
        ModelCommand::AddArguments();
    }

    ~ReadBindingBinding() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeBindingWithParams:params
                              completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                  NSLog(@"Binding.Binding response %@", [value description]);
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "Binding Binding Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }
};

class WriteBindingBinding : public ModelCommand {
public:
    WriteBindingBinding()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "binding");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteBindingBinding() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPBindingClusterTargetStruct * newElement_0;
                newElement_0 = [CHIPBindingClusterTargetStruct new];
                if (entry_0.node.HasValue()) {
                    newElement_0.node = [NSNumber numberWithUnsignedLongLong:entry_0.node.Value()];
                } else {
                    newElement_0.node = nil;
                }
                if (entry_0.group.HasValue()) {
                    newElement_0.group = [NSNumber numberWithUnsignedShort:entry_0.group.Value()];
                } else {
                    newElement_0.group = nil;
                }
                if (entry_0.endpoint.HasValue()) {
                    newElement_0.endpoint = [NSNumber numberWithUnsignedShort:entry_0.endpoint.Value()];
                } else {
                    newElement_0.endpoint = nil;
                }
                if (entry_0.cluster.HasValue()) {
                    newElement_0.cluster = [NSNumber numberWithUnsignedInt:entry_0.cluster.Value()];
                } else {
                    newElement_0.cluster = nil;
                }
                newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeBindingWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "Binding Binding Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type>> mComplex;
};

class SubscribeAttributeBindingBinding : public ModelCommand {
public:
    SubscribeAttributeBindingBinding()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "binding");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingBinding() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBindingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"Binding.Binding response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadBindingGeneratedCommandList : public ModelCommand {
public:
    ReadBindingGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Binding.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Binding GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBindingGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBindingGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Binding.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadBindingAcceptedCommandList : public ModelCommand {
public:
    ReadBindingAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Binding.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Binding AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBindingAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeBindingAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Binding.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBindingAttributeList : public ModelCommand {
public:
    ReadBindingAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Binding.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Binding AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBindingAttributeList : public ModelCommand {
public:
    SubscribeAttributeBindingAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Binding.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBindingClusterRevision : public ModelCommand {
public:
    ReadBindingClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBindingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Binding.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Binding ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBindingClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBindingClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Binding.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BooleanState                                                | 0x0045 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * StateValue                                                        | 0x0000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateChange                                                       | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute StateValue
 */
class ReadBooleanStateStateValue : public ModelCommand {
public:
    ReadBooleanStateStateValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "state-value");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateStateValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStateValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.StateValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState StateValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBooleanStateStateValue : public ModelCommand {
public:
    SubscribeAttributeBooleanStateStateValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "state-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateStateValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStateValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BooleanState.StateValue response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadBooleanStateGeneratedCommandList : public ModelCommand {
public:
    ReadBooleanStateGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBooleanStateGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBooleanStateGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"BooleanState.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadBooleanStateAcceptedCommandList : public ModelCommand {
public:
    ReadBooleanStateAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBooleanStateAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeBooleanStateAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"BooleanState.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBooleanStateAttributeList : public ModelCommand {
public:
    ReadBooleanStateAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBooleanStateAttributeList : public ModelCommand {
public:
    SubscribeAttributeBooleanStateAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BooleanState.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBooleanStateClusterRevision : public ModelCommand {
public:
    ReadBooleanStateClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBooleanStateClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBooleanStateClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BooleanState.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedActions                                              | 0x0025 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * InstantAction                                                     |   0x00 |
| * InstantActionWithTransition                                       |   0x01 |
| * StartAction                                                       |   0x02 |
| * StartActionWithDuration                                           |   0x03 |
| * StopAction                                                        |   0x04 |
| * PauseAction                                                       |   0x05 |
| * PauseActionWithDuration                                           |   0x06 |
| * ResumeAction                                                      |   0x07 |
| * EnableAction                                                      |   0x08 |
| * EnableActionWithDuration                                          |   0x09 |
| * DisableAction                                                     |   0x0A |
| * DisableActionWithDuration                                         |   0x0B |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActionList                                                        | 0x0000 |
| * EndpointList                                                      | 0x0001 |
| * SetupUrl                                                          | 0x0002 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateChanged                                                      | 0x0000 |
| * ActionFailed                                                      | 0x0001 |
\*----------------------------------------------------------------------------*/

/*
 * Command DisableAction
 */
class BridgedActionsDisableAction : public ModelCommand {
public:
    BridgedActionsDisableAction()
        : ModelCommand("disable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterDisableActionParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster disableActionWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command DisableActionWithDuration
 */
class BridgedActionsDisableActionWithDuration : public ModelCommand {
public:
    BridgedActionsDisableActionWithDuration()
        : ModelCommand("disable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterDisableActionWithDurationParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];

        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster disableActionWithDurationWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command EnableAction
 */
class BridgedActionsEnableAction : public ModelCommand {
public:
    BridgedActionsEnableAction()
        : ModelCommand("enable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterEnableActionParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster enableActionWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command EnableActionWithDuration
 */
class BridgedActionsEnableActionWithDuration : public ModelCommand {
public:
    BridgedActionsEnableActionWithDuration()
        : ModelCommand("enable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterEnableActionWithDurationParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];

        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster enableActionWithDurationWithParams:params
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command InstantAction
 */
class BridgedActionsInstantAction : public ModelCommand {
public:
    BridgedActionsInstantAction()
        : ModelCommand("instant-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterInstantActionParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster instantActionWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command InstantActionWithTransition
 */
class BridgedActionsInstantActionWithTransition : public ModelCommand {
public:
    BridgedActionsInstantActionWithTransition()
        : ModelCommand("instant-action-with-transition")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterInstantActionWithTransitionParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster instantActionWithTransitionWithParams:params
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint16_t mTransitionTime;
};

/*
 * Command PauseAction
 */
class BridgedActionsPauseAction : public ModelCommand {
public:
    BridgedActionsPauseAction()
        : ModelCommand("pause-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterPauseActionParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster pauseActionWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command PauseActionWithDuration
 */
class BridgedActionsPauseActionWithDuration : public ModelCommand {
public:
    BridgedActionsPauseActionWithDuration()
        : ModelCommand("pause-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterPauseActionWithDurationParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];

        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster pauseActionWithDurationWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command ResumeAction
 */
class BridgedActionsResumeAction : public ModelCommand {
public:
    BridgedActionsResumeAction()
        : ModelCommand("resume-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterResumeActionParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster resumeActionWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command StartAction
 */
class BridgedActionsStartAction : public ModelCommand {
public:
    BridgedActionsStartAction()
        : ModelCommand("start-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterStartActionParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster startActionWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command StartActionWithDuration
 */
class BridgedActionsStartActionWithDuration : public ModelCommand {
public:
    BridgedActionsStartActionWithDuration()
        : ModelCommand("start-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterStartActionWithDurationParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];

        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster startActionWithDurationWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command StopAction
 */
class BridgedActionsStopAction : public ModelCommand {
public:
    BridgedActionsStopAction()
        : ModelCommand("stop-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterStopActionParams alloc] init];

        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];

        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster stopActionWithParams:params
                    completionHandler:^(NSError * _Nullable error) {
                        chipError = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                        SetCommandExitStatus(chipError);
                    }];
        return chipError;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Attribute ActionList
 */
class ReadBridgedActionsActionList : public ModelCommand {
public:
    ReadBridgedActionsActionList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "action-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsActionList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActionListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.ActionList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions ActionList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsActionList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsActionList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "action-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsActionList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActionListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedActions.ActionList response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndpointList
 */
class ReadBridgedActionsEndpointList : public ModelCommand {
public:
    ReadBridgedActionsEndpointList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "endpoint-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsEndpointList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEndpointListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.EndpointList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions EndpointList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsEndpointList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsEndpointList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "endpoint-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsEndpointList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEndpointListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BridgedActions.EndpointList response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SetupUrl
 */
class ReadBridgedActionsSetupUrl : public ModelCommand {
public:
    ReadBridgedActionsSetupUrl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "setup-url");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsSetupUrl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSetupUrlWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.SetupUrl response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions SetupUrl Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsSetupUrl : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsSetupUrl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "setup-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsSetupUrl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSetupUrlWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"BridgedActions.SetupUrl response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadBridgedActionsGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedActionsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"BridgedActions.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadBridgedActionsAcceptedCommandList : public ModelCommand {
public:
    ReadBridgedActionsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"BridgedActions.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBridgedActionsAttributeList : public ModelCommand {
public:
    ReadBridgedActionsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsAttributeList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BridgedActions.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedActionsClusterRevision : public ModelCommand {
public:
    ReadBridgedActionsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BridgedActions.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedDeviceBasic                                          | 0x0039 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * VendorName                                                        | 0x0001 |
| * VendorID                                                          | 0x0002 |
| * ProductName                                                       | 0x0003 |
| * NodeLabel                                                         | 0x0005 |
| * HardwareVersion                                                   | 0x0007 |
| * HardwareVersionString                                             | 0x0008 |
| * SoftwareVersion                                                   | 0x0009 |
| * SoftwareVersionString                                             | 0x000A |
| * ManufacturingDate                                                 | 0x000B |
| * PartNumber                                                        | 0x000C |
| * ProductURL                                                        | 0x000D |
| * ProductLabel                                                      | 0x000E |
| * SerialNumber                                                      | 0x000F |
| * Reachable                                                         | 0x0011 |
| * UniqueID                                                          | 0x0012 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StartUp                                                           | 0x0000 |
| * ShutDown                                                          | 0x0001 |
| * Leave                                                             | 0x0002 |
| * ReachableChanged                                                  | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute VendorName
 */
class ReadBridgedDeviceBasicVendorName : public ModelCommand {
public:
    ReadBridgedDeviceBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.VendorName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicVendorName : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.VendorName response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadBridgedDeviceBasicVendorID : public ModelCommand {
public:
    ReadBridgedDeviceBasicVendorID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.VendorID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic VendorID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicVendorID : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicVendorID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"BridgedDeviceBasic.VendorID response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductName
 */
class ReadBridgedDeviceBasicProductName : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-name");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicProductName : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicProductName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"BridgedDeviceBasic.ProductName response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NodeLabel
 */
class ReadBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    ReadBridgedDeviceBasicNodeLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "node-label");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNodeLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.NodeLabel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic NodeLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    WriteBridgedDeviceBasicNodeLabel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) WriteAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeNodeLabelWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogError(chipTool, "BridgedDeviceBasic NodeLabel Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicNodeLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNodeLabelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"BridgedDeviceBasic.NodeLabel response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersion
 */
class ReadBridgedDeviceBasicHardwareVersion : public ModelCommand {
public:
    ReadBridgedDeviceBasicHardwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHardwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.HardwareVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic HardwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicHardwareVersion : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicHardwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeHardwareVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.HardwareVersion response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersionString
 */
class ReadBridgedDeviceBasicHardwareVersionString : public ModelCommand {
public:
    ReadBridgedDeviceBasicHardwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHardwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.HardwareVersionString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic HardwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicHardwareVersionString : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicHardwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeHardwareVersionStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BridgedDeviceBasic.HardwareVersionString response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersion
 */
class ReadBridgedDeviceBasicSoftwareVersion : public ModelCommand {
public:
    ReadBridgedDeviceBasicSoftwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoftwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SoftwareVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SoftwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicSoftwareVersion : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicSoftwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSoftwareVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.SoftwareVersion response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersionString
 */
class ReadBridgedDeviceBasicSoftwareVersionString : public ModelCommand {
public:
    ReadBridgedDeviceBasicSoftwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoftwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SoftwareVersionString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SoftwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicSoftwareVersionString : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicSoftwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSoftwareVersionStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BridgedDeviceBasic.SoftwareVersionString response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ManufacturingDate
 */
class ReadBridgedDeviceBasicManufacturingDate : public ModelCommand {
public:
    ReadBridgedDeviceBasicManufacturingDate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "manufacturing-date");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeManufacturingDateWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ManufacturingDate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ManufacturingDate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicManufacturingDate : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicManufacturingDate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "manufacturing-date");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeManufacturingDateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"BridgedDeviceBasic.ManufacturingDate response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartNumber
 */
class ReadBridgedDeviceBasicPartNumber : public ModelCommand {
public:
    ReadBridgedDeviceBasicPartNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "part-number");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.PartNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic PartNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicPartNumber : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicPartNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "part-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.PartNumber response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductURL
 */
class ReadBridgedDeviceBasicProductURL : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductURL()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-url");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductURLWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductURL response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductURL Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicProductURL : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicProductURL()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductURLWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.ProductURL response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductLabel
 */
class ReadBridgedDeviceBasicProductLabel : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-label");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductLabel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicProductLabel : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicProductLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductLabelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BridgedDeviceBasic.ProductLabel response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SerialNumber
 */
class ReadBridgedDeviceBasicSerialNumber : public ModelCommand {
public:
    ReadBridgedDeviceBasicSerialNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "serial-number");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSerialNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SerialNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SerialNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicSerialNumber : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicSerialNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "serial-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSerialNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BridgedDeviceBasic.SerialNumber response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Reachable
 */
class ReadBridgedDeviceBasicReachable : public ModelCommand {
public:
    ReadBridgedDeviceBasicReachable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reachable");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeReachableWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.Reachable response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic Reachable Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicReachable : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicReachable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reachable");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeReachableWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"BridgedDeviceBasic.Reachable response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UniqueID
 */
class ReadBridgedDeviceBasicUniqueID : public ModelCommand {
public:
    ReadBridgedDeviceBasicUniqueID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "unique-id");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUniqueIDWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.UniqueID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic UniqueID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicUniqueID : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicUniqueID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "unique-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUniqueIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"BridgedDeviceBasic.UniqueID response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadBridgedDeviceBasicGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedDeviceBasicGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"BridgedDeviceBasic.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadBridgedDeviceBasicAcceptedCommandList : public ModelCommand {
public:
    ReadBridgedDeviceBasicAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"BridgedDeviceBasic.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBridgedDeviceBasicAttributeList : public ModelCommand {
public:
    ReadBridgedDeviceBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicAttributeList : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BridgedDeviceBasic.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedDeviceBasicClusterRevision : public ModelCommand {
public:
    ReadBridgedDeviceBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Channel                                                     | 0x0504 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeChannel                                                     |   0x00 |
| * ChangeChannelByNumber                                             |   0x02 |
| * SkipChannel                                                       |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ChannelList                                                       | 0x0000 |
| * Lineup                                                            | 0x0001 |
| * CurrentChannel                                                    | 0x0002 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeChannel
 */
class ChannelChangeChannel : public ModelCommand {
public:
    ChannelChangeChannel()
        : ModelCommand("change-channel")
    {
        AddArgument("Match", &mMatch);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPChannelClusterChangeChannelParams alloc] init];

        params.match = [[NSString alloc] initWithBytes:mMatch.data() length:mMatch.size() encoding:NSUTF8StringEncoding];
        [cluster
            changeChannelWithParams:params
                  completionHandler:^(CHIPChannelClusterChangeChannelResponseParams * _Nullable values, NSError * _Nullable error) {
                      NSLog(@"Values: %@", values);
                      chipError = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                      SetCommandExitStatus(chipError);
                  }];
        return chipError;
    }

private:
    chip::ByteSpan mMatch;
};

/*
 * Command ChangeChannelByNumber
 */
class ChannelChangeChannelByNumber : public ModelCommand {
public:
    ChannelChangeChannelByNumber()
        : ModelCommand("change-channel-by-number")
    {
        AddArgument("MajorNumber", 0, UINT16_MAX, &mMajorNumber);
        AddArgument("MinorNumber", 0, UINT16_MAX, &mMinorNumber);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPChannelClusterChangeChannelByNumberParams alloc] init];

        params.majorNumber = [NSNumber numberWithUnsignedShort:mMajorNumber];

        params.minorNumber = [NSNumber numberWithUnsignedShort:mMinorNumber];
        [cluster changeChannelByNumberWithParams:params
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    uint16_t mMajorNumber;
    uint16_t mMinorNumber;
};

/*
 * Command SkipChannel
 */
class ChannelSkipChannel : public ModelCommand {
public:
    ChannelSkipChannel()
        : ModelCommand("skip-channel")
    {
        AddArgument("Count", 0, UINT16_MAX, &mCount);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPChannelClusterSkipChannelParams alloc] init];

        params.count = [NSNumber numberWithUnsignedShort:mCount];
        [cluster skipChannelWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint16_t mCount;
};

/*
 * Attribute ChannelList
 */
class ReadChannelChannelList : public ModelCommand {
public:
    ReadChannelChannelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelChannelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChannelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.ChannelList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel ChannelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelChannelList : public ModelCommand {
public:
    SubscribeAttributeChannelChannelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelChannelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeChannelListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Channel.ChannelList response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Lineup
 */
class ReadChannelLineup : public ModelCommand {
public:
    ReadChannelLineup()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lineup");
        ModelCommand::AddArguments();
    }

    ~ReadChannelLineup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeLineupWithCompletionHandler:^(CHIPChannelClusterLineupInfo * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Channel.Lineup response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Channel Lineup Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeChannelLineup : public ModelCommand {
public:
    SubscribeAttributeChannelLineup()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lineup");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelLineup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeLineupWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                             params:params
                            subscriptionEstablished:nullptr
                                      reportHandler:^(CHIPChannelClusterLineupInfo * _Nullable value, NSError * _Nullable error) {
                                          NSLog(@"Channel.Lineup response %@", [value description]);
                                          if (error || !mWait) {
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }
                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentChannel
 */
class ReadChannelCurrentChannel : public ModelCommand {
public:
    ReadChannelCurrentChannel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-channel");
        ModelCommand::AddArguments();
    }

    ~ReadChannelCurrentChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentChannelWithCompletionHandler:^(
            CHIPChannelClusterChannelInfo * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.CurrentChannel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel CurrentChannel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelCurrentChannel : public ModelCommand {
public:
    SubscribeAttributeChannelCurrentChannel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-channel");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelCurrentChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentChannelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(
                                                       CHIPChannelClusterChannelInfo * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"Channel.CurrentChannel response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadChannelGeneratedCommandList : public ModelCommand {
public:
    ReadChannelGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeChannelGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Channel.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadChannelAcceptedCommandList : public ModelCommand {
public:
    ReadChannelAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeChannelAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Channel.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadChannelAttributeList : public ModelCommand {
public:
    ReadChannelAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelAttributeList : public ModelCommand {
public:
    SubscribeAttributeChannelAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Channel.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadChannelClusterRevision : public ModelCommand {
public:
    ReadChannelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadChannelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelClusterRevision : public ModelCommand {
public:
    SubscribeAttributeChannelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Channel.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ColorControl                                                | 0x0300 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MoveToHue                                                         |   0x00 |
| * MoveHue                                                           |   0x01 |
| * StepHue                                                           |   0x02 |
| * MoveToSaturation                                                  |   0x03 |
| * MoveSaturation                                                    |   0x04 |
| * StepSaturation                                                    |   0x05 |
| * MoveToHueAndSaturation                                            |   0x06 |
| * MoveToColor                                                       |   0x07 |
| * MoveColor                                                         |   0x08 |
| * StepColor                                                         |   0x09 |
| * MoveToColorTemperature                                            |   0x0A |
| * EnhancedMoveToHue                                                 |   0x40 |
| * EnhancedMoveHue                                                   |   0x41 |
| * EnhancedStepHue                                                   |   0x42 |
| * EnhancedMoveToHueAndSaturation                                    |   0x43 |
| * ColorLoopSet                                                      |   0x44 |
| * StopMoveStep                                                      |   0x47 |
| * MoveColorTemperature                                              |   0x4B |
| * StepColorTemperature                                              |   0x4C |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentHue                                                        | 0x0000 |
| * CurrentSaturation                                                 | 0x0001 |
| * RemainingTime                                                     | 0x0002 |
| * CurrentX                                                          | 0x0003 |
| * CurrentY                                                          | 0x0004 |
| * DriftCompensation                                                 | 0x0005 |
| * CompensationText                                                  | 0x0006 |
| * ColorTemperature                                                  | 0x0007 |
| * ColorMode                                                         | 0x0008 |
| * ColorControlOptions                                               | 0x000F |
| * NumberOfPrimaries                                                 | 0x0010 |
| * Primary1X                                                         | 0x0011 |
| * Primary1Y                                                         | 0x0012 |
| * Primary1Intensity                                                 | 0x0013 |
| * Primary2X                                                         | 0x0015 |
| * Primary2Y                                                         | 0x0016 |
| * Primary2Intensity                                                 | 0x0017 |
| * Primary3X                                                         | 0x0019 |
| * Primary3Y                                                         | 0x001A |
| * Primary3Intensity                                                 | 0x001B |
| * Primary4X                                                         | 0x0020 |
| * Primary4Y                                                         | 0x0021 |
| * Primary4Intensity                                                 | 0x0022 |
| * Primary5X                                                         | 0x0024 |
| * Primary5Y                                                         | 0x0025 |
| * Primary5Intensity                                                 | 0x0026 |
| * Primary6X                                                         | 0x0028 |
| * Primary6Y                                                         | 0x0029 |
| * Primary6Intensity                                                 | 0x002A |
| * WhitePointX                                                       | 0x0030 |
| * WhitePointY                                                       | 0x0031 |
| * ColorPointRX                                                      | 0x0032 |
| * ColorPointRY                                                      | 0x0033 |
| * ColorPointRIntensity                                              | 0x0034 |
| * ColorPointGX                                                      | 0x0036 |
| * ColorPointGY                                                      | 0x0037 |
| * ColorPointGIntensity                                              | 0x0038 |
| * ColorPointBX                                                      | 0x003A |
| * ColorPointBY                                                      | 0x003B |
| * ColorPointBIntensity                                              | 0x003C |
| * EnhancedCurrentHue                                                | 0x4000 |
| * EnhancedColorMode                                                 | 0x4001 |
| * ColorLoopActive                                                   | 0x4002 |
| * ColorLoopDirection                                                | 0x4003 |
| * ColorLoopTime                                                     | 0x4004 |
| * ColorLoopStartEnhancedHue                                         | 0x4005 |
| * ColorLoopStoredEnhancedHue                                        | 0x4006 |
| * ColorCapabilities                                                 | 0x400A |
| * ColorTempPhysicalMin                                              | 0x400B |
| * ColorTempPhysicalMax                                              | 0x400C |
| * CoupleColorTempToLevelMinMireds                                   | 0x400D |
| * StartUpColorTemperatureMireds                                     | 0x4010 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ColorLoopSet
 */
class ColorControlColorLoopSet : public ModelCommand {
public:
    ColorControlColorLoopSet()
        : ModelCommand("color-loop-set")
    {
        AddArgument("UpdateFlags", 0, UINT8_MAX, &mUpdateFlags);
        AddArgument("Action", 0, UINT8_MAX, &mAction);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("Time", 0, UINT16_MAX, &mTime);
        AddArgument("StartHue", 0, UINT16_MAX, &mStartHue);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000044) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];

        params.updateFlags = [NSNumber numberWithUnsignedChar:mUpdateFlags];

        params.action = [NSNumber numberWithUnsignedChar:mAction];

        params.direction = [NSNumber numberWithUnsignedChar:mDirection];

        params.time = [NSNumber numberWithUnsignedShort:mTime];

        params.startHue = [NSNumber numberWithUnsignedShort:mStartHue];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    uint8_t mUpdateFlags;
    uint8_t mAction;
    uint8_t mDirection;
    uint16_t mTime;
    uint16_t mStartHue;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveHue
 */
class ColorControlEnhancedMoveHue : public ModelCommand {
public:
    ColorControlEnhancedMoveHue()
        : ModelCommand("enhanced-move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT16_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000041) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveHueParams alloc] init];

        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];

        params.rate = [NSNumber numberWithUnsignedShort:mRate];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveHueWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             chipError = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                             SetCommandExitStatus(chipError);
                         }];
        return chipError;
    }

private:
    uint8_t mMoveMode;
    uint16_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveToHue
 */
class ColorControlEnhancedMoveToHue : public ModelCommand {
public:
    ColorControlEnhancedMoveToHue()
        : ModelCommand("enhanced-move-to-hue")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mEnhancedHue);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000040) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];

        params.enhancedHue = [NSNumber numberWithUnsignedShort:mEnhancedHue];

        params.direction = [NSNumber numberWithUnsignedChar:mDirection];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               chipError = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                               SetCommandExitStatus(chipError);
                           }];
        return chipError;
    }

private:
    uint16_t mEnhancedHue;
    uint8_t mDirection;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveToHueAndSaturation
 */
class ColorControlEnhancedMoveToHueAndSaturation : public ModelCommand {
public:
    ColorControlEnhancedMoveToHueAndSaturation()
        : ModelCommand("enhanced-move-to-hue-and-saturation")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mEnhancedHue);
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000043) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueAndSaturationParams alloc] init];

        params.enhancedHue = [NSNumber numberWithUnsignedShort:mEnhancedHue];

        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveToHueAndSaturationWithParams:params
                                        completionHandler:^(NSError * _Nullable error) {
                                            chipError = [CHIPError errorToCHIPErrorCode:error];
                                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                            SetCommandExitStatus(chipError);
                                        }];
        return chipError;
    }

private:
    uint16_t mEnhancedHue;
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedStepHue
 */
class ColorControlEnhancedStepHue : public ModelCommand {
public:
    ColorControlEnhancedStepHue()
        : ModelCommand("enhanced-step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT16_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000042) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterEnhancedStepHueParams alloc] init];

        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];

        params.stepSize = [NSNumber numberWithUnsignedShort:mStepSize];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedStepHueWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             chipError = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                             SetCommandExitStatus(chipError);
                         }];
        return chipError;
    }

private:
    uint8_t mStepMode;
    uint16_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveColor
 */
class ColorControlMoveColor : public ModelCommand {
public:
    ColorControlMoveColor()
        : ModelCommand("move-color")
    {
        AddArgument("RateX", INT16_MIN, INT16_MAX, &mRateX);
        AddArgument("RateY", INT16_MIN, INT16_MAX, &mRateY);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveColorParams alloc] init];

        params.rateX = [NSNumber numberWithShort:mRateX];

        params.rateY = [NSNumber numberWithShort:mRateY];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveColorWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       chipError = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                       SetCommandExitStatus(chipError);
                   }];
        return chipError;
    }

private:
    int16_t mRateX;
    int16_t mRateY;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveColorTemperature
 */
class ColorControlMoveColorTemperature : public ModelCommand {
public:
    ColorControlMoveColorTemperature()
        : ModelCommand("move-color-temperature")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT16_MAX, &mRate);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mColorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mColorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];

        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];

        params.rate = [NSNumber numberWithUnsignedShort:mRate];

        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:mColorTemperatureMinimum];

        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:mColorTemperatureMaximum];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mMoveMode;
    uint16_t mRate;
    uint16_t mColorTemperatureMinimum;
    uint16_t mColorTemperatureMaximum;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveHue
 */
class ColorControlMoveHue : public ModelCommand {
public:
    ColorControlMoveHue()
        : ModelCommand("move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveHueParams alloc] init];

        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];

        params.rate = [NSNumber numberWithUnsignedChar:mRate];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveHueWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     chipError = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                     SetCommandExitStatus(chipError);
                 }];
        return chipError;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveSaturation
 */
class ColorControlMoveSaturation : public ModelCommand {
public:
    ColorControlMoveSaturation()
        : ModelCommand("move-saturation")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];

        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];

        params.rate = [NSNumber numberWithUnsignedChar:mRate];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            chipError = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                            SetCommandExitStatus(chipError);
                        }];
        return chipError;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColor
 */
class ColorControlMoveToColor : public ModelCommand {
public:
    ColorControlMoveToColor()
        : ModelCommand("move-to-color")
    {
        AddArgument("ColorX", 0, UINT16_MAX, &mColorX);
        AddArgument("ColorY", 0, UINT16_MAX, &mColorY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToColorParams alloc] init];

        params.colorX = [NSNumber numberWithUnsignedShort:mColorX];

        params.colorY = [NSNumber numberWithUnsignedShort:mColorY];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToColorWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint16_t mColorX;
    uint16_t mColorY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColorTemperature
 */
class ColorControlMoveToColorTemperature : public ModelCommand {
public:
    ColorControlMoveToColorTemperature()
        : ModelCommand("move-to-color-temperature")
    {
        AddArgument("ColorTemperature", 0, UINT16_MAX, &mColorTemperature);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToColorTemperatureParams alloc] init];

        params.colorTemperature = [NSNumber numberWithUnsignedShort:mColorTemperature];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToColorTemperatureWithParams:params
                                completionHandler:^(NSError * _Nullable error) {
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    uint16_t mColorTemperature;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHue
 */
class ColorControlMoveToHue : public ModelCommand {
public:
    ColorControlMoveToHue()
        : ModelCommand("move-to-hue")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mHue);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToHueParams alloc] init];

        params.hue = [NSNumber numberWithUnsignedChar:mHue];

        params.direction = [NSNumber numberWithUnsignedChar:mDirection];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToHueWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       chipError = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                       SetCommandExitStatus(chipError);
                   }];
        return chipError;
    }

private:
    uint8_t mHue;
    uint8_t mDirection;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHueAndSaturation
 */
class ColorControlMoveToHueAndSaturation : public ModelCommand {
public:
    ColorControlMoveToHueAndSaturation()
        : ModelCommand("move-to-hue-and-saturation")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mHue);
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToHueAndSaturationParams alloc] init];

        params.hue = [NSNumber numberWithUnsignedChar:mHue];

        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToHueAndSaturationWithParams:params
                                completionHandler:^(NSError * _Nullable error) {
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    uint8_t mHue;
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToSaturation
 */
class ColorControlMoveToSaturation : public ModelCommand {
public:
    ColorControlMoveToSaturation()
        : ModelCommand("move-to-saturation")
    {
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToSaturationParams alloc] init];

        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToSaturationWithParams:params
                          completionHandler:^(NSError * _Nullable error) {
                              chipError = [CHIPError errorToCHIPErrorCode:error];
                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                              SetCommandExitStatus(chipError);
                          }];
        return chipError;
    }

private:
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColor
 */
class ColorControlStepColor : public ModelCommand {
public:
    ColorControlStepColor()
        : ModelCommand("step-color")
    {
        AddArgument("StepX", INT16_MIN, INT16_MAX, &mStepX);
        AddArgument("StepY", INT16_MIN, INT16_MAX, &mStepY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStepColorParams alloc] init];

        params.stepX = [NSNumber numberWithShort:mStepX];

        params.stepY = [NSNumber numberWithShort:mStepY];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepColorWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       chipError = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                       SetCommandExitStatus(chipError);
                   }];
        return chipError;
    }

private:
    int16_t mStepX;
    int16_t mStepY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColorTemperature
 */
class ColorControlStepColorTemperature : public ModelCommand {
public:
    ColorControlStepColorTemperature()
        : ModelCommand("step-color-temperature")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT16_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mColorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mColorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStepColorTemperatureParams alloc] init];

        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];

        params.stepSize = [NSNumber numberWithUnsignedShort:mStepSize];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:mColorTemperatureMinimum];

        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:mColorTemperatureMaximum];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mStepMode;
    uint16_t mStepSize;
    uint16_t mTransitionTime;
    uint16_t mColorTemperatureMinimum;
    uint16_t mColorTemperatureMaximum;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepHue
 */
class ColorControlStepHue : public ModelCommand {
public:
    ColorControlStepHue()
        : ModelCommand("step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStepHueParams alloc] init];

        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];

        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];

        params.transitionTime = [NSNumber numberWithUnsignedChar:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepHueWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     chipError = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                     SetCommandExitStatus(chipError);
                 }];
        return chipError;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepSaturation
 */
class ColorControlStepSaturation : public ModelCommand {
public:
    ColorControlStepSaturation()
        : ModelCommand("step-saturation")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStepSaturationParams alloc] init];

        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];

        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];

        params.transitionTime = [NSNumber numberWithUnsignedChar:mTransitionTime];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            chipError = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                            SetCommandExitStatus(chipError);
                        }];
        return chipError;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StopMoveStep
 */
class ColorControlStopMoveStep : public ModelCommand {
public:
    ColorControlStopMoveStep()
        : ModelCommand("stop-move-step")
    {
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000047) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStopMoveStepParams alloc] init];

        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];

        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stopMoveStepWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Attribute CurrentHue
 */
class ReadColorControlCurrentHue : public ModelCommand {
public:
    ReadColorControlCurrentHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentHue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentHue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCurrentHue : public ModelCommand {
public:
    SubscribeAttributeColorControlCurrentHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentHueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ColorControl.CurrentHue response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentSaturation
 */
class ReadColorControlCurrentSaturation : public ModelCommand {
public:
    ReadColorControlCurrentSaturation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-saturation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentSaturation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentSaturationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentSaturation response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentSaturation Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCurrentSaturation : public ModelCommand {
public:
    SubscribeAttributeColorControlCurrentSaturation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-saturation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCurrentSaturation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentSaturationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.CurrentSaturation response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadColorControlRemainingTime : public ModelCommand {
public:
    ReadColorControlRemainingTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.RemainingTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl RemainingTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlRemainingTime : public ModelCommand {
public:
    SubscribeAttributeColorControlRemainingTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRemainingTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.RemainingTime response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentX
 */
class ReadColorControlCurrentX : public ModelCommand {
public:
    ReadColorControlCurrentX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCurrentX : public ModelCommand {
public:
    SubscribeAttributeColorControlCurrentX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCurrentX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ColorControl.CurrentX response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentY
 */
class ReadColorControlCurrentY : public ModelCommand {
public:
    ReadColorControlCurrentY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCurrentY : public ModelCommand {
public:
    SubscribeAttributeColorControlCurrentY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCurrentY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ColorControl.CurrentY response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DriftCompensation
 */
class ReadColorControlDriftCompensation : public ModelCommand {
public:
    ReadColorControlDriftCompensation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "drift-compensation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlDriftCompensation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDriftCompensationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.DriftCompensation response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl DriftCompensation Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlDriftCompensation : public ModelCommand {
public:
    SubscribeAttributeColorControlDriftCompensation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "drift-compensation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlDriftCompensation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDriftCompensationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.DriftCompensation response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CompensationText
 */
class ReadColorControlCompensationText : public ModelCommand {
public:
    ReadColorControlCompensationText()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "compensation-text");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCompensationText() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCompensationTextWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CompensationText response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CompensationText Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCompensationText : public ModelCommand {
public:
    SubscribeAttributeColorControlCompensationText()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "compensation-text");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCompensationText() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCompensationTextWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ColorControl.CompensationText response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTemperature
 */
class ReadColorControlColorTemperature : public ModelCommand {
public:
    ReadColorControlColorTemperature()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTemperature response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTemperature Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorTemperature : public ModelCommand {
public:
    SubscribeAttributeColorControlColorTemperature()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorTemperatureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ColorControl.ColorTemperature response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorMode
 */
class ReadColorControlColorMode : public ModelCommand {
public:
    ReadColorControlColorMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorMode : public ModelCommand {
public:
    SubscribeAttributeColorControlColorMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.ColorMode response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorControlOptions
 */
class ReadColorControlColorControlOptions : public ModelCommand {
public:
    ReadColorControlColorControlOptions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-control-options");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorControlOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorControlOptions response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorControlOptions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorControlOptions : public ModelCommand {
public:
    WriteColorControlColorControlOptions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeColorControlOptionsWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(chipTool, "ColorControl ColorControlOptions Error: %s",
                                                  chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeColorControlColorControlOptions : public ModelCommand {
public:
    SubscribeAttributeColorControlColorControlOptions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeColorControlOptionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ColorControl.ColorControlOptions response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPrimaries
 */
class ReadColorControlNumberOfPrimaries : public ModelCommand {
public:
    ReadColorControlNumberOfPrimaries()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-primaries");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlNumberOfPrimaries() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfPrimariesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.NumberOfPrimaries response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl NumberOfPrimaries Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlNumberOfPrimaries : public ModelCommand {
public:
    SubscribeAttributeColorControlNumberOfPrimaries()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-primaries");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlNumberOfPrimaries() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNumberOfPrimariesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.NumberOfPrimaries response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1X
 */
class ReadColorControlPrimary1X : public ModelCommand {
public:
    ReadColorControlPrimary1X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary1XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary1X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary1X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary1X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary1XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary1X response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Y
 */
class ReadColorControlPrimary1Y : public ModelCommand {
public:
    ReadColorControlPrimary1Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary1YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary1Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary1Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary1Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary1YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary1Y response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Intensity
 */
class ReadColorControlPrimary1Intensity : public ModelCommand {
public:
    ReadColorControlPrimary1Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary1IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary1Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary1Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary1Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary1IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary1Intensity response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2X
 */
class ReadColorControlPrimary2X : public ModelCommand {
public:
    ReadColorControlPrimary2X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000015) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary2XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary2X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary2X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary2X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary2XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary2X response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Y
 */
class ReadColorControlPrimary2Y : public ModelCommand {
public:
    ReadColorControlPrimary2Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000016) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary2YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary2Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary2Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary2Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary2YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary2Y response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Intensity
 */
class ReadColorControlPrimary2Intensity : public ModelCommand {
public:
    ReadColorControlPrimary2Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000017) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary2IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary2Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary2Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary2Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary2IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary2Intensity response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3X
 */
class ReadColorControlPrimary3X : public ModelCommand {
public:
    ReadColorControlPrimary3X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000019) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary3XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary3X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary3X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary3X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary3XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary3X response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Y
 */
class ReadColorControlPrimary3Y : public ModelCommand {
public:
    ReadColorControlPrimary3Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000001A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary3YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary3Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary3Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary3Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000001A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary3YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary3Y response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Intensity
 */
class ReadColorControlPrimary3Intensity : public ModelCommand {
public:
    ReadColorControlPrimary3Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000001B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary3IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary3Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary3Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary3Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000001B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary3IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary3Intensity response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4X
 */
class ReadColorControlPrimary4X : public ModelCommand {
public:
    ReadColorControlPrimary4X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000020) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary4XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary4X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary4X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary4X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000020) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary4XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary4X response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Y
 */
class ReadColorControlPrimary4Y : public ModelCommand {
public:
    ReadColorControlPrimary4Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000021) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary4YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary4Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary4Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary4Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary4YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary4Y response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Intensity
 */
class ReadColorControlPrimary4Intensity : public ModelCommand {
public:
    ReadColorControlPrimary4Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000022) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary4IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary4Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary4Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary4Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000022) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary4IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary4Intensity response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5X
 */
class ReadColorControlPrimary5X : public ModelCommand {
public:
    ReadColorControlPrimary5X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000024) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary5XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary5X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary5X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary5X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000024) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary5XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary5X response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Y
 */
class ReadColorControlPrimary5Y : public ModelCommand {
public:
    ReadColorControlPrimary5Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000025) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary5YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary5Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary5Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary5Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000025) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary5YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary5Y response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Intensity
 */
class ReadColorControlPrimary5Intensity : public ModelCommand {
public:
    ReadColorControlPrimary5Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000026) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary5IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary5Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary5Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary5Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000026) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary5IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary5Intensity response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6X
 */
class ReadColorControlPrimary6X : public ModelCommand {
public:
    ReadColorControlPrimary6X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000028) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary6XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary6X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary6X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary6X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000028) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary6XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary6X response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Y
 */
class ReadColorControlPrimary6Y : public ModelCommand {
public:
    ReadColorControlPrimary6Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000029) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary6YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary6Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary6Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary6Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000029) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary6YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary6Y response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Intensity
 */
class ReadColorControlPrimary6Intensity : public ModelCommand {
public:
    ReadColorControlPrimary6Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000002A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary6IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary6Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary6Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary6Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000002A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary6IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary6Intensity response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointX
 */
class ReadColorControlWhitePointX : public ModelCommand {
public:
    ReadColorControlWhitePointX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000030) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWhitePointXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.WhitePointX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl WhitePointX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlWhitePointX : public ModelCommand {
public:
    WriteColorControlWhitePointX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000030) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeWhitePointXWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "ColorControl WhitePointX Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlWhitePointX : public ModelCommand {
public:
    SubscribeAttributeColorControlWhitePointX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000030) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWhitePointXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ColorControl.WhitePointX response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointY
 */
class ReadColorControlWhitePointY : public ModelCommand {
public:
    ReadColorControlWhitePointY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000031) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWhitePointYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.WhitePointY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl WhitePointY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlWhitePointY : public ModelCommand {
public:
    WriteColorControlWhitePointY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000031) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeWhitePointYWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "ColorControl WhitePointY Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlWhitePointY : public ModelCommand {
public:
    SubscribeAttributeColorControlWhitePointY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000031) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWhitePointYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ColorControl.WhitePointY response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRX
 */
class ReadColorControlColorPointRX : public ModelCommand {
public:
    ReadColorControlColorPointRX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000032) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointRXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointRX : public ModelCommand {
public:
    WriteColorControlColorPointRX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000032) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointRXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointRX Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointRX : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointRX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000032) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointRXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointRX response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRY
 */
class ReadColorControlColorPointRY : public ModelCommand {
public:
    ReadColorControlColorPointRY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-ry");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000033) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointRYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointRY : public ModelCommand {
public:
    WriteColorControlColorPointRY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000033) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointRYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointRY Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointRY : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointRY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000033) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointRYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointRY response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRIntensity
 */
class ReadColorControlColorPointRIntensity : public ModelCommand {
public:
    ReadColorControlColorPointRIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000034) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointRIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRIntensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointRIntensity : public ModelCommand {
public:
    WriteColorControlColorPointRIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000034) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeColorPointRIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "ColorControl ColorPointRIntensity Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeColorControlColorPointRIntensity : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointRIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000034) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointRIntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorPointRIntensity response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGX
 */
class ReadColorControlColorPointGX : public ModelCommand {
public:
    ReadColorControlColorPointGX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000036) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointGXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointGX : public ModelCommand {
public:
    WriteColorControlColorPointGX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000036) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointGXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointGX Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointGX : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointGX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000036) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointGXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointGX response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGY
 */
class ReadColorControlColorPointGY : public ModelCommand {
public:
    ReadColorControlColorPointGY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gy");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000037) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointGYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointGY : public ModelCommand {
public:
    WriteColorControlColorPointGY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000037) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointGYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointGY Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointGY : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointGY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000037) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointGYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointGY response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGIntensity
 */
class ReadColorControlColorPointGIntensity : public ModelCommand {
public:
    ReadColorControlColorPointGIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000038) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointGIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGIntensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointGIntensity : public ModelCommand {
public:
    WriteColorControlColorPointGIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000038) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeColorPointGIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "ColorControl ColorPointGIntensity Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeColorControlColorPointGIntensity : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointGIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000038) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointGIntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorPointGIntensity response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBX
 */
class ReadColorControlColorPointBX : public ModelCommand {
public:
    ReadColorControlColorPointBX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointBXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointBX : public ModelCommand {
public:
    WriteColorControlColorPointBX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointBXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointBX Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointBX : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointBX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointBXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointBX response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBY
 */
class ReadColorControlColorPointBY : public ModelCommand {
public:
    ReadColorControlColorPointBY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-by");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointBYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointBY : public ModelCommand {
public:
    WriteColorControlColorPointBY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointBYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointBY Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointBY : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointBY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointBYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointBY response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBIntensity
 */
class ReadColorControlColorPointBIntensity : public ModelCommand {
public:
    ReadColorControlColorPointBIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointBIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBIntensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointBIntensity : public ModelCommand {
public:
    WriteColorControlColorPointBIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeColorPointBIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "ColorControl ColorPointBIntensity Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeColorControlColorPointBIntensity : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointBIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointBIntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorPointBIntensity response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedCurrentHue
 */
class ReadColorControlEnhancedCurrentHue : public ModelCommand {
public:
    ReadColorControlEnhancedCurrentHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.EnhancedCurrentHue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl EnhancedCurrentHue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlEnhancedCurrentHue : public ModelCommand {
public:
    SubscribeAttributeColorControlEnhancedCurrentHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlEnhancedCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeEnhancedCurrentHueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.EnhancedCurrentHue response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedColorMode
 */
class ReadColorControlEnhancedColorMode : public ModelCommand {
public:
    ReadColorControlEnhancedColorMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnhancedColorModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.EnhancedColorMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl EnhancedColorMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlEnhancedColorMode : public ModelCommand {
public:
    SubscribeAttributeColorControlEnhancedColorMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlEnhancedColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnhancedColorModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.EnhancedColorMode response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopActive
 */
class ReadColorControlColorLoopActive : public ModelCommand {
public:
    ReadColorControlColorLoopActive()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-active");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopActive() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopActive response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopActive Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopActive : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopActive()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-active");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopActive() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorLoopActiveWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ColorControl.ColorLoopActive response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopDirection
 */
class ReadColorControlColorLoopDirection : public ModelCommand {
public:
    ReadColorControlColorLoopDirection()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-direction");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopDirection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopDirection response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopDirection Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopDirection : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopDirection()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-direction");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopDirection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeColorLoopDirectionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.ColorLoopDirection response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopTime
 */
class ReadColorControlColorLoopTime : public ModelCommand {
public:
    ReadColorControlColorLoopTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopTime : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorLoopTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.ColorLoopTime response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStartEnhancedHue
 */
class ReadColorControlColorLoopStartEnhancedHue : public ModelCommand {
public:
    ReadColorControlColorLoopStartEnhancedHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStartEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ColorLoopStartEnhancedHue response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ColorLoopStartEnhancedHue Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopStartEnhancedHue : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopStartEnhancedHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopStartEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeColorLoopStartEnhancedHueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorLoopStartEnhancedHue response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStoredEnhancedHue
 */
class ReadColorControlColorLoopStoredEnhancedHue : public ModelCommand {
public:
    ReadColorControlColorLoopStoredEnhancedHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStoredEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ColorLoopStoredEnhancedHue response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ColorLoopStoredEnhancedHue Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopStoredEnhancedHue : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopStoredEnhancedHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopStoredEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeColorLoopStoredEnhancedHueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ColorControl.ColorLoopStoredEnhancedHue response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorCapabilities
 */
class ReadColorControlColorCapabilities : public ModelCommand {
public:
    ReadColorControlColorCapabilities()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorCapabilitiesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorCapabilities response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorCapabilities Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorCapabilities : public ModelCommand {
public:
    SubscribeAttributeColorControlColorCapabilities()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorCapabilitiesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.ColorCapabilities response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMin
 */
class ReadColorControlColorTempPhysicalMin : public ModelCommand {
public:
    ReadColorControlColorTempPhysicalMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorTempPhysicalMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTempPhysicalMin response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTempPhysicalMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorTempPhysicalMin : public ModelCommand {
public:
    SubscribeAttributeColorControlColorTempPhysicalMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorTempPhysicalMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorTempPhysicalMinWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorTempPhysicalMin response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMax
 */
class ReadColorControlColorTempPhysicalMax : public ModelCommand {
public:
    ReadColorControlColorTempPhysicalMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorTempPhysicalMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTempPhysicalMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTempPhysicalMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorTempPhysicalMax : public ModelCommand {
public:
    SubscribeAttributeColorControlColorTempPhysicalMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorTempPhysicalMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorTempPhysicalMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorTempPhysicalMax response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CoupleColorTempToLevelMinMireds
 */
class ReadColorControlCoupleColorTempToLevelMinMireds : public ModelCommand {
public:
    ReadColorControlCoupleColorTempToLevelMinMireds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCoupleColorTempToLevelMinMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCoupleColorTempToLevelMinMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CoupleColorTempToLevelMinMireds response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CoupleColorTempToLevelMinMireds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCoupleColorTempToLevelMinMireds : public ModelCommand {
public:
    SubscribeAttributeColorControlCoupleColorTempToLevelMinMireds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCoupleColorTempToLevelMinMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCoupleColorTempToLevelMinMiredsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                      params:params
                                                     subscriptionEstablished:nullptr
                                                               reportHandler:^(
                                                                   NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                   NSLog(
                                                                       @"ColorControl.CoupleColorTempToLevelMinMireds response %@",
                                                                       [value description]);
                                                                   if (error || !mWait) {
                                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                   }
                                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpColorTemperatureMireds
 */
class ReadColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    ReadColorControlStartUpColorTemperatureMireds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartUpColorTemperatureMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.StartUpColorTemperatureMireds response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl StartUpColorTemperatureMireds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    WriteColorControlStartUpColorTemperatureMireds()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00004010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster
            writeAttributeStartUpColorTemperatureMiredsWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                                   ChipLogError(chipTool, "ColorControl StartUpColorTemperatureMireds Error: %s",
                                                       chip::ErrorStr(chipError));
                                                   SetCommandExitStatus(chipError);
                                               }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    SubscribeAttributeColorControlStartUpColorTemperatureMireds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeStartUpColorTemperatureMiredsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"ColorControl.StartUpColorTemperatureMireds response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadColorControlGeneratedCommandList : public ModelCommand {
public:
    ReadColorControlGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeColorControlGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadColorControlAcceptedCommandList : public ModelCommand {
public:
    ReadColorControlAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeColorControlAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ColorControl.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadColorControlAttributeList : public ModelCommand {
public:
    ReadColorControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeColorControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadColorControlClusterRevision : public ModelCommand {
public:
    ReadColorControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeColorControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ColorControl.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ContentLauncher                                             | 0x050A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LaunchContent                                                     |   0x00 |
| * LaunchURL                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AcceptHeader                                                      | 0x0000 |
| * SupportedStreamingProtocols                                       | 0x0001 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command LaunchContent
 */
class ContentLauncherLaunchContent : public ModelCommand {
public:
    ContentLauncherLaunchContent()
        : ModelCommand("launch-content")
        , mComplex_Search(&mRequest.search)
    {
        AddArgument("Search", &mComplex_Search);
        AddArgument("AutoPlay", 0, 1, &mAutoPlay);
        AddArgument("Data", &mData);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPContentLauncherClusterLaunchContentParams alloc] init];

        params.search = [CHIPContentLauncherClusterContentSearch new];
        { // Scope for our temporary variables
            auto * array_1 = [NSMutableArray new];
            for (auto & entry_1 : mRequest.search.parameterList) {
                CHIPContentLauncherClusterParameter * newElement_1;
                newElement_1 = [CHIPContentLauncherClusterParameter new];
                newElement_1.type = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_1.type)];
                newElement_1.value = [[NSString alloc] initWithBytes:entry_1.value.data()
                                                              length:entry_1.value.size()
                                                            encoding:NSUTF8StringEncoding];
                if (entry_1.externalIDList.HasValue()) {
                    { // Scope for our temporary variables
                        auto * array_4 = [NSMutableArray new];
                        for (auto & entry_4 : entry_1.externalIDList.Value()) {
                            CHIPContentLauncherClusterAdditionalInfo * newElement_4;
                            newElement_4 = [CHIPContentLauncherClusterAdditionalInfo new];
                            newElement_4.name = [[NSString alloc] initWithBytes:entry_4.name.data()
                                                                         length:entry_4.name.size()
                                                                       encoding:NSUTF8StringEncoding];
                            newElement_4.value = [[NSString alloc] initWithBytes:entry_4.value.data()
                                                                          length:entry_4.value.size()
                                                                        encoding:NSUTF8StringEncoding];
                            [array_4 addObject:newElement_4];
                        }
                        newElement_1.externalIDList = array_4;
                    }
                } else {
                    newElement_1.externalIDList = nil;
                }
                [array_1 addObject:newElement_1];
            }
            params.search.parameterList = array_1;
        }

        params.autoPlay = [NSNumber numberWithBool:mAutoPlay];

        params.data = [[NSString alloc] initWithBytes:mData.data() length:mData.size() encoding:NSUTF8StringEncoding];
        [cluster launchContentWithParams:params
                       completionHandler:^(
                           CHIPContentLauncherClusterLaunchResponseParams * _Nullable values, NSError * _Nullable error) {
                           NSLog(@"Values: %@", values);
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::ContentLauncher::Structs::ContentSearch::Type> mComplex_Search;
    bool mAutoPlay;
    chip::ByteSpan mData;
};

/*
 * Command LaunchURL
 */
class ContentLauncherLaunchURL : public ModelCommand {
public:
    ContentLauncherLaunchURL()
        : ModelCommand("launch-url")
        , mComplex_BrandingInformation(&mRequest.brandingInformation)
    {
        AddArgument("ContentURL", &mContentURL);
        AddArgument("DisplayString", &mDisplayString);
        AddArgument("BrandingInformation", &mComplex_BrandingInformation);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPContentLauncherClusterLaunchURLParams alloc] init];

        params.contentURL = [[NSString alloc] initWithBytes:mContentURL.data()
                                                     length:mContentURL.size()
                                                   encoding:NSUTF8StringEncoding];

        params.displayString = [[NSString alloc] initWithBytes:mDisplayString.data()
                                                        length:mDisplayString.size()
                                                      encoding:NSUTF8StringEncoding];

        if (mRequest.brandingInformation.HasValue()) {
            params.brandingInformation = [CHIPContentLauncherClusterBrandingInformation new];
            params.brandingInformation.providerName =
                [[NSString alloc] initWithBytes:mRequest.brandingInformation.Value().providerName.data()
                                         length:mRequest.brandingInformation.Value().providerName.size()
                                       encoding:NSUTF8StringEncoding];
            if (mRequest.brandingInformation.Value().background.HasValue()) {
                params.brandingInformation.background = [CHIPContentLauncherClusterStyleInformation new];
                if (mRequest.brandingInformation.Value().background.Value().imageUrl.HasValue()) {
                    params.brandingInformation.background.imageUrl = [[NSString alloc]
                        initWithBytes:mRequest.brandingInformation.Value().background.Value().imageUrl.Value().data()
                               length:mRequest.brandingInformation.Value().background.Value().imageUrl.Value().size()
                             encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.background.imageUrl = nil;
                }
                if (mRequest.brandingInformation.Value().background.Value().color.HasValue()) {
                    params.brandingInformation.background.color =
                        [[NSString alloc] initWithBytes:mRequest.brandingInformation.Value().background.Value().color.Value().data()
                                                 length:mRequest.brandingInformation.Value().background.Value().color.Value().size()
                                               encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.background.color = nil;
                }
                if (mRequest.brandingInformation.Value().background.Value().size.HasValue()) {
                    params.brandingInformation.background.size = [CHIPContentLauncherClusterDimension new];
                    params.brandingInformation.background.size.width =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().background.Value().size.Value().width];
                    params.brandingInformation.background.size.height =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().background.Value().size.Value().height];
                    params.brandingInformation.background.size.metric = [NSNumber
                        numberWithUnsignedChar:chip::to_underlying(
                                                   mRequest.brandingInformation.Value().background.Value().size.Value().metric)];
                } else {
                    params.brandingInformation.background.size = nil;
                }
            } else {
                params.brandingInformation.background = nil;
            }
            if (mRequest.brandingInformation.Value().logo.HasValue()) {
                params.brandingInformation.logo = [CHIPContentLauncherClusterStyleInformation new];
                if (mRequest.brandingInformation.Value().logo.Value().imageUrl.HasValue()) {
                    params.brandingInformation.logo.imageUrl =
                        [[NSString alloc] initWithBytes:mRequest.brandingInformation.Value().logo.Value().imageUrl.Value().data()
                                                 length:mRequest.brandingInformation.Value().logo.Value().imageUrl.Value().size()
                                               encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.logo.imageUrl = nil;
                }
                if (mRequest.brandingInformation.Value().logo.Value().color.HasValue()) {
                    params.brandingInformation.logo.color =
                        [[NSString alloc] initWithBytes:mRequest.brandingInformation.Value().logo.Value().color.Value().data()
                                                 length:mRequest.brandingInformation.Value().logo.Value().color.Value().size()
                                               encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.logo.color = nil;
                }
                if (mRequest.brandingInformation.Value().logo.Value().size.HasValue()) {
                    params.brandingInformation.logo.size = [CHIPContentLauncherClusterDimension new];
                    params.brandingInformation.logo.size.width =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().logo.Value().size.Value().width];
                    params.brandingInformation.logo.size.height =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().logo.Value().size.Value().height];
                    params.brandingInformation.logo.size.metric = [NSNumber
                        numberWithUnsignedChar:chip::to_underlying(
                                                   mRequest.brandingInformation.Value().logo.Value().size.Value().metric)];
                } else {
                    params.brandingInformation.logo.size = nil;
                }
            } else {
                params.brandingInformation.logo = nil;
            }
            if (mRequest.brandingInformation.Value().progressBar.HasValue()) {
                params.brandingInformation.progressBar = [CHIPContentLauncherClusterStyleInformation new];
                if (mRequest.brandingInformation.Value().progressBar.Value().imageUrl.HasValue()) {
                    params.brandingInformation.progressBar.imageUrl = [[NSString alloc]
                        initWithBytes:mRequest.brandingInformation.Value().progressBar.Value().imageUrl.Value().data()
                               length:mRequest.brandingInformation.Value().progressBar.Value().imageUrl.Value().size()
                             encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.progressBar.imageUrl = nil;
                }
                if (mRequest.brandingInformation.Value().progressBar.Value().color.HasValue()) {
                    params.brandingInformation.progressBar.color = [[NSString alloc]
                        initWithBytes:mRequest.brandingInformation.Value().progressBar.Value().color.Value().data()
                               length:mRequest.brandingInformation.Value().progressBar.Value().color.Value().size()
                             encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.progressBar.color = nil;
                }
                if (mRequest.brandingInformation.Value().progressBar.Value().size.HasValue()) {
                    params.brandingInformation.progressBar.size = [CHIPContentLauncherClusterDimension new];
                    params.brandingInformation.progressBar.size.width =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().progressBar.Value().size.Value().width];
                    params.brandingInformation.progressBar.size.height =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().progressBar.Value().size.Value().height];
                    params.brandingInformation.progressBar.size.metric = [NSNumber
                        numberWithUnsignedChar:chip::to_underlying(
                                                   mRequest.brandingInformation.Value().progressBar.Value().size.Value().metric)];
                } else {
                    params.brandingInformation.progressBar.size = nil;
                }
            } else {
                params.brandingInformation.progressBar = nil;
            }
            if (mRequest.brandingInformation.Value().splash.HasValue()) {
                params.brandingInformation.splash = [CHIPContentLauncherClusterStyleInformation new];
                if (mRequest.brandingInformation.Value().splash.Value().imageUrl.HasValue()) {
                    params.brandingInformation.splash.imageUrl =
                        [[NSString alloc] initWithBytes:mRequest.brandingInformation.Value().splash.Value().imageUrl.Value().data()
                                                 length:mRequest.brandingInformation.Value().splash.Value().imageUrl.Value().size()
                                               encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.splash.imageUrl = nil;
                }
                if (mRequest.brandingInformation.Value().splash.Value().color.HasValue()) {
                    params.brandingInformation.splash.color =
                        [[NSString alloc] initWithBytes:mRequest.brandingInformation.Value().splash.Value().color.Value().data()
                                                 length:mRequest.brandingInformation.Value().splash.Value().color.Value().size()
                                               encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.splash.color = nil;
                }
                if (mRequest.brandingInformation.Value().splash.Value().size.HasValue()) {
                    params.brandingInformation.splash.size = [CHIPContentLauncherClusterDimension new];
                    params.brandingInformation.splash.size.width =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().splash.Value().size.Value().width];
                    params.brandingInformation.splash.size.height =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().splash.Value().size.Value().height];
                    params.brandingInformation.splash.size.metric = [NSNumber
                        numberWithUnsignedChar:chip::to_underlying(
                                                   mRequest.brandingInformation.Value().splash.Value().size.Value().metric)];
                } else {
                    params.brandingInformation.splash.size = nil;
                }
            } else {
                params.brandingInformation.splash = nil;
            }
            if (mRequest.brandingInformation.Value().waterMark.HasValue()) {
                params.brandingInformation.waterMark = [CHIPContentLauncherClusterStyleInformation new];
                if (mRequest.brandingInformation.Value().waterMark.Value().imageUrl.HasValue()) {
                    params.brandingInformation.waterMark.imageUrl = [[NSString alloc]
                        initWithBytes:mRequest.brandingInformation.Value().waterMark.Value().imageUrl.Value().data()
                               length:mRequest.brandingInformation.Value().waterMark.Value().imageUrl.Value().size()
                             encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.waterMark.imageUrl = nil;
                }
                if (mRequest.brandingInformation.Value().waterMark.Value().color.HasValue()) {
                    params.brandingInformation.waterMark.color =
                        [[NSString alloc] initWithBytes:mRequest.brandingInformation.Value().waterMark.Value().color.Value().data()
                                                 length:mRequest.brandingInformation.Value().waterMark.Value().color.Value().size()
                                               encoding:NSUTF8StringEncoding];
                } else {
                    params.brandingInformation.waterMark.color = nil;
                }
                if (mRequest.brandingInformation.Value().waterMark.Value().size.HasValue()) {
                    params.brandingInformation.waterMark.size = [CHIPContentLauncherClusterDimension new];
                    params.brandingInformation.waterMark.size.width =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().waterMark.Value().size.Value().width];
                    params.brandingInformation.waterMark.size.height =
                        [NSNumber numberWithDouble:mRequest.brandingInformation.Value().waterMark.Value().size.Value().height];
                    params.brandingInformation.waterMark.size.metric = [NSNumber
                        numberWithUnsignedChar:chip::to_underlying(
                                                   mRequest.brandingInformation.Value().waterMark.Value().size.Value().metric)];
                } else {
                    params.brandingInformation.waterMark.size = nil;
                }
            } else {
                params.brandingInformation.waterMark = nil;
            }
        } else {
            params.brandingInformation = nil;
        }
        [cluster
            launchURLWithParams:params
              completionHandler:^(CHIPContentLauncherClusterLaunchResponseParams * _Nullable values, NSError * _Nullable error) {
                  NSLog(@"Values: %@", values);
                  chipError = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                  SetCommandExitStatus(chipError);
              }];
        return chipError;
    }

private:
    chip::ByteSpan mContentURL;
    chip::ByteSpan mDisplayString;
    chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type mRequest;
    TypedComplexArgument<chip::Optional<chip::app::Clusters::ContentLauncher::Structs::BrandingInformation::Type>>
        mComplex_BrandingInformation;
};

/*
 * Attribute AcceptHeader
 */
class ReadContentLauncherAcceptHeader : public ModelCommand {
public:
    ReadContentLauncherAcceptHeader()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accept-header");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAcceptHeader() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptHeaderWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.AcceptHeader response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher AcceptHeader Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeContentLauncherAcceptHeader : public ModelCommand {
public:
    SubscribeAttributeContentLauncherAcceptHeader()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accept-header");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherAcceptHeader() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptHeaderWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ContentLauncher.AcceptHeader response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedStreamingProtocols
 */
class ReadContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    ReadContentLauncherSupportedStreamingProtocols()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeSupportedStreamingProtocolsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ContentLauncher.SupportedStreamingProtocols response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ContentLauncher SupportedStreamingProtocols Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    WriteContentLauncherSupportedStreamingProtocols()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) WriteAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster
            writeAttributeSupportedStreamingProtocolsWithValue:value
                                             completionHandler:^(NSError * _Nullable error) {
                                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                                 ChipLogError(chipTool, "ContentLauncher SupportedStreamingProtocols Error: %s",
                                                     chip::ErrorStr(chipError));
                                                 SetCommandExitStatus(chipError);
                                             }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    SubscribeAttributeContentLauncherSupportedStreamingProtocols()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSupportedStreamingProtocolsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ContentLauncher.SupportedStreamingProtocols response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadContentLauncherGeneratedCommandList : public ModelCommand {
public:
    ReadContentLauncherGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeContentLauncherGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeContentLauncherGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ContentLauncher.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadContentLauncherAcceptedCommandList : public ModelCommand {
public:
    ReadContentLauncherAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeContentLauncherAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeContentLauncherAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ContentLauncher.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadContentLauncherAttributeList : public ModelCommand {
public:
    ReadContentLauncherAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeContentLauncherAttributeList : public ModelCommand {
public:
    SubscribeAttributeContentLauncherAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ContentLauncher.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadContentLauncherClusterRevision : public ModelCommand {
public:
    ReadContentLauncherClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeContentLauncherClusterRevision : public ModelCommand {
public:
    SubscribeAttributeContentLauncherClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ContentLauncher.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Descriptor                                                  | 0x001D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DeviceList                                                        | 0x0000 |
| * ServerList                                                        | 0x0001 |
| * ClientList                                                        | 0x0002 |
| * PartsList                                                         | 0x0003 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute DeviceList
 */
class ReadDescriptorDeviceList : public ModelCommand {
public:
    ReadDescriptorDeviceList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "device-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorDeviceList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDeviceListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.DeviceList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor DeviceList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorDeviceList : public ModelCommand {
public:
    SubscribeAttributeDescriptorDeviceList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "device-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorDeviceList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDeviceListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Descriptor.DeviceList response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerList
 */
class ReadDescriptorServerList : public ModelCommand {
public:
    ReadDescriptorServerList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorServerList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeServerListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ServerList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ServerList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorServerList : public ModelCommand {
public:
    SubscribeAttributeDescriptorServerList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorServerList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeServerListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Descriptor.ServerList response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientList
 */
class ReadDescriptorClientList : public ModelCommand {
public:
    ReadDescriptorClientList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClientList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClientListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ClientList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ClientList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorClientList : public ModelCommand {
public:
    SubscribeAttributeDescriptorClientList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorClientList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClientListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Descriptor.ClientList response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartsList
 */
class ReadDescriptorPartsList : public ModelCommand {
public:
    ReadDescriptorPartsList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "parts-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorPartsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartsListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.PartsList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor PartsList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorPartsList : public ModelCommand {
public:
    SubscribeAttributeDescriptorPartsList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "parts-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorPartsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartsListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"Descriptor.PartsList response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadDescriptorGeneratedCommandList : public ModelCommand {
public:
    ReadDescriptorGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDescriptorGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Descriptor.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadDescriptorAcceptedCommandList : public ModelCommand {
public:
    ReadDescriptorAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeDescriptorAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"Descriptor.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDescriptorAttributeList : public ModelCommand {
public:
    ReadDescriptorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorAttributeList : public ModelCommand {
public:
    SubscribeAttributeDescriptorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Descriptor.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadDescriptorClusterRevision : public ModelCommand {
public:
    ReadDescriptorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorClusterRevision : public ModelCommand {
public:
    SubscribeAttributeDescriptorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Descriptor.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster DiagnosticLogs                                              | 0x0032 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * RetrieveLogsRequest                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RetrieveLogsRequest
 */
class DiagnosticLogsRetrieveLogsRequest : public ModelCommand {
public:
    DiagnosticLogsRetrieveLogsRequest()
        : ModelCommand("retrieve-logs-request")
    {
        AddArgument("Intent", 0, UINT8_MAX, &mIntent);
        AddArgument("RequestedProtocol", 0, UINT8_MAX, &mRequestedProtocol);
        AddArgument("TransferFileDesignator", &mTransferFileDesignator);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDiagnosticLogsClusterRetrieveLogsRequestParams alloc] init];

        params.intent = [NSNumber numberWithUnsignedChar:mIntent];

        params.requestedProtocol = [NSNumber numberWithUnsignedChar:mRequestedProtocol];

        params.transferFileDesignator = [[NSData alloc] initWithBytes:mTransferFileDesignator.data()
                                                               length:mTransferFileDesignator.size()];
        [cluster retrieveLogsRequestWithParams:params
                             completionHandler:^(CHIPDiagnosticLogsClusterRetrieveLogsResponseParams * _Nullable values,
                                 NSError * _Nullable error) {
                                 NSLog(@"Values: %@", values);
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint8_t mIntent;
    uint8_t mRequestedProtocol;
    chip::ByteSpan mTransferFileDesignator;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadDiagnosticLogsGeneratedCommandList : public ModelCommand {
public:
    ReadDiagnosticLogsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DiagnosticLogs.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DiagnosticLogs GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDiagnosticLogsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDiagnosticLogsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDiagnosticLogsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"DiagnosticLogs.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadDiagnosticLogsAcceptedCommandList : public ModelCommand {
public:
    ReadDiagnosticLogsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DiagnosticLogs.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DiagnosticLogs AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDiagnosticLogsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeDiagnosticLogsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDiagnosticLogsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"DiagnosticLogs.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDiagnosticLogsAttributeList : public ModelCommand {
public:
    ReadDiagnosticLogsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DiagnosticLogs.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DiagnosticLogs AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDiagnosticLogsAttributeList : public ModelCommand {
public:
    SubscribeAttributeDiagnosticLogsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDiagnosticLogsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"DiagnosticLogs.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster DoorLock                                                    | 0x0101 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LockDoor                                                          |   0x00 |
| * UnlockDoor                                                        |   0x01 |
| * UnlockWithTimeout                                                 |   0x03 |
| * GetLogRecord                                                      |   0x04 |
| * SetPINCode                                                        |   0x05 |
| * GetPINCode                                                        |   0x06 |
| * ClearPINCode                                                      |   0x07 |
| * ClearAllPINCodes                                                  |   0x08 |
| * SetUserStatus                                                     |   0x09 |
| * GetUserStatus                                                     |   0x0A |
| * SetWeekDaySchedule                                                |   0x0B |
| * GetWeekDaySchedule                                                |   0x0C |
| * ClearWeekDaySchedule                                              |   0x0D |
| * SetYearDaySchedule                                                |   0x0E |
| * GetYearDaySchedule                                                |   0x0F |
| * ClearYearDaySchedule                                              |   0x10 |
| * SetHolidaySchedule                                                |   0x11 |
| * GetHolidaySchedule                                                |   0x12 |
| * ClearHolidaySchedule                                              |   0x13 |
| * SetUserType                                                       |   0x14 |
| * GetUserType                                                       |   0x15 |
| * SetRFIDCode                                                       |   0x16 |
| * GetRFIDCode                                                       |   0x17 |
| * ClearRFIDCode                                                     |   0x18 |
| * ClearAllRFIDCodes                                                 |   0x19 |
| * SetUser                                                           |   0x1A |
| * GetUser                                                           |   0x1B |
| * ClearUser                                                         |   0x1D |
| * SetCredential                                                     |   0x22 |
| * GetCredentialStatus                                               |   0x24 |
| * ClearCredential                                                   |   0x26 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LockState                                                         | 0x0000 |
| * LockType                                                          | 0x0001 |
| * ActuatorEnabled                                                   | 0x0002 |
| * DoorState                                                         | 0x0003 |
| * DoorOpenEvents                                                    | 0x0004 |
| * DoorClosedEvents                                                  | 0x0005 |
| * OpenPeriod                                                        | 0x0006 |
| * NumberOfLogRecordsSupported                                       | 0x0010 |
| * NumberOfTotalUsersSupported                                       | 0x0011 |
| * NumberOfPINUsersSupported                                         | 0x0012 |
| * NumberOfRFIDUsersSupported                                        | 0x0013 |
| * NumberOfWeekDaySchedulesSupportedPerUser                          | 0x0014 |
| * NumberOfYearDaySchedulesSupportedPerUser                          | 0x0015 |
| * NumberOfHolidaySchedulesSupported                                 | 0x0016 |
| * MaxPINCodeLength                                                  | 0x0017 |
| * MinPINCodeLength                                                  | 0x0018 |
| * MaxRFIDCodeLength                                                 | 0x0019 |
| * MinRFIDCodeLength                                                 | 0x001A |
| * CredentialRulesSupport                                            | 0x001B |
| * EnableLogging                                                     | 0x0020 |
| * Language                                                          | 0x0021 |
| * LEDSettings                                                       | 0x0022 |
| * AutoRelockTime                                                    | 0x0023 |
| * SoundVolume                                                       | 0x0024 |
| * OperatingMode                                                     | 0x0025 |
| * SupportedOperatingModes                                           | 0x0026 |
| * DefaultConfigurationRegister                                      | 0x0027 |
| * EnableLocalProgramming                                            | 0x0028 |
| * EnableOneTouchLocking                                             | 0x0029 |
| * EnableInsideStatusLED                                             | 0x002A |
| * EnablePrivacyModeButton                                           | 0x002B |
| * LocalProgrammingFeatures                                          | 0x002C |
| * WrongCodeEntryLimit                                               | 0x0030 |
| * UserCodeTemporaryDisableTime                                      | 0x0031 |
| * SendPINOverTheAir                                                 | 0x0032 |
| * RequirePINforRemoteOperation                                      | 0x0033 |
| * ExpiringUserTimeout                                               | 0x0035 |
| * AlarmMask                                                         | 0x0040 |
| * KeypadOperationEventMask                                          | 0x0041 |
| * RemoteOperationEventMask                                          | 0x0042 |
| * ManualOperationEventMask                                          | 0x0043 |
| * RFIDOperationEventMask                                            | 0x0044 |
| * KeypadProgrammingEventMask                                        | 0x0045 |
| * RemoteProgrammingEventMask                                        | 0x0046 |
| * RFIDProgrammingEventMask                                          | 0x0047 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * DoorLockAlarm                                                     | 0x0000 |
| * DoorStateChange                                                   | 0x0001 |
| * LockOperation                                                     | 0x0002 |
| * LockOperationError                                                | 0x0003 |
| * LockUserChange                                                    | 0x0004 |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearCredential
 */
class DoorLockClearCredential : public ModelCommand {
public:
    DoorLockClearCredential()
        : ModelCommand("clear-credential")
        , mComplex_Credential(&mRequest.credential)
    {
        AddArgument("Credential", &mComplex_Credential);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000026) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearCredentialParams alloc] init];

        if (mRequest.credential.IsNull()) {
            params.credential = nil;
        } else {
            params.credential = [CHIPDoorLockClusterDlCredential new];
            params.credential.credentialType =
                [NSNumber numberWithUnsignedChar:chip::to_underlying(mRequest.credential.Value().credentialType)];
            params.credential.credentialIndex = [NSNumber numberWithUnsignedShort:mRequest.credential.Value().credentialIndex];
        }
        [cluster clearCredentialWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             chipError = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                             SetCommandExitStatus(chipError);
                         }];
        return chipError;
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearCredential::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::Structs::DlCredential::Type>>
        mComplex_Credential;
};

/*
 * Command ClearHolidaySchedule
 */
class DoorLockClearHolidaySchedule : public ModelCommand {
public:
    DoorLockClearHolidaySchedule()
        : ModelCommand("clear-holiday-schedule")
    {
        AddArgument("HolidayIndex", 0, UINT8_MAX, &mHolidayIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearHolidayScheduleParams alloc] init];

        params.holidayIndex = [NSNumber numberWithUnsignedChar:mHolidayIndex];
        [cluster clearHolidayScheduleWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mHolidayIndex;
};

/*
 * Command ClearUser
 */
class DoorLockClearUser : public ModelCommand {
public:
    DoorLockClearUser()
        : ModelCommand("clear-user")
    {
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearUserParams alloc] init];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearUserWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       chipError = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                       SetCommandExitStatus(chipError);
                   }];
        return chipError;
    }

private:
    uint16_t mUserIndex;
};

/*
 * Command ClearWeekDaySchedule
 */
class DoorLockClearWeekDaySchedule : public ModelCommand {
public:
    DoorLockClearWeekDaySchedule()
        : ModelCommand("clear-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearWeekDayScheduleParams alloc] init];

        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearWeekDayScheduleWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command ClearYearDaySchedule
 */
class DoorLockClearYearDaySchedule : public ModelCommand {
public:
    DoorLockClearYearDaySchedule()
        : ModelCommand("clear-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearYearDayScheduleParams alloc] init];

        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearYearDayScheduleWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command GetCredentialStatus
 */
class DoorLockGetCredentialStatus : public ModelCommand {
public:
    DoorLockGetCredentialStatus()
        : ModelCommand("get-credential-status")
        , mComplex_Credential(&mRequest.credential)
    {
        AddArgument("Credential", &mComplex_Credential);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000024) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetCredentialStatusParams alloc] init];

        params.credential = [CHIPDoorLockClusterDlCredential new];
        params.credential.credentialType =
            [NSNumber numberWithUnsignedChar:chip::to_underlying(mRequest.credential.credentialType)];
        params.credential.credentialIndex = [NSNumber numberWithUnsignedShort:mRequest.credential.credentialIndex];
        [cluster getCredentialStatusWithParams:params
                             completionHandler:^(CHIPDoorLockClusterGetCredentialStatusResponseParams * _Nullable values,
                                 NSError * _Nullable error) {
                                 NSLog(@"Values: %@", values);
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::DoorLock::Structs::DlCredential::Type> mComplex_Credential;
};

/*
 * Command GetHolidaySchedule
 */
class DoorLockGetHolidaySchedule : public ModelCommand {
public:
    DoorLockGetHolidaySchedule()
        : ModelCommand("get-holiday-schedule")
    {
        AddArgument("HolidayIndex", 0, UINT8_MAX, &mHolidayIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetHolidayScheduleParams alloc] init];

        params.holidayIndex = [NSNumber numberWithUnsignedChar:mHolidayIndex];
        [cluster getHolidayScheduleWithParams:params
                            completionHandler:^(
                                CHIPDoorLockClusterGetHolidayScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mHolidayIndex;
};

/*
 * Command GetUser
 */
class DoorLockGetUser : public ModelCommand {
public:
    DoorLockGetUser()
        : ModelCommand("get-user")
    {
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetUserParams alloc] init];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getUserWithParams:params
                 completionHandler:^(CHIPDoorLockClusterGetUserResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     chipError = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                     SetCommandExitStatus(chipError);
                 }];
        return chipError;
    }

private:
    uint16_t mUserIndex;
};

/*
 * Command GetWeekDaySchedule
 */
class DoorLockGetWeekDaySchedule : public ModelCommand {
public:
    DoorLockGetWeekDaySchedule()
        : ModelCommand("get-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetWeekDayScheduleParams alloc] init];

        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getWeekDayScheduleWithParams:params
                            completionHandler:^(
                                CHIPDoorLockClusterGetWeekDayScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command GetYearDaySchedule
 */
class DoorLockGetYearDaySchedule : public ModelCommand {
public:
    DoorLockGetYearDaySchedule()
        : ModelCommand("get-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetYearDayScheduleParams alloc] init];

        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getYearDayScheduleWithParams:params
                            completionHandler:^(
                                CHIPDoorLockClusterGetYearDayScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command LockDoor
 */
class DoorLockLockDoor : public ModelCommand {
public:
    DoorLockLockDoor()
        : ModelCommand("lock-door")
    {
        AddArgument("PinCode", &mPinCode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterLockDoorParams alloc] init];

        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster lockDoorWithParams:params
                  completionHandler:^(NSError * _Nullable error) {
                      chipError = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                      SetCommandExitStatus(chipError);
                  }];
        return chipError;
    }

private:
    chip::ByteSpan mPinCode;
};

/*
 * Command SetCredential
 */
class DoorLockSetCredential : public ModelCommand {
public:
    DoorLockSetCredential()
        : ModelCommand("set-credential")
        , mComplex_Credential(&mRequest.credential)
    {
        AddArgument("OperationType", 0, UINT8_MAX, &mOperationType);
        AddArgument("Credential", &mComplex_Credential);
        AddArgument("CredentialData", &mCredentialData);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("UserStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("UserType", 0, UINT8_MAX, &mUserType);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000022) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetCredentialParams alloc] init];

        params.operationType = [NSNumber numberWithUnsignedChar:mOperationType];

        params.credential = [CHIPDoorLockClusterDlCredential new];
        params.credential.credentialType =
            [NSNumber numberWithUnsignedChar:chip::to_underlying(mRequest.credential.credentialType)];
        params.credential.credentialIndex = [NSNumber numberWithUnsignedShort:mRequest.credential.credentialIndex];

        params.credentialData = [[NSData alloc] initWithBytes:mCredentialData.data() length:mCredentialData.size()];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];

        params.userStatus = [NSNumber numberWithUnsignedChar:mUserStatus];

        params.userType = [NSNumber numberWithUnsignedChar:mUserType];
        [cluster setCredentialWithParams:params
                       completionHandler:^(
                           CHIPDoorLockClusterSetCredentialResponseParams * _Nullable values, NSError * _Nullable error) {
                           NSLog(@"Values: %@", values);
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint8_t mOperationType;
    chip::app::Clusters::DoorLock::Commands::SetCredential::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::DoorLock::Structs::DlCredential::Type> mComplex_Credential;
    chip::ByteSpan mCredentialData;
    uint16_t mUserIndex;
    uint8_t mUserStatus;
    uint8_t mUserType;
};

/*
 * Command SetHolidaySchedule
 */
class DoorLockSetHolidaySchedule : public ModelCommand {
public:
    DoorLockSetHolidaySchedule()
        : ModelCommand("set-holiday-schedule")
    {
        AddArgument("HolidayIndex", 0, UINT8_MAX, &mHolidayIndex);
        AddArgument("LocalStartTime", 0, UINT32_MAX, &mLocalStartTime);
        AddArgument("LocalEndTime", 0, UINT32_MAX, &mLocalEndTime);
        AddArgument("OperatingMode", 0, UINT8_MAX, &mOperatingMode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetHolidayScheduleParams alloc] init];

        params.holidayIndex = [NSNumber numberWithUnsignedChar:mHolidayIndex];

        params.localStartTime = [NSNumber numberWithUnsignedInt:mLocalStartTime];

        params.localEndTime = [NSNumber numberWithUnsignedInt:mLocalEndTime];

        params.operatingMode = [NSNumber numberWithUnsignedChar:mOperatingMode];
        [cluster setHolidayScheduleWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mHolidayIndex;
    uint32_t mLocalStartTime;
    uint32_t mLocalEndTime;
    uint8_t mOperatingMode;
};

/*
 * Command SetUser
 */
class DoorLockSetUser : public ModelCommand {
public:
    DoorLockSetUser()
        : ModelCommand("set-user")
    {
        AddArgument("OperationType", 0, UINT8_MAX, &mOperationType);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("UserName", &mUserName);
        AddArgument("UserUniqueId", 0, UINT32_MAX, &mUserUniqueId);
        AddArgument("UserStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("UserType", 0, UINT8_MAX, &mUserType);
        AddArgument("CredentialRule", 0, UINT8_MAX, &mCredentialRule);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetUserParams alloc] init];

        params.operationType = [NSNumber numberWithUnsignedChar:mOperationType];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];

        params.userName = [[NSString alloc] initWithBytes:mUserName.data() length:mUserName.size() encoding:NSUTF8StringEncoding];

        params.userUniqueId = [NSNumber numberWithUnsignedInt:mUserUniqueId];

        params.userStatus = [NSNumber numberWithUnsignedChar:mUserStatus];

        params.userType = [NSNumber numberWithUnsignedChar:mUserType];

        params.credentialRule = [NSNumber numberWithUnsignedChar:mCredentialRule];
        [cluster setUserWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     chipError = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                     SetCommandExitStatus(chipError);
                 }];
        return chipError;
    }

private:
    uint8_t mOperationType;
    uint16_t mUserIndex;
    chip::ByteSpan mUserName;
    uint32_t mUserUniqueId;
    uint8_t mUserStatus;
    uint8_t mUserType;
    uint8_t mCredentialRule;
};

/*
 * Command SetWeekDaySchedule
 */
class DoorLockSetWeekDaySchedule : public ModelCommand {
public:
    DoorLockSetWeekDaySchedule()
        : ModelCommand("set-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("DaysMask", 0, UINT8_MAX, &mDaysMask);
        AddArgument("StartHour", 0, UINT8_MAX, &mStartHour);
        AddArgument("StartMinute", 0, UINT8_MAX, &mStartMinute);
        AddArgument("EndHour", 0, UINT8_MAX, &mEndHour);
        AddArgument("EndMinute", 0, UINT8_MAX, &mEndMinute);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetWeekDayScheduleParams alloc] init];

        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];

        params.daysMask = [NSNumber numberWithUnsignedChar:mDaysMask];

        params.startHour = [NSNumber numberWithUnsignedChar:mStartHour];

        params.startMinute = [NSNumber numberWithUnsignedChar:mStartMinute];

        params.endHour = [NSNumber numberWithUnsignedChar:mEndHour];

        params.endMinute = [NSNumber numberWithUnsignedChar:mEndMinute];
        [cluster setWeekDayScheduleWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
    uint8_t mDaysMask;
    uint8_t mStartHour;
    uint8_t mStartMinute;
    uint8_t mEndHour;
    uint8_t mEndMinute;
};

/*
 * Command SetYearDaySchedule
 */
class DoorLockSetYearDaySchedule : public ModelCommand {
public:
    DoorLockSetYearDaySchedule()
        : ModelCommand("set-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("LocalStartTime", 0, UINT32_MAX, &mLocalStartTime);
        AddArgument("LocalEndTime", 0, UINT32_MAX, &mLocalEndTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetYearDayScheduleParams alloc] init];

        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];

        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];

        params.localStartTime = [NSNumber numberWithUnsignedInt:mLocalStartTime];

        params.localEndTime = [NSNumber numberWithUnsignedInt:mLocalEndTime];
        [cluster setYearDayScheduleWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
    uint32_t mLocalStartTime;
    uint32_t mLocalEndTime;
};

/*
 * Command UnlockDoor
 */
class DoorLockUnlockDoor : public ModelCommand {
public:
    DoorLockUnlockDoor()
        : ModelCommand("unlock-door")
    {
        AddArgument("PinCode", &mPinCode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterUnlockDoorParams alloc] init];

        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster unlockDoorWithParams:params
                    completionHandler:^(NSError * _Nullable error) {
                        chipError = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                        SetCommandExitStatus(chipError);
                    }];
        return chipError;
    }

private:
    chip::ByteSpan mPinCode;
};

/*
 * Command UnlockWithTimeout
 */
class DoorLockUnlockWithTimeout : public ModelCommand {
public:
    DoorLockUnlockWithTimeout()
        : ModelCommand("unlock-with-timeout")
    {
        AddArgument("Timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("PinCode", &mPinCode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterUnlockWithTimeoutParams alloc] init];

        params.timeout = [NSNumber numberWithUnsignedShort:mTimeout];

        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster unlockWithTimeoutWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               chipError = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                               SetCommandExitStatus(chipError);
                           }];
        return chipError;
    }

private:
    uint16_t mTimeout;
    chip::ByteSpan mPinCode;
};

/*
 * Attribute LockState
 */
class ReadDoorLockLockState : public ModelCommand {
public:
    ReadDoorLockLockState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLockStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.LockState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock LockState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockLockState : public ModelCommand {
public:
    SubscribeAttributeDoorLockLockState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lock-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockLockState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLockStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"DoorLock.LockState response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LockType
 */
class ReadDoorLockLockType : public ModelCommand {
public:
    ReadDoorLockLockType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-type");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLockTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.LockType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock LockType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockLockType : public ModelCommand {
public:
    SubscribeAttributeDoorLockLockType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lock-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockLockType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLockTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"DoorLock.LockType response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActuatorEnabled
 */
class ReadDoorLockActuatorEnabled : public ModelCommand {
public:
    ReadDoorLockActuatorEnabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "actuator-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockActuatorEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActuatorEnabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.ActuatorEnabled response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock ActuatorEnabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockActuatorEnabled : public ModelCommand {
public:
    SubscribeAttributeDoorLockActuatorEnabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "actuator-enabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockActuatorEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActuatorEnabledWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"DoorLock.ActuatorEnabled response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DoorState
 */
class ReadDoorLockDoorState : public ModelCommand {
public:
    ReadDoorLockDoorState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "door-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockDoorState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDoorStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.DoorState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock DoorState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockDoorState : public ModelCommand {
public:
    SubscribeAttributeDoorLockDoorState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "door-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockDoorState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDoorStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"DoorLock.DoorState response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfTotalUsersSupported
 */
class ReadDoorLockNumberOfTotalUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfTotalUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-total-users-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfTotalUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfTotalUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfTotalUsersSupported response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfTotalUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfTotalUsersSupported : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfTotalUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-total-users-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfTotalUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfTotalUsersSupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"DoorLock.NumberOfTotalUsersSupported response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPINUsersSupported
 */
class ReadDoorLockNumberOfPINUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfPINUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-pinusers-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfPINUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfPINUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfPINUsersSupported response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfPINUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfPINUsersSupported : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfPINUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-pinusers-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfPINUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfPINUsersSupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"DoorLock.NumberOfPINUsersSupported response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfRFIDUsersSupported
 */
class ReadDoorLockNumberOfRFIDUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfRFIDUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-rfidusers-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfRFIDUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfRFIDUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfRFIDUsersSupported response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfRFIDUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfRFIDUsersSupported : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfRFIDUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-rfidusers-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfRFIDUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfRFIDUsersSupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"DoorLock.NumberOfRFIDUsersSupported response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfWeekDaySchedulesSupportedPerUser
 */
class ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser : public ModelCommand {
public:
    ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-week-day-schedules-supported-per-user");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000014) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfWeekDaySchedulesSupportedPerUserWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.NumberOfWeekDaySchedulesSupportedPerUser response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock NumberOfWeekDaySchedulesSupportedPerUser Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfWeekDaySchedulesSupportedPerUser : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfWeekDaySchedulesSupportedPerUser()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-week-day-schedules-supported-per-user");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfWeekDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfWeekDaySchedulesSupportedPerUserWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                               params:params
                                                              subscriptionEstablished:nullptr
                                                                        reportHandler:^(
                                                                            NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                            NSLog(@"DoorLock."
                                                                                  @"NumberOfWeekDaySchedulesSupportedPerUser "
                                                                                  @"response %@",
                                                                                [value description]);
                                                                            if (error || !mWait) {
                                                                                SetCommandExitStatus(
                                                                                    [CHIPError errorToCHIPErrorCode:error]);
                                                                            }
                                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfYearDaySchedulesSupportedPerUser
 */
class ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser : public ModelCommand {
public:
    ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-year-day-schedules-supported-per-user");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000015) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfYearDaySchedulesSupportedPerUserWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.NumberOfYearDaySchedulesSupportedPerUser response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock NumberOfYearDaySchedulesSupportedPerUser Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfYearDaySchedulesSupportedPerUser : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfYearDaySchedulesSupportedPerUser()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-year-day-schedules-supported-per-user");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfYearDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfYearDaySchedulesSupportedPerUserWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                               params:params
                                                              subscriptionEstablished:nullptr
                                                                        reportHandler:^(
                                                                            NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                            NSLog(@"DoorLock."
                                                                                  @"NumberOfYearDaySchedulesSupportedPerUser "
                                                                                  @"response %@",
                                                                                [value description]);
                                                                            if (error || !mWait) {
                                                                                SetCommandExitStatus(
                                                                                    [CHIPError errorToCHIPErrorCode:error]);
                                                                            }
                                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfHolidaySchedulesSupported
 */
class ReadDoorLockNumberOfHolidaySchedulesSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfHolidaySchedulesSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-holiday-schedules-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfHolidaySchedulesSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000016) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfHolidaySchedulesSupportedWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.NumberOfHolidaySchedulesSupported response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock NumberOfHolidaySchedulesSupported Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfHolidaySchedulesSupported : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfHolidaySchedulesSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-holiday-schedules-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfHolidaySchedulesSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfHolidaySchedulesSupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                        params:params
                                                       subscriptionEstablished:nullptr
                                                                 reportHandler:^(
                                                                     NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                     NSLog(
                                                                         @"DoorLock.NumberOfHolidaySchedulesSupported response %@",
                                                                         [value description]);
                                                                     if (error || !mWait) {
                                                                         SetCommandExitStatus(
                                                                             [CHIPError errorToCHIPErrorCode:error]);
                                                                     }
                                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxPINCodeLength
 */
class ReadDoorLockMaxPINCodeLength : public ModelCommand {
public:
    ReadDoorLockMaxPINCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pincode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMaxPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000017) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxPINCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MaxPINCodeLength response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MaxPINCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockMaxPINCodeLength : public ModelCommand {
public:
    SubscribeAttributeDoorLockMaxPINCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-pincode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockMaxPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxPINCodeLengthWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"DoorLock.MaxPINCodeLength response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinPINCodeLength
 */
class ReadDoorLockMinPINCodeLength : public ModelCommand {
public:
    ReadDoorLockMinPINCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-pincode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMinPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000018) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinPINCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MinPINCodeLength response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MinPINCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockMinPINCodeLength : public ModelCommand {
public:
    SubscribeAttributeDoorLockMinPINCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-pincode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockMinPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000018) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinPINCodeLengthWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"DoorLock.MinPINCodeLength response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxRFIDCodeLength
 */
class ReadDoorLockMaxRFIDCodeLength : public ModelCommand {
public:
    ReadDoorLockMaxRFIDCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-rfidcode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMaxRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000019) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxRFIDCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MaxRFIDCodeLength response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MaxRFIDCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockMaxRFIDCodeLength : public ModelCommand {
public:
    SubscribeAttributeDoorLockMaxRFIDCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-rfidcode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockMaxRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxRFIDCodeLengthWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"DoorLock.MaxRFIDCodeLength response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinRFIDCodeLength
 */
class ReadDoorLockMinRFIDCodeLength : public ModelCommand {
public:
    ReadDoorLockMinRFIDCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-rfidcode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMinRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000001A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinRFIDCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MinRFIDCodeLength response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MinRFIDCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockMinRFIDCodeLength : public ModelCommand {
public:
    SubscribeAttributeDoorLockMinRFIDCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-rfidcode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockMinRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000001A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinRFIDCodeLengthWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"DoorLock.MinRFIDCodeLength response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Language
 */
class ReadDoorLockLanguage : public ModelCommand {
public:
    ReadDoorLockLanguage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "language");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000021) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLanguageWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.Language response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock Language Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockLanguage : public ModelCommand {
public:
    WriteDoorLockLanguage()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "language");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLanguageWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "DoorLock Language Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeDoorLockLanguage : public ModelCommand {
public:
    SubscribeAttributeDoorLockLanguage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "language");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLanguageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"DoorLock.Language response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AutoRelockTime
 */
class ReadDoorLockAutoRelockTime : public ModelCommand {
public:
    ReadDoorLockAutoRelockTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "auto-relock-time");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000023) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAutoRelockTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.AutoRelockTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock AutoRelockTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockAutoRelockTime : public ModelCommand {
public:
    WriteDoorLockAutoRelockTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "auto-relock-time");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000023) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeAutoRelockTimeWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "DoorLock AutoRelockTime Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeDoorLockAutoRelockTime : public ModelCommand {
public:
    SubscribeAttributeDoorLockAutoRelockTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "auto-relock-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000023) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAutoRelockTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"DoorLock.AutoRelockTime response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoundVolume
 */
class ReadDoorLockSoundVolume : public ModelCommand {
public:
    ReadDoorLockSoundVolume()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "sound-volume");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000024) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoundVolumeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.SoundVolume response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock SoundVolume Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockSoundVolume : public ModelCommand {
public:
    WriteDoorLockSoundVolume()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "sound-volume");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000024) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeSoundVolumeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "DoorLock SoundVolume Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeDoorLockSoundVolume : public ModelCommand {
public:
    SubscribeAttributeDoorLockSoundVolume()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "sound-volume");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000024) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSoundVolumeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"DoorLock.SoundVolume response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperatingMode
 */
class ReadDoorLockOperatingMode : public ModelCommand {
public:
    ReadDoorLockOperatingMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operating-mode");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000025) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOperatingModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.OperatingMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock OperatingMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockOperatingMode : public ModelCommand {
public:
    WriteDoorLockOperatingMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "operating-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000025) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOperatingModeWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        chipError = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "DoorLock OperatingMode Error: %s", chip::ErrorStr(chipError));
                                        SetCommandExitStatus(chipError);
                                    }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeDoorLockOperatingMode : public ModelCommand {
public:
    SubscribeAttributeDoorLockOperatingMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operating-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000025) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOperatingModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"DoorLock.OperatingMode response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedOperatingModes
 */
class ReadDoorLockSupportedOperatingModes : public ModelCommand {
public:
    ReadDoorLockSupportedOperatingModes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-operating-modes");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockSupportedOperatingModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000026) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeSupportedOperatingModesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.SupportedOperatingModes response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock SupportedOperatingModes Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockSupportedOperatingModes : public ModelCommand {
public:
    SubscribeAttributeDoorLockSupportedOperatingModes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-operating-modes");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockSupportedOperatingModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000026) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedOperatingModesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"DoorLock.SupportedOperatingModes response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnableOneTouchLocking
 */
class ReadDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    ReadDoorLockEnableOneTouchLocking()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000029) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnableOneTouchLockingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.EnableOneTouchLocking response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock EnableOneTouchLocking Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    WriteDoorLockEnableOneTouchLocking()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000029) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeEnableOneTouchLockingWithValue:value
                                            completionHandler:^(NSError * _Nullable error) {
                                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                                ChipLogError(chipTool, "DoorLock EnableOneTouchLocking Error: %s",
                                                    chip::ErrorStr(chipError));
                                                SetCommandExitStatus(chipError);
                                            }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    SubscribeAttributeDoorLockEnableOneTouchLocking()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000029) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeEnableOneTouchLockingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"DoorLock.EnableOneTouchLocking response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnablePrivacyModeButton
 */
class ReadDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    ReadDoorLockEnablePrivacyModeButton()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000002B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeEnablePrivacyModeButtonWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.EnablePrivacyModeButton response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock EnablePrivacyModeButton Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    WriteDoorLockEnablePrivacyModeButton()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x0000002B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeEnablePrivacyModeButtonWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                                  ChipLogError(chipTool, "DoorLock EnablePrivacyModeButton Error: %s",
                                                      chip::ErrorStr(chipError));
                                                  SetCommandExitStatus(chipError);
                                              }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    SubscribeAttributeDoorLockEnablePrivacyModeButton()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000002B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnablePrivacyModeButtonWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"DoorLock.EnablePrivacyModeButton response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WrongCodeEntryLimit
 */
class ReadDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    ReadDoorLockWrongCodeEntryLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000030) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWrongCodeEntryLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.WrongCodeEntryLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock WrongCodeEntryLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    WriteDoorLockWrongCodeEntryLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000030) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeWrongCodeEntryLimitWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(
                                                  chipTool, "DoorLock WrongCodeEntryLimit Error: %s", chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    SubscribeAttributeDoorLockWrongCodeEntryLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000030) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWrongCodeEntryLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"DoorLock.WrongCodeEntryLimit response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UserCodeTemporaryDisableTime
 */
class ReadDoorLockUserCodeTemporaryDisableTime : public ModelCommand {
public:
    ReadDoorLockUserCodeTemporaryDisableTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "user-code-temporary-disable-time");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockUserCodeTemporaryDisableTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000031) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUserCodeTemporaryDisableTimeWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.UserCodeTemporaryDisableTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock UserCodeTemporaryDisableTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockUserCodeTemporaryDisableTime : public ModelCommand {
public:
    WriteDoorLockUserCodeTemporaryDisableTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "user-code-temporary-disable-time");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockUserCodeTemporaryDisableTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000031) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeUserCodeTemporaryDisableTimeWithValue:value
                                                   completionHandler:^(NSError * _Nullable error) {
                                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                                       ChipLogError(chipTool, "DoorLock UserCodeTemporaryDisableTime Error: %s",
                                                           chip::ErrorStr(chipError));
                                                       SetCommandExitStatus(chipError);
                                                   }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeDoorLockUserCodeTemporaryDisableTime : public ModelCommand {
public:
    SubscribeAttributeDoorLockUserCodeTemporaryDisableTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "user-code-temporary-disable-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockUserCodeTemporaryDisableTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000031) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeUserCodeTemporaryDisableTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"DoorLock.UserCodeTemporaryDisableTime response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RequirePINforRemoteOperation
 */
class ReadDoorLockRequirePINforRemoteOperation : public ModelCommand {
public:
    ReadDoorLockRequirePINforRemoteOperation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "require-pinfor-remote-operation");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockRequirePINforRemoteOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000033) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRequirePINforRemoteOperationWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.RequirePINforRemoteOperation response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock RequirePINforRemoteOperation Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockRequirePINforRemoteOperation : public ModelCommand {
public:
    WriteDoorLockRequirePINforRemoteOperation()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "require-pinfor-remote-operation");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockRequirePINforRemoteOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000033) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeRequirePINforRemoteOperationWithValue:value
                                                   completionHandler:^(NSError * _Nullable error) {
                                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                                       ChipLogError(chipTool, "DoorLock RequirePINforRemoteOperation Error: %s",
                                                           chip::ErrorStr(chipError));
                                                       SetCommandExitStatus(chipError);
                                                   }];
        return chipError;
    }

private:
    bool mValue;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadDoorLockGeneratedCommandList : public ModelCommand {
public:
    ReadDoorLockGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDoorLockGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"DoorLock.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadDoorLockAcceptedCommandList : public ModelCommand {
public:
    ReadDoorLockAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeDoorLockAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"DoorLock.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDoorLockAttributeList : public ModelCommand {
public:
    ReadDoorLockAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockAttributeList : public ModelCommand {
public:
    SubscribeAttributeDoorLockAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"DoorLock.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadDoorLockClusterRevision : public ModelCommand {
public:
    ReadDoorLockClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockClusterRevision : public ModelCommand {
public:
    SubscribeAttributeDoorLockClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"DoorLock.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ElectricalMeasurement                                       | 0x0B04 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GetProfileInfoCommand                                             |   0x00 |
| * GetMeasurementProfileCommand                                      |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasurementType                                                   | 0x0000 |
| * DcVoltage                                                         | 0x0100 |
| * DcVoltageMin                                                      | 0x0101 |
| * DcVoltageMax                                                      | 0x0102 |
| * DcCurrent                                                         | 0x0103 |
| * DcCurrentMin                                                      | 0x0104 |
| * DcCurrentMax                                                      | 0x0105 |
| * DcPower                                                           | 0x0106 |
| * DcPowerMin                                                        | 0x0107 |
| * DcPowerMax                                                        | 0x0108 |
| * DcVoltageMultiplier                                               | 0x0200 |
| * DcVoltageDivisor                                                  | 0x0201 |
| * DcCurrentMultiplier                                               | 0x0202 |
| * DcCurrentDivisor                                                  | 0x0203 |
| * DcPowerMultiplier                                                 | 0x0204 |
| * DcPowerDivisor                                                    | 0x0205 |
| * AcFrequency                                                       | 0x0300 |
| * AcFrequencyMin                                                    | 0x0301 |
| * AcFrequencyMax                                                    | 0x0302 |
| * NeutralCurrent                                                    | 0x0303 |
| * TotalActivePower                                                  | 0x0304 |
| * TotalReactivePower                                                | 0x0305 |
| * TotalApparentPower                                                | 0x0306 |
| * Measured1stHarmonicCurrent                                        | 0x0307 |
| * Measured3rdHarmonicCurrent                                        | 0x0308 |
| * Measured5thHarmonicCurrent                                        | 0x0309 |
| * Measured7thHarmonicCurrent                                        | 0x030A |
| * Measured9thHarmonicCurrent                                        | 0x030B |
| * Measured11thHarmonicCurrent                                       | 0x030C |
| * MeasuredPhase1stHarmonicCurrent                                   | 0x030D |
| * MeasuredPhase3rdHarmonicCurrent                                   | 0x030E |
| * MeasuredPhase5thHarmonicCurrent                                   | 0x030F |
| * MeasuredPhase7thHarmonicCurrent                                   | 0x0310 |
| * MeasuredPhase9thHarmonicCurrent                                   | 0x0311 |
| * MeasuredPhase11thHarmonicCurrent                                  | 0x0312 |
| * AcFrequencyMultiplier                                             | 0x0400 |
| * AcFrequencyDivisor                                                | 0x0401 |
| * PowerMultiplier                                                   | 0x0402 |
| * PowerDivisor                                                      | 0x0403 |
| * HarmonicCurrentMultiplier                                         | 0x0404 |
| * PhaseHarmonicCurrentMultiplier                                    | 0x0405 |
| * InstantaneousVoltage                                              | 0x0500 |
| * InstantaneousLineCurrent                                          | 0x0501 |
| * InstantaneousActiveCurrent                                        | 0x0502 |
| * InstantaneousReactiveCurrent                                      | 0x0503 |
| * InstantaneousPower                                                | 0x0504 |
| * RmsVoltage                                                        | 0x0505 |
| * RmsVoltageMin                                                     | 0x0506 |
| * RmsVoltageMax                                                     | 0x0507 |
| * RmsCurrent                                                        | 0x0508 |
| * RmsCurrentMin                                                     | 0x0509 |
| * RmsCurrentMax                                                     | 0x050A |
| * ActivePower                                                       | 0x050B |
| * ActivePowerMin                                                    | 0x050C |
| * ActivePowerMax                                                    | 0x050D |
| * ReactivePower                                                     | 0x050E |
| * ApparentPower                                                     | 0x050F |
| * PowerFactor                                                       | 0x0510 |
| * AverageRmsVoltageMeasurementPeriod                                | 0x0511 |
| * AverageRmsUnderVoltageCounter                                     | 0x0513 |
| * RmsExtremeOverVoltagePeriod                                       | 0x0514 |
| * RmsExtremeUnderVoltagePeriod                                      | 0x0515 |
| * RmsVoltageSagPeriod                                               | 0x0516 |
| * RmsVoltageSwellPeriod                                             | 0x0517 |
| * AcVoltageMultiplier                                               | 0x0600 |
| * AcVoltageDivisor                                                  | 0x0601 |
| * AcCurrentMultiplier                                               | 0x0602 |
| * AcCurrentDivisor                                                  | 0x0603 |
| * AcPowerMultiplier                                                 | 0x0604 |
| * AcPowerDivisor                                                    | 0x0605 |
| * OverloadAlarmsMask                                                | 0x0700 |
| * VoltageOverload                                                   | 0x0701 |
| * CurrentOverload                                                   | 0x0702 |
| * AcOverloadAlarmsMask                                              | 0x0800 |
| * AcVoltageOverload                                                 | 0x0801 |
| * AcCurrentOverload                                                 | 0x0802 |
| * AcActivePowerOverload                                             | 0x0803 |
| * AcReactivePowerOverload                                           | 0x0804 |
| * AverageRmsOverVoltage                                             | 0x0805 |
| * AverageRmsUnderVoltage                                            | 0x0806 |
| * RmsExtremeOverVoltage                                             | 0x0807 |
| * RmsExtremeUnderVoltage                                            | 0x0808 |
| * RmsVoltageSag                                                     | 0x0809 |
| * RmsVoltageSwell                                                   | 0x080A |
| * LineCurrentPhaseB                                                 | 0x0901 |
| * ActiveCurrentPhaseB                                               | 0x0902 |
| * ReactiveCurrentPhaseB                                             | 0x0903 |
| * RmsVoltagePhaseB                                                  | 0x0905 |
| * RmsVoltageMinPhaseB                                               | 0x0906 |
| * RmsVoltageMaxPhaseB                                               | 0x0907 |
| * RmsCurrentPhaseB                                                  | 0x0908 |
| * RmsCurrentMinPhaseB                                               | 0x0909 |
| * RmsCurrentMaxPhaseB                                               | 0x090A |
| * ActivePowerPhaseB                                                 | 0x090B |
| * ActivePowerMinPhaseB                                              | 0x090C |
| * ActivePowerMaxPhaseB                                              | 0x090D |
| * ReactivePowerPhaseB                                               | 0x090E |
| * ApparentPowerPhaseB                                               | 0x090F |
| * PowerFactorPhaseB                                                 | 0x0910 |
| * AverageRmsVoltageMeasurementPeriodPhaseB                          | 0x0911 |
| * AverageRmsOverVoltageCounterPhaseB                                | 0x0912 |
| * AverageRmsUnderVoltageCounterPhaseB                               | 0x0913 |
| * RmsExtremeOverVoltagePeriodPhaseB                                 | 0x0914 |
| * RmsExtremeUnderVoltagePeriodPhaseB                                | 0x0915 |
| * RmsVoltageSagPeriodPhaseB                                         | 0x0916 |
| * RmsVoltageSwellPeriodPhaseB                                       | 0x0917 |
| * LineCurrentPhaseC                                                 | 0x0A01 |
| * ActiveCurrentPhaseC                                               | 0x0A02 |
| * ReactiveCurrentPhaseC                                             | 0x0A03 |
| * RmsVoltagePhaseC                                                  | 0x0A05 |
| * RmsVoltageMinPhaseC                                               | 0x0A06 |
| * RmsVoltageMaxPhaseC                                               | 0x0A07 |
| * RmsCurrentPhaseC                                                  | 0x0A08 |
| * RmsCurrentMinPhaseC                                               | 0x0A09 |
| * RmsCurrentMaxPhaseC                                               | 0x0A0A |
| * ActivePowerPhaseC                                                 | 0x0A0B |
| * ActivePowerMinPhaseC                                              | 0x0A0C |
| * ActivePowerMaxPhaseC                                              | 0x0A0D |
| * ReactivePowerPhaseC                                               | 0x0A0E |
| * ApparentPowerPhaseC                                               | 0x0A0F |
| * PowerFactorPhaseC                                                 | 0x0A10 |
| * AverageRmsVoltageMeasurementPeriodPhaseC                          | 0x0A11 |
| * AverageRmsOverVoltageCounterPhaseC                                | 0x0A12 |
| * AverageRmsUnderVoltageCounterPhaseC                               | 0x0A13 |
| * RmsExtremeOverVoltagePeriodPhaseC                                 | 0x0A14 |
| * RmsExtremeUnderVoltagePeriodPhaseC                                | 0x0A15 |
| * RmsVoltageSagPeriodPhaseC                                         | 0x0A16 |
| * RmsVoltageSwellPeriodPhaseC                                       | 0x0A17 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasurementType
 */
class ReadElectricalMeasurementMeasurementType : public ModelCommand {
public:
    ReadElectricalMeasurementMeasurementType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measurement-type");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementMeasurementType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasurementTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.MeasurementType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement MeasurementType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementMeasurementType : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementMeasurementType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measurement-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementMeasurementType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMeasurementTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ElectricalMeasurement.MeasurementType response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalActivePower
 */
class ReadElectricalMeasurementTotalActivePower : public ModelCommand {
public:
    ReadElectricalMeasurementTotalActivePower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "total-active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementTotalActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000304) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTotalActivePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.TotalActivePower response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement TotalActivePower Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementTotalActivePower : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementTotalActivePower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "total-active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementTotalActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000304) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTotalActivePowerWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ElectricalMeasurement.TotalActivePower response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltage
 */
class ReadElectricalMeasurementRmsVoltage : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000505) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsVoltageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltage response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsVoltage : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsVoltage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000505) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRmsVoltageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ElectricalMeasurement.RmsVoltage response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMin
 */
class ReadElectricalMeasurementRmsVoltageMin : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltageMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000506) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsVoltageMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltageMin response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltageMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsVoltageMin : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsVoltageMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsVoltageMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000506) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRmsVoltageMinWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.RmsVoltageMin response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMax
 */
class ReadElectricalMeasurementRmsVoltageMax : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltageMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000507) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsVoltageMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltageMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltageMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsVoltageMax : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsVoltageMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsVoltageMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000507) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRmsVoltageMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.RmsVoltageMax response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrent
 */
class ReadElectricalMeasurementRmsCurrent : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrent()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000508) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsCurrentWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrent response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrent Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsCurrent : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsCurrent()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000508) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRmsCurrentWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ElectricalMeasurement.RmsCurrent response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMin
 */
class ReadElectricalMeasurementRmsCurrentMin : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrentMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000509) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsCurrentMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrentMin response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrentMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsCurrentMin : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsCurrentMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsCurrentMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000509) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRmsCurrentMinWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.RmsCurrentMin response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMax
 */
class ReadElectricalMeasurementRmsCurrentMax : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrentMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsCurrentMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrentMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrentMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsCurrentMax : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsCurrentMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsCurrentMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRmsCurrentMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.RmsCurrentMax response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePower
 */
class ReadElectricalMeasurementActivePower : public ModelCommand {
public:
    ReadElectricalMeasurementActivePower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActivePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePower response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePower Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementActivePower : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementActivePower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActivePowerWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ElectricalMeasurement.ActivePower response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMin
 */
class ReadElectricalMeasurementActivePowerMin : public ModelCommand {
public:
    ReadElectricalMeasurementActivePowerMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActivePowerMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePowerMin response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePowerMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementActivePowerMin : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementActivePowerMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementActivePowerMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActivePowerMinWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ElectricalMeasurement.ActivePowerMin response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMax
 */
class ReadElectricalMeasurementActivePowerMax : public ModelCommand {
public:
    ReadElectricalMeasurementActivePowerMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActivePowerMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePowerMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePowerMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementActivePowerMax : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementActivePowerMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementActivePowerMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActivePowerMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ElectricalMeasurement.ActivePowerMax response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadElectricalMeasurementGeneratedCommandList : public ModelCommand {
public:
    ReadElectricalMeasurementGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ElectricalMeasurement.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadElectricalMeasurementAcceptedCommandList : public ModelCommand {
public:
    ReadElectricalMeasurementAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ElectricalMeasurement.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadElectricalMeasurementAttributeList : public ModelCommand {
public:
    ReadElectricalMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadElectricalMeasurementClusterRevision : public ModelCommand {
public:
    ReadElectricalMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ElectricalMeasurement.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster EthernetNetworkDiagnostics                                  | 0x0037 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * PHYRate                                                           | 0x0000 |
| * FullDuplex                                                        | 0x0001 |
| * PacketRxCount                                                     | 0x0002 |
| * PacketTxCount                                                     | 0x0003 |
| * TxErrCount                                                        | 0x0004 |
| * CollisionCount                                                    | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * CarrierDetect                                                     | 0x0007 |
| * TimeSinceReset                                                    | 0x0008 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class EthernetNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    EthernetNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute PHYRate
 */
class ReadEthernetNetworkDiagnosticsPHYRate : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPHYRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "phyrate");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPHYRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePHYRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PHYRate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PHYRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsPHYRate : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsPHYRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "phyrate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsPHYRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePHYRateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"EthernetNetworkDiagnostics.PHYRate response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FullDuplex
 */
class ReadEthernetNetworkDiagnosticsFullDuplex : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsFullDuplex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "full-duplex");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFullDuplex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFullDuplexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.FullDuplex response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics FullDuplex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsFullDuplex : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsFullDuplex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "full-duplex");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsFullDuplex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFullDuplexWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"EthernetNetworkDiagnostics.FullDuplex response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketRxCount
 */
class ReadEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPacketRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PacketRxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PacketRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsPacketRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsPacketRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketRxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"EthernetNetworkDiagnostics.PacketRxCount response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketTxCount
 */
class ReadEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPacketTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PacketTxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PacketTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsPacketTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsPacketTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketTxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"EthernetNetworkDiagnostics.PacketTxCount response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCount
 */
class ReadEthernetNetworkDiagnosticsTxErrCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsTxErrCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTxErrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxErrCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.TxErrCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics TxErrCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsTxErrCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsTxErrCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsTxErrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxErrCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"EthernetNetworkDiagnostics.TxErrCount response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CollisionCount
 */
class ReadEthernetNetworkDiagnosticsCollisionCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsCollisionCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "collision-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCollisionCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCollisionCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.CollisionCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics CollisionCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsCollisionCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsCollisionCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "collision-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsCollisionCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCollisionCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"EthernetNetworkDiagnostics.CollisionCount response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadEthernetNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.OverrunCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOverrunCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"EthernetNetworkDiagnostics.OverrunCount response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CarrierDetect
 */
class ReadEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsCarrierDetect()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "carrier-detect");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCarrierDetect() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCarrierDetectWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.CarrierDetect response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics CarrierDetect Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsCarrierDetect()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "carrier-detect");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsCarrierDetect() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCarrierDetectWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"EthernetNetworkDiagnostics.CarrierDetect response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TimeSinceReset
 */
class ReadEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsTimeSinceReset()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "time-since-reset");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTimeSinceReset() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTimeSinceResetWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.TimeSinceReset response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics TimeSinceReset Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsTimeSinceReset()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "time-since-reset");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsTimeSinceReset() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTimeSinceResetWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"EthernetNetworkDiagnostics.TimeSinceReset response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadEthernetNetworkDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"EthernetNetworkDiagnostics.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadEthernetNetworkDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"EthernetNetworkDiagnostics.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadEthernetNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"EthernetNetworkDiagnostics.AttributeList response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadEthernetNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"EthernetNetworkDiagnostics.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadEthernetNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"EthernetNetworkDiagnostics.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FanControl                                                  | 0x0202 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * FanMode                                                           | 0x0000 |
| * FanModeSequence                                                   | 0x0001 |
| * PercentSetting                                                    | 0x0002 |
| * PercentCurrent                                                    | 0x0003 |
| * SpeedMax                                                          | 0x0004 |
| * SpeedSetting                                                      | 0x0005 |
| * SpeedCurrent                                                      | 0x0006 |
| * RockSupport                                                       | 0x0007 |
| * RockSetting                                                       | 0x0008 |
| * WindSupport                                                       | 0x0009 |
| * WindSetting                                                       | 0x000A |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute FanMode
 */
class ReadFanControlFanMode : public ModelCommand {
public:
    ReadFanControlFanMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "fan-mode");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlFanMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFanModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.FanMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl FanMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteFanControlFanMode : public ModelCommand {
public:
    WriteFanControlFanMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "fan-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteFanControlFanMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeFanModeWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "FanControl FanMode Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeFanControlFanMode : public ModelCommand {
public:
    SubscribeAttributeFanControlFanMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "fan-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlFanMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFanModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"FanControl.FanMode response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FanModeSequence
 */
class ReadFanControlFanModeSequence : public ModelCommand {
public:
    ReadFanControlFanModeSequence()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "fan-mode-sequence");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlFanModeSequence() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFanModeSequenceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.FanModeSequence response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl FanModeSequence Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteFanControlFanModeSequence : public ModelCommand {
public:
    WriteFanControlFanModeSequence()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "fan-mode-sequence");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteFanControlFanModeSequence() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) WriteAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeFanModeSequenceWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          chipError = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "FanControl FanModeSequence Error: %s", chip::ErrorStr(chipError));
                                          SetCommandExitStatus(chipError);
                                      }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeFanControlFanModeSequence : public ModelCommand {
public:
    SubscribeAttributeFanControlFanModeSequence()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "fan-mode-sequence");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlFanModeSequence() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFanModeSequenceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"FanControl.FanModeSequence response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PercentSetting
 */
class ReadFanControlPercentSetting : public ModelCommand {
public:
    ReadFanControlPercentSetting()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "percent-setting");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlPercentSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePercentSettingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.PercentSetting response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl PercentSetting Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteFanControlPercentSetting : public ModelCommand {
public:
    WriteFanControlPercentSetting()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "percent-setting");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteFanControlPercentSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) WriteAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributePercentSettingWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "FanControl PercentSetting Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeFanControlPercentSetting : public ModelCommand {
public:
    SubscribeAttributeFanControlPercentSetting()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "percent-setting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlPercentSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePercentSettingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"FanControl.PercentSetting response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PercentCurrent
 */
class ReadFanControlPercentCurrent : public ModelCommand {
public:
    ReadFanControlPercentCurrent()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "percent-current");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlPercentCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePercentCurrentWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.PercentCurrent response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl PercentCurrent Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlPercentCurrent : public ModelCommand {
public:
    SubscribeAttributeFanControlPercentCurrent()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "percent-current");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlPercentCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePercentCurrentWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"FanControl.PercentCurrent response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SpeedMax
 */
class ReadFanControlSpeedMax : public ModelCommand {
public:
    ReadFanControlSpeedMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "speed-max");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlSpeedMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSpeedMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.SpeedMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl SpeedMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlSpeedMax : public ModelCommand {
public:
    SubscribeAttributeFanControlSpeedMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "speed-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlSpeedMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSpeedMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"FanControl.SpeedMax response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SpeedSetting
 */
class ReadFanControlSpeedSetting : public ModelCommand {
public:
    ReadFanControlSpeedSetting()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "speed-setting");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlSpeedSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSpeedSettingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.SpeedSetting response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl SpeedSetting Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteFanControlSpeedSetting : public ModelCommand {
public:
    WriteFanControlSpeedSetting()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "speed-setting");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteFanControlSpeedSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) WriteAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeSpeedSettingWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "FanControl SpeedSetting Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeFanControlSpeedSetting : public ModelCommand {
public:
    SubscribeAttributeFanControlSpeedSetting()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "speed-setting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlSpeedSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSpeedSettingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"FanControl.SpeedSetting response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SpeedCurrent
 */
class ReadFanControlSpeedCurrent : public ModelCommand {
public:
    ReadFanControlSpeedCurrent()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "speed-current");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlSpeedCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSpeedCurrentWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.SpeedCurrent response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl SpeedCurrent Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlSpeedCurrent : public ModelCommand {
public:
    SubscribeAttributeFanControlSpeedCurrent()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "speed-current");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlSpeedCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSpeedCurrentWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"FanControl.SpeedCurrent response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RockSupport
 */
class ReadFanControlRockSupport : public ModelCommand {
public:
    ReadFanControlRockSupport()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rock-support");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlRockSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRockSupportWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.RockSupport response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl RockSupport Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlRockSupport : public ModelCommand {
public:
    SubscribeAttributeFanControlRockSupport()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rock-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlRockSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRockSupportWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"FanControl.RockSupport response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RockSetting
 */
class ReadFanControlRockSetting : public ModelCommand {
public:
    ReadFanControlRockSetting()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rock-setting");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlRockSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRockSettingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.RockSetting response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl RockSetting Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteFanControlRockSetting : public ModelCommand {
public:
    WriteFanControlRockSetting()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "rock-setting");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteFanControlRockSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) WriteAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeRockSettingWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "FanControl RockSetting Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeFanControlRockSetting : public ModelCommand {
public:
    SubscribeAttributeFanControlRockSetting()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rock-setting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlRockSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRockSettingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"FanControl.RockSetting response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WindSupport
 */
class ReadFanControlWindSupport : public ModelCommand {
public:
    ReadFanControlWindSupport()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wind-support");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlWindSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWindSupportWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.WindSupport response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl WindSupport Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlWindSupport : public ModelCommand {
public:
    SubscribeAttributeFanControlWindSupport()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wind-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlWindSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWindSupportWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"FanControl.WindSupport response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WindSetting
 */
class ReadFanControlWindSetting : public ModelCommand {
public:
    ReadFanControlWindSetting()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wind-setting");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlWindSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWindSettingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.WindSetting response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl WindSetting Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteFanControlWindSetting : public ModelCommand {
public:
    WriteFanControlWindSetting()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "wind-setting");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteFanControlWindSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) WriteAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeWindSettingWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "FanControl WindSetting Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeFanControlWindSetting : public ModelCommand {
public:
    SubscribeAttributeFanControlWindSetting()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wind-setting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlWindSetting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWindSettingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"FanControl.WindSetting response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadFanControlGeneratedCommandList : public ModelCommand {
public:
    ReadFanControlGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeFanControlGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"FanControl.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadFanControlAcceptedCommandList : public ModelCommand {
public:
    ReadFanControlAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeFanControlAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"FanControl.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFanControlAttributeList : public ModelCommand {
public:
    ReadFanControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeFanControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"FanControl.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadFanControlFeatureMap : public ModelCommand {
public:
    ReadFanControlFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlFeatureMap : public ModelCommand {
public:
    SubscribeAttributeFanControlFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"FanControl.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadFanControlClusterRevision : public ModelCommand {
public:
    ReadFanControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFanControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FanControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FanControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFanControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeFanControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFanControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000202) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFanControl * cluster = [[CHIPFanControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"FanControl.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FixedLabel                                                  | 0x0040 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute LabelList
 */
class ReadFixedLabelLabelList : public ModelCommand {
public:
    ReadFixedLabelLabelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLabelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.LabelList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel LabelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFixedLabelLabelList : public ModelCommand {
public:
    SubscribeAttributeFixedLabelLabelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "label-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLabelListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"FixedLabel.LabelList response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadFixedLabelGeneratedCommandList : public ModelCommand {
public:
    ReadFixedLabelGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFixedLabelGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeFixedLabelGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"FixedLabel.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadFixedLabelAcceptedCommandList : public ModelCommand {
public:
    ReadFixedLabelAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFixedLabelAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeFixedLabelAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"FixedLabel.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFixedLabelAttributeList : public ModelCommand {
public:
    ReadFixedLabelAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFixedLabelAttributeList : public ModelCommand {
public:
    SubscribeAttributeFixedLabelAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"FixedLabel.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadFixedLabelClusterRevision : public ModelCommand {
public:
    ReadFixedLabelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFixedLabelClusterRevision : public ModelCommand {
public:
    SubscribeAttributeFixedLabelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"FixedLabel.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FlowMeasurement                                             | 0x0404 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadFlowMeasurementMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"FlowMeasurement.MeasuredValue response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadFlowMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"FlowMeasurement.MinMeasuredValue response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadFlowMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"FlowMeasurement.MaxMeasuredValue response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadFlowMeasurementTolerance : public ModelCommand {
public:
    ReadFlowMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.Tolerance response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementTolerance : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeToleranceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"FlowMeasurement.Tolerance response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadFlowMeasurementGeneratedCommandList : public ModelCommand {
public:
    ReadFlowMeasurementGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"FlowMeasurement.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadFlowMeasurementAcceptedCommandList : public ModelCommand {
public:
    ReadFlowMeasurementAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"FlowMeasurement.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFlowMeasurementAttributeList : public ModelCommand {
public:
    ReadFlowMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"FlowMeasurement.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadFlowMeasurementClusterRevision : public ModelCommand {
public:
    ReadFlowMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"FlowMeasurement.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralCommissioning                                        | 0x0030 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ArmFailSafe                                                       |   0x00 |
| * SetRegulatoryConfig                                               |   0x02 |
| * CommissioningComplete                                             |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Breadcrumb                                                        | 0x0000 |
| * BasicCommissioningInfo                                            | 0x0001 |
| * RegulatoryConfig                                                  | 0x0002 |
| * LocationCapability                                                | 0x0003 |
| * SupportsConcurrentConnection                                      | 0x0004 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ArmFailSafe
 */
class GeneralCommissioningArmFailSafe : public ModelCommand {
public:
    GeneralCommissioningArmFailSafe()
        : ModelCommand("arm-fail-safe")
    {
        AddArgument("ExpiryLengthSeconds", 0, UINT16_MAX, &mExpiryLengthSeconds);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGeneralCommissioningClusterArmFailSafeParams alloc] init];

        params.expiryLengthSeconds = [NSNumber numberWithUnsignedShort:mExpiryLengthSeconds];

        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster armFailSafeWithParams:params
                     completionHandler:^(
                         CHIPGeneralCommissioningClusterArmFailSafeResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint16_t mExpiryLengthSeconds;
    uint64_t mBreadcrumb;
};

/*
 * Command CommissioningComplete
 */
class GeneralCommissioningCommissioningComplete : public ModelCommand {
public:
    GeneralCommissioningCommissioningComplete()
        : ModelCommand("commissioning-complete")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster commissioningCompleteWithCompletionHandler:^(
            CHIPGeneralCommissioningClusterCommissioningCompleteResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command SetRegulatoryConfig
 */
class GeneralCommissioningSetRegulatoryConfig : public ModelCommand {
public:
    GeneralCommissioningSetRegulatoryConfig()
        : ModelCommand("set-regulatory-config")
    {
        AddArgument("NewRegulatoryConfig", 0, UINT8_MAX, &mNewRegulatoryConfig);
        AddArgument("CountryCode", &mCountryCode);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGeneralCommissioningClusterSetRegulatoryConfigParams alloc] init];

        params.newRegulatoryConfig = [NSNumber numberWithUnsignedChar:mNewRegulatoryConfig];

        params.countryCode = [[NSString alloc] initWithBytes:mCountryCode.data()
                                                      length:mCountryCode.size()
                                                    encoding:NSUTF8StringEncoding];

        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster
            setRegulatoryConfigWithParams:params
                        completionHandler:^(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            chipError = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                            SetCommandExitStatus(chipError);
                        }];
        return chipError;
    }

private:
    uint8_t mNewRegulatoryConfig;
    chip::ByteSpan mCountryCode;
    uint64_t mBreadcrumb;
};

/*
 * Attribute Breadcrumb
 */
class ReadGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    ReadGeneralCommissioningBreadcrumb()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "breadcrumb");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBreadcrumbWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.Breadcrumb response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning Breadcrumb Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    WriteGeneralCommissioningBreadcrumb()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeBreadcrumbWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "GeneralCommissioning Breadcrumb Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningBreadcrumb()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBreadcrumbWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GeneralCommissioning.Breadcrumb response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BasicCommissioningInfo
 */
class ReadGeneralCommissioningBasicCommissioningInfo : public ModelCommand {
public:
    ReadGeneralCommissioningBasicCommissioningInfo()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "basic-commissioning-info");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBasicCommissioningInfo() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBasicCommissioningInfoWithCompletionHandler:^(
            CHIPGeneralCommissioningClusterBasicCommissioningInfo * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.BasicCommissioningInfo response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning BasicCommissioningInfo Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningBasicCommissioningInfo : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningBasicCommissioningInfo()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "basic-commissioning-info");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningBasicCommissioningInfo() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBasicCommissioningInfoWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(
                                                          CHIPGeneralCommissioningClusterBasicCommissioningInfo * _Nullable value,
                                                          NSError * _Nullable error) {
                                                          NSLog(@"GeneralCommissioning.BasicCommissioningInfo response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RegulatoryConfig
 */
class ReadGeneralCommissioningRegulatoryConfig : public ModelCommand {
public:
    ReadGeneralCommissioningRegulatoryConfig()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "regulatory-config");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningRegulatoryConfig() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRegulatoryConfigWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.RegulatoryConfig response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning RegulatoryConfig Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningRegulatoryConfig : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningRegulatoryConfig()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "regulatory-config");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningRegulatoryConfig() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRegulatoryConfigWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"GeneralCommissioning.RegulatoryConfig response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocationCapability
 */
class ReadGeneralCommissioningLocationCapability : public ModelCommand {
public:
    ReadGeneralCommissioningLocationCapability()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "location-capability");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningLocationCapability() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLocationCapabilityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.LocationCapability response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning LocationCapability Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningLocationCapability : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningLocationCapability()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "location-capability");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningLocationCapability() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLocationCapabilityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"GeneralCommissioning.LocationCapability response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportsConcurrentConnection
 */
class ReadGeneralCommissioningSupportsConcurrentConnection : public ModelCommand {
public:
    ReadGeneralCommissioningSupportsConcurrentConnection()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supports-concurrent-connection");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningSupportsConcurrentConnection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportsConcurrentConnectionWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.SupportsConcurrentConnection response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning SupportsConcurrentConnection Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningSupportsConcurrentConnection : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningSupportsConcurrentConnection()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supports-concurrent-connection");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningSupportsConcurrentConnection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSupportsConcurrentConnectionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"GeneralCommissioning.SupportsConcurrentConnection response "
                                                                      @"%@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadGeneralCommissioningGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralCommissioningGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"GeneralCommissioning.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadGeneralCommissioningAcceptedCommandList : public ModelCommand {
public:
    ReadGeneralCommissioningAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"GeneralCommissioning.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGeneralCommissioningAttributeList : public ModelCommand {
public:
    ReadGeneralCommissioningAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningAttributeList : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"GeneralCommissioning.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralCommissioningClusterRevision : public ModelCommand {
public:
    ReadGeneralCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningClusterRevision : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GeneralCommissioning.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralDiagnostics                                          | 0x0033 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NetworkInterfaces                                                 | 0x0000 |
| * RebootCount                                                       | 0x0001 |
| * UpTime                                                            | 0x0002 |
| * TotalOperationalHours                                             | 0x0003 |
| * BootReasons                                                       | 0x0004 |
| * ActiveHardwareFaults                                              | 0x0005 |
| * ActiveRadioFaults                                                 | 0x0006 |
| * ActiveNetworkFaults                                               | 0x0007 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * HardwareFaultChange                                               | 0x0000 |
| * RadioFaultChange                                                  | 0x0001 |
| * NetworkFaultChange                                                | 0x0002 |
| * BootReason                                                        | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute NetworkInterfaces
 */
class ReadGeneralDiagnosticsNetworkInterfaces : public ModelCommand {
public:
    ReadGeneralDiagnosticsNetworkInterfaces()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "network-interfaces");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsNetworkInterfaces() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNetworkInterfacesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.NetworkInterfaces response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics NetworkInterfaces Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsNetworkInterfaces : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsNetworkInterfaces()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "network-interfaces");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsNetworkInterfaces() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNetworkInterfacesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"GeneralDiagnostics.NetworkInterfaces response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RebootCount
 */
class ReadGeneralDiagnosticsRebootCount : public ModelCommand {
public:
    ReadGeneralDiagnosticsRebootCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reboot-count");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsRebootCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRebootCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.RebootCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics RebootCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsRebootCount : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsRebootCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reboot-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsRebootCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRebootCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"GeneralDiagnostics.RebootCount response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpTime
 */
class ReadGeneralDiagnosticsUpTime : public ModelCommand {
public:
    ReadGeneralDiagnosticsUpTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "up-time");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsUpTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUpTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.UpTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics UpTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsUpTime : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsUpTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "up-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsUpTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUpTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"GeneralDiagnostics.UpTime response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalOperationalHours
 */
class ReadGeneralDiagnosticsTotalOperationalHours : public ModelCommand {
public:
    ReadGeneralDiagnosticsTotalOperationalHours()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "total-operational-hours");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsTotalOperationalHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTotalOperationalHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.TotalOperationalHours response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics TotalOperationalHours Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsTotalOperationalHours : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsTotalOperationalHours()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "total-operational-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsTotalOperationalHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTotalOperationalHoursWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GeneralDiagnostics.TotalOperationalHours response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BootReasons
 */
class ReadGeneralDiagnosticsBootReasons : public ModelCommand {
public:
    ReadGeneralDiagnosticsBootReasons()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "boot-reasons");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsBootReasons() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBootReasonsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.BootReasons response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics BootReasons Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsBootReasons : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsBootReasons()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "boot-reasons");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsBootReasons() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBootReasonsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"GeneralDiagnostics.BootReasons response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveHardwareFaults
 */
class ReadGeneralDiagnosticsActiveHardwareFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveHardwareFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-hardware-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveHardwareFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveHardwareFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveHardwareFaults response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveHardwareFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsActiveHardwareFaults : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsActiveHardwareFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-hardware-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsActiveHardwareFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveHardwareFaultsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"GeneralDiagnostics.ActiveHardwareFaults response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveRadioFaults
 */
class ReadGeneralDiagnosticsActiveRadioFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveRadioFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-radio-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveRadioFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveRadioFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveRadioFaults response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveRadioFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsActiveRadioFaults : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsActiveRadioFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-radio-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsActiveRadioFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveRadioFaultsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"GeneralDiagnostics.ActiveRadioFaults response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveNetworkFaults
 */
class ReadGeneralDiagnosticsActiveNetworkFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveNetworkFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveNetworkFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveNetworkFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveNetworkFaults response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveNetworkFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsActiveNetworkFaults : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsActiveNetworkFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-network-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsActiveNetworkFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveNetworkFaultsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"GeneralDiagnostics.ActiveNetworkFaults response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadGeneralDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralDiagnosticsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"GeneralDiagnostics.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadGeneralDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    ReadGeneralDiagnosticsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"GeneralDiagnostics.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGeneralDiagnosticsAttributeList : public ModelCommand {
public:
    ReadGeneralDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"GeneralDiagnostics.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadGeneralDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GeneralDiagnostics.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GroupKeyManagement                                          | 0x003F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * KeySetWrite                                                       |   0x00 |
| * KeySetRead                                                        |   0x01 |
| * KeySetRemove                                                      |   0x03 |
| * KeySetReadAllIndices                                              |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GroupKeyMap                                                       | 0x0000 |
| * GroupTable                                                        | 0x0001 |
| * MaxGroupsPerFabric                                                | 0x0002 |
| * MaxGroupKeysPerFabric                                             | 0x0003 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command KeySetRead
 */
class GroupKeyManagementKeySetRead : public ModelCommand {
public:
    GroupKeyManagementKeySetRead()
        : ModelCommand("key-set-read")
    {
        AddArgument("GroupKeySetID", 0, UINT16_MAX, &mGroupKeySetID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadParams alloc] init];

        params.groupKeySetID = [NSNumber numberWithUnsignedShort:mGroupKeySetID];
        [cluster keySetReadWithParams:params
                    completionHandler:^(
                        CHIPGroupKeyManagementClusterKeySetReadResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        chipError = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                        SetCommandExitStatus(chipError);
                    }];
        return chipError;
    }

private:
    uint16_t mGroupKeySetID;
};

/*
 * Command KeySetReadAllIndices
 */
class GroupKeyManagementKeySetReadAllIndices : public ModelCommand {
public:
    GroupKeyManagementKeySetReadAllIndices()
        : ModelCommand("key-set-read-all-indices")
        , mComplex_GroupKeySetIDs(&mRequest.groupKeySetIDs)
    {
        AddArgument("GroupKeySetIDs", &mComplex_GroupKeySetIDs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadAllIndicesParams alloc] init];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.groupKeySetIDs) {
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedShort:entry_0];
                [array_0 addObject:newElement_0];
            }
            params.groupKeySetIDs = array_0;
        }
        [cluster
            keySetReadAllIndicesWithParams:params
                         completionHandler:^(CHIPGroupKeyManagementClusterKeySetReadAllIndicesResponseParams * _Nullable values,
                             NSError * _Nullable error) {
                             NSLog(@"Values: %@", values);
                             chipError = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                             SetCommandExitStatus(chipError);
                         }];
        return chipError;
    }

private:
    chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadAllIndices::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const uint16_t>> mComplex_GroupKeySetIDs;
};

/*
 * Command KeySetRemove
 */
class GroupKeyManagementKeySetRemove : public ModelCommand {
public:
    GroupKeyManagementKeySetRemove()
        : ModelCommand("key-set-remove")
    {
        AddArgument("GroupKeySetID", 0, UINT16_MAX, &mGroupKeySetID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetRemoveParams alloc] init];

        params.groupKeySetID = [NSNumber numberWithUnsignedShort:mGroupKeySetID];
        [cluster keySetRemoveWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    uint16_t mGroupKeySetID;
};

/*
 * Command KeySetWrite
 */
class GroupKeyManagementKeySetWrite : public ModelCommand {
public:
    GroupKeyManagementKeySetWrite()
        : ModelCommand("key-set-write")
        , mComplex_GroupKeySet(&mRequest.groupKeySet)
    {
        AddArgument("GroupKeySet", &mComplex_GroupKeySet);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetWriteParams alloc] init];

        params.groupKeySet = [CHIPGroupKeyManagementClusterGroupKeySetStruct new];
        params.groupKeySet.groupKeySetID = [NSNumber numberWithUnsignedShort:mRequest.groupKeySet.groupKeySetID];
        params.groupKeySet.groupKeySecurityPolicy =
            [NSNumber numberWithUnsignedChar:chip::to_underlying(mRequest.groupKeySet.groupKeySecurityPolicy)];
        if (mRequest.groupKeySet.epochKey0.IsNull()) {
            params.groupKeySet.epochKey0 = nil;
        } else {
            params.groupKeySet.epochKey0 = [NSData dataWithBytes:mRequest.groupKeySet.epochKey0.Value().data()
                                                          length:mRequest.groupKeySet.epochKey0.Value().size()];
        }
        if (mRequest.groupKeySet.epochStartTime0.IsNull()) {
            params.groupKeySet.epochStartTime0 = nil;
        } else {
            params.groupKeySet.epochStartTime0 = [NSNumber numberWithUnsignedLongLong:mRequest.groupKeySet.epochStartTime0.Value()];
        }
        if (mRequest.groupKeySet.epochKey1.IsNull()) {
            params.groupKeySet.epochKey1 = nil;
        } else {
            params.groupKeySet.epochKey1 = [NSData dataWithBytes:mRequest.groupKeySet.epochKey1.Value().data()
                                                          length:mRequest.groupKeySet.epochKey1.Value().size()];
        }
        if (mRequest.groupKeySet.epochStartTime1.IsNull()) {
            params.groupKeySet.epochStartTime1 = nil;
        } else {
            params.groupKeySet.epochStartTime1 = [NSNumber numberWithUnsignedLongLong:mRequest.groupKeySet.epochStartTime1.Value()];
        }
        if (mRequest.groupKeySet.epochKey2.IsNull()) {
            params.groupKeySet.epochKey2 = nil;
        } else {
            params.groupKeySet.epochKey2 = [NSData dataWithBytes:mRequest.groupKeySet.epochKey2.Value().data()
                                                          length:mRequest.groupKeySet.epochKey2.Value().size()];
        }
        if (mRequest.groupKeySet.epochStartTime2.IsNull()) {
            params.groupKeySet.epochStartTime2 = nil;
        } else {
            params.groupKeySet.epochStartTime2 = [NSNumber numberWithUnsignedLongLong:mRequest.groupKeySet.epochStartTime2.Value()];
        }
        [cluster keySetWriteWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeySetStruct::Type> mComplex_GroupKeySet;
};

/*
 * Attribute GroupKeyMap
 */
class ReadGroupKeyManagementGroupKeyMap : public ModelCommand {
public:
    ReadGroupKeyManagementGroupKeyMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "group-key-map");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeGroupKeyMapWithParams:params
                                  completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                      NSLog(@"GroupKeyManagement.GroupKeyMap response %@", [value description]);
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "GroupKeyManagement GroupKeyMap Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }
};

class WriteGroupKeyManagementGroupKeyMap : public ModelCommand {
public:
    WriteGroupKeyManagementGroupKeyMap()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "group-key-map");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPGroupKeyManagementClusterGroupKeyMapStruct * newElement_0;
                newElement_0 = [CHIPGroupKeyManagementClusterGroupKeyMapStruct new];
                newElement_0.groupId = [NSNumber numberWithUnsignedShort:entry_0.groupId];
                newElement_0.groupKeySetID = [NSNumber numberWithUnsignedShort:entry_0.groupKeySetID];
                newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeGroupKeyMapWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "GroupKeyManagement GroupKeyMap Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type> mValue;
    TypedComplexArgument<
        chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>>
        mComplex;
};

class SubscribeAttributeGroupKeyManagementGroupKeyMap : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementGroupKeyMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "group-key-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGroupKeyMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"GroupKeyManagement.GroupKeyMap response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GroupTable
 */
class ReadGroupKeyManagementGroupTable : public ModelCommand {
public:
    ReadGroupKeyManagementGroupTable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "group-table");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupTable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeGroupTableWithParams:params
                                 completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                     NSLog(@"GroupKeyManagement.GroupTable response %@", [value description]);
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogError(chipTool, "GroupKeyManagement GroupTable Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementGroupTable : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementGroupTable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "group-table");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementGroupTable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGroupTableWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GroupKeyManagement.GroupTable response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxGroupsPerFabric
 */
class ReadGroupKeyManagementMaxGroupsPerFabric : public ModelCommand {
public:
    ReadGroupKeyManagementMaxGroupsPerFabric()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-groups-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementMaxGroupsPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxGroupsPerFabricWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.MaxGroupsPerFabric response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement MaxGroupsPerFabric Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementMaxGroupsPerFabric : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementMaxGroupsPerFabric()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-groups-per-fabric");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementMaxGroupsPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxGroupsPerFabricWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"GroupKeyManagement.MaxGroupsPerFabric response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxGroupKeysPerFabric
 */
class ReadGroupKeyManagementMaxGroupKeysPerFabric : public ModelCommand {
public:
    ReadGroupKeyManagementMaxGroupKeysPerFabric()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-group-keys-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementMaxGroupKeysPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxGroupKeysPerFabricWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.MaxGroupKeysPerFabric response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement MaxGroupKeysPerFabric Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementMaxGroupKeysPerFabric : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementMaxGroupKeysPerFabric()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-group-keys-per-fabric");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementMaxGroupKeysPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxGroupKeysPerFabricWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GroupKeyManagement.MaxGroupKeysPerFabric response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadGroupKeyManagementGeneratedCommandList : public ModelCommand {
public:
    ReadGroupKeyManagementGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"GroupKeyManagement.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadGroupKeyManagementAcceptedCommandList : public ModelCommand {
public:
    ReadGroupKeyManagementAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"GroupKeyManagement.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGroupKeyManagementAttributeList : public ModelCommand {
public:
    ReadGroupKeyManagementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementAttributeList : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"GroupKeyManagement.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupKeyManagementClusterRevision : public ModelCommand {
public:
    ReadGroupKeyManagementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GroupKeyManagement.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Groups                                                      | 0x0004 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddGroup                                                          |   0x00 |
| * ViewGroup                                                         |   0x01 |
| * GetGroupMembership                                                |   0x02 |
| * RemoveGroup                                                       |   0x03 |
| * RemoveAllGroups                                                   |   0x04 |
| * AddGroupIfIdentifying                                             |   0x05 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NameSupport                                                       | 0x0000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddGroup
 */
class GroupsAddGroup : public ModelCommand {
public:
    GroupsAddGroup()
        : ModelCommand("add-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("GroupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterAddGroupParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];

        params.groupName = [[NSString alloc] initWithBytes:mGroupName.data()
                                                    length:mGroupName.size()
                                                  encoding:NSUTF8StringEncoding];
        [cluster addGroupWithParams:params
                  completionHandler:^(CHIPGroupsClusterAddGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                      NSLog(@"Values: %@", values);
                      chipError = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                      SetCommandExitStatus(chipError);
                  }];
        return chipError;
    }

private:
    chip::GroupId mGroupId;
    chip::ByteSpan mGroupName;
};

/*
 * Command AddGroupIfIdentifying
 */
class GroupsAddGroupIfIdentifying : public ModelCommand {
public:
    GroupsAddGroupIfIdentifying()
        : ModelCommand("add-group-if-identifying")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("GroupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterAddGroupIfIdentifyingParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];

        params.groupName = [[NSString alloc] initWithBytes:mGroupName.data()
                                                    length:mGroupName.size()
                                                  encoding:NSUTF8StringEncoding];
        [cluster addGroupIfIdentifyingWithParams:params
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    chip::GroupId mGroupId;
    chip::ByteSpan mGroupName;
};

/*
 * Command GetGroupMembership
 */
class GroupsGetGroupMembership : public ModelCommand {
public:
    GroupsGetGroupMembership()
        : ModelCommand("get-group-membership")
        , mComplex_GroupList(&mRequest.groupList)
    {
        AddArgument("GroupList", &mComplex_GroupList);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterGetGroupMembershipParams alloc] init];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.groupList) {
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedShort:entry_0];
                [array_0 addObject:newElement_0];
            }
            params.groupList = array_0;
        }
        [cluster getGroupMembershipWithParams:params
                            completionHandler:^(
                                CHIPGroupsClusterGetGroupMembershipResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    chip::app::Clusters::Groups::Commands::GetGroupMembership::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const chip::GroupId>> mComplex_GroupList;
};

/*
 * Command RemoveAllGroups
 */
class GroupsRemoveAllGroups : public ModelCommand {
public:
    GroupsRemoveAllGroups()
        : ModelCommand("remove-all-groups")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster removeAllGroupsWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command RemoveGroup
 */
class GroupsRemoveGroup : public ModelCommand {
public:
    GroupsRemoveGroup()
        : ModelCommand("remove-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterRemoveGroupParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster removeGroupWithParams:params
                     completionHandler:^(CHIPGroupsClusterRemoveGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    chip::GroupId mGroupId;
};

/*
 * Command ViewGroup
 */
class GroupsViewGroup : public ModelCommand {
public:
    GroupsViewGroup()
        : ModelCommand("view-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       chipError = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                       SetCommandExitStatus(chipError);
                   }];
        return chipError;
    }

private:
    chip::GroupId mGroupId;
};

/*
 * Attribute NameSupport
 */
class ReadGroupsNameSupport : public ModelCommand {
public:
    ReadGroupsNameSupport()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNameSupportWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.NameSupport response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups NameSupport Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupsNameSupport : public ModelCommand {
public:
    SubscribeAttributeGroupsNameSupport()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNameSupportWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Groups.NameSupport response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadGroupsGeneratedCommandList : public ModelCommand {
public:
    ReadGroupsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGroupsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"Groups.GeneratedCommandList response %@", [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadGroupsAcceptedCommandList : public ModelCommand {
public:
    ReadGroupsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeGroupsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Groups.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGroupsAttributeList : public ModelCommand {
public:
    ReadGroupsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupsAttributeList : public ModelCommand {
public:
    SubscribeAttributeGroupsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Groups.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupsClusterRevision : public ModelCommand {
public:
    ReadGroupsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeGroupsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Groups.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Identify                                                    | 0x0003 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Identify                                                          |   0x00 |
| * IdentifyQuery                                                     |   0x01 |
| * TriggerEffect                                                     |   0x40 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * IdentifyTime                                                      | 0x0000 |
| * IdentifyType                                                      | 0x0001 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Identify
 */
class IdentifyIdentify : public ModelCommand {
public:
    IdentifyIdentify()
        : ModelCommand("identify")
    {
        AddArgument("IdentifyTime", 0, UINT16_MAX, &mIdentifyTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPIdentifyClusterIdentifyParams alloc] init];

        params.identifyTime = [NSNumber numberWithUnsignedShort:mIdentifyTime];
        [cluster identifyWithParams:params
                  completionHandler:^(NSError * _Nullable error) {
                      chipError = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                      SetCommandExitStatus(chipError);
                  }];
        return chipError;
    }

private:
    uint16_t mIdentifyTime;
};

/*
 * Command IdentifyQuery
 */
class IdentifyIdentifyQuery : public ModelCommand {
public:
    IdentifyIdentifyQuery()
        : ModelCommand("identify-query")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster identifyQueryWithCompletionHandler:^(
            CHIPIdentifyClusterIdentifyQueryResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command TriggerEffect
 */
class IdentifyTriggerEffect : public ModelCommand {
public:
    IdentifyTriggerEffect()
        : ModelCommand("trigger-effect")
    {
        AddArgument("EffectIdentifier", 0, UINT8_MAX, &mEffectIdentifier);
        AddArgument("EffectVariant", 0, UINT8_MAX, &mEffectVariant);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000040) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPIdentifyClusterTriggerEffectParams alloc] init];

        params.effectIdentifier = [NSNumber numberWithUnsignedChar:mEffectIdentifier];

        params.effectVariant = [NSNumber numberWithUnsignedChar:mEffectVariant];
        [cluster triggerEffectWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint8_t mEffectIdentifier;
    uint8_t mEffectVariant;
};

/*
 * Attribute IdentifyTime
 */
class ReadIdentifyIdentifyTime : public ModelCommand {
public:
    ReadIdentifyIdentifyTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-time");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeIdentifyTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.IdentifyTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify IdentifyTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteIdentifyIdentifyTime : public ModelCommand {
public:
    WriteIdentifyIdentifyTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeIdentifyTimeWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "Identify IdentifyTime Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeIdentifyIdentifyTime : public ModelCommand {
public:
    SubscribeAttributeIdentifyIdentifyTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeIdentifyTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Identify.IdentifyTime response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute IdentifyType
 */
class ReadIdentifyIdentifyType : public ModelCommand {
public:
    ReadIdentifyIdentifyType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-type");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeIdentifyTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.IdentifyType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify IdentifyType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIdentifyIdentifyType : public ModelCommand {
public:
    SubscribeAttributeIdentifyIdentifyType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "identify-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyIdentifyType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeIdentifyTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Identify.IdentifyType response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadIdentifyGeneratedCommandList : public ModelCommand {
public:
    ReadIdentifyGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIdentifyGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeIdentifyGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Identify.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadIdentifyAcceptedCommandList : public ModelCommand {
public:
    ReadIdentifyAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIdentifyAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeIdentifyAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Identify.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadIdentifyAttributeList : public ModelCommand {
public:
    ReadIdentifyAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIdentifyAttributeList : public ModelCommand {
public:
    SubscribeAttributeIdentifyAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Identify.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadIdentifyClusterRevision : public ModelCommand {
public:
    ReadIdentifyClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIdentifyClusterRevision : public ModelCommand {
public:
    SubscribeAttributeIdentifyClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Identify.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster IlluminanceMeasurement                                      | 0x0400 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * LightSensorType                                                   | 0x0004 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadIlluminanceMeasurementMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"IlluminanceMeasurement.MeasuredValue response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadIlluminanceMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"IlluminanceMeasurement.MinMeasuredValue response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadIlluminanceMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"IlluminanceMeasurement.MaxMeasuredValue response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadIlluminanceMeasurementTolerance : public ModelCommand {
public:
    ReadIlluminanceMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.Tolerance response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementTolerance : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeToleranceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"IlluminanceMeasurement.Tolerance response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LightSensorType
 */
class ReadIlluminanceMeasurementLightSensorType : public ModelCommand {
public:
    ReadIlluminanceMeasurementLightSensorType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "light-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementLightSensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLightSensorTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.LightSensorType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement LightSensorType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementLightSensorType : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementLightSensorType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "light-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementLightSensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLightSensorTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"IlluminanceMeasurement.LightSensorType response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadIlluminanceMeasurementGeneratedCommandList : public ModelCommand {
public:
    ReadIlluminanceMeasurementGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"IlluminanceMeasurement.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadIlluminanceMeasurementAcceptedCommandList : public ModelCommand {
public:
    ReadIlluminanceMeasurementAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"IlluminanceMeasurement.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadIlluminanceMeasurementAttributeList : public ModelCommand {
public:
    ReadIlluminanceMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"IlluminanceMeasurement.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadIlluminanceMeasurementClusterRevision : public ModelCommand {
public:
    ReadIlluminanceMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"IlluminanceMeasurement.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster KeypadInput                                                 | 0x0509 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SendKey                                                           |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command SendKey
 */
class KeypadInputSendKey : public ModelCommand {
public:
    KeypadInputSendKey()
        : ModelCommand("send-key")
    {
        AddArgument("KeyCode", 0, UINT8_MAX, &mKeyCode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPKeypadInputClusterSendKeyParams alloc] init];

        params.keyCode = [NSNumber numberWithUnsignedChar:mKeyCode];
        [cluster sendKeyWithParams:params
                 completionHandler:^(CHIPKeypadInputClusterSendKeyResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     chipError = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                     SetCommandExitStatus(chipError);
                 }];
        return chipError;
    }

private:
    uint8_t mKeyCode;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadKeypadInputGeneratedCommandList : public ModelCommand {
public:
    ReadKeypadInputGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"KeypadInput.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "KeypadInput GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeKeypadInputGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeKeypadInputGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeKeypadInputGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"KeypadInput.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadKeypadInputAcceptedCommandList : public ModelCommand {
public:
    ReadKeypadInputAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"KeypadInput.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "KeypadInput AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeKeypadInputAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeKeypadInputAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeKeypadInputAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"KeypadInput.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadKeypadInputAttributeList : public ModelCommand {
public:
    ReadKeypadInputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"KeypadInput.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "KeypadInput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeKeypadInputAttributeList : public ModelCommand {
public:
    SubscribeAttributeKeypadInputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeKeypadInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"KeypadInput.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadKeypadInputClusterRevision : public ModelCommand {
public:
    ReadKeypadInputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"KeypadInput.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "KeypadInput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeKeypadInputClusterRevision : public ModelCommand {
public:
    SubscribeAttributeKeypadInputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeKeypadInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"KeypadInput.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LevelControl                                                | 0x0008 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MoveToLevel                                                       |   0x00 |
| * Move                                                              |   0x01 |
| * Step                                                              |   0x02 |
| * Stop                                                              |   0x03 |
| * MoveToLevelWithOnOff                                              |   0x04 |
| * MoveWithOnOff                                                     |   0x05 |
| * StepWithOnOff                                                     |   0x06 |
| * StopWithOnOff                                                     |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentLevel                                                      | 0x0000 |
| * RemainingTime                                                     | 0x0001 |
| * MinLevel                                                          | 0x0002 |
| * MaxLevel                                                          | 0x0003 |
| * CurrentFrequency                                                  | 0x0004 |
| * MinFrequency                                                      | 0x0005 |
| * MaxFrequency                                                      | 0x0006 |
| * Options                                                           | 0x000F |
| * OnOffTransitionTime                                               | 0x0010 |
| * OnLevel                                                           | 0x0011 |
| * OnTransitionTime                                                  | 0x0012 |
| * OffTransitionTime                                                 | 0x0013 |
| * DefaultMoveRate                                                   | 0x0014 |
| * StartUpCurrentLevel                                               | 0x4000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Move
 */
class LevelControlMove : public ModelCommand {
public:
    LevelControlMove()
        : ModelCommand("move")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterMoveParams alloc] init];

        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];

        params.rate = [NSNumber numberWithUnsignedChar:mRate];

        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];

        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster moveWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  chipError = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                  SetCommandExitStatus(chipError);
              }];
        return chipError;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command MoveToLevel
 */
class LevelControlMoveToLevel : public ModelCommand {
public:
    LevelControlMoveToLevel()
        : ModelCommand("move-to-level")
    {
        AddArgument("Level", 0, UINT8_MAX, &mLevel);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];

        params.level = [NSNumber numberWithUnsignedChar:mLevel];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];

        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command MoveToLevelWithOnOff
 */
class LevelControlMoveToLevelWithOnOff : public ModelCommand {
public:
    LevelControlMoveToLevelWithOnOff()
        : ModelCommand("move-to-level-with-on-off")
    {
        AddArgument("Level", 0, UINT8_MAX, &mLevel);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelWithOnOffParams alloc] init];

        params.level = [NSNumber numberWithUnsignedChar:mLevel];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster moveToLevelWithOnOffWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
};

/*
 * Command MoveWithOnOff
 */
class LevelControlMoveWithOnOff : public ModelCommand {
public:
    LevelControlMoveWithOnOff()
        : ModelCommand("move-with-on-off")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterMoveWithOnOffParams alloc] init];

        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];

        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        [cluster moveWithOnOffWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
};

/*
 * Command Step
 */
class LevelControlStep : public ModelCommand {
public:
    LevelControlStep()
        : ModelCommand("step")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterStepParams alloc] init];

        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];

        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];

        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster stepWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  chipError = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                  SetCommandExitStatus(chipError);
              }];
        return chipError;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command StepWithOnOff
 */
class LevelControlStepWithOnOff : public ModelCommand {
public:
    LevelControlStepWithOnOff()
        : ModelCommand("step-with-on-off")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterStepWithOnOffParams alloc] init];

        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];

        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster stepWithOnOffWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
};

/*
 * Command Stop
 */
class LevelControlStop : public ModelCommand {
public:
    LevelControlStop()
        : ModelCommand("stop")
    {
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterStopParams alloc] init];

        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];

        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster stopWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  chipError = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                  SetCommandExitStatus(chipError);
              }];
        return chipError;
    }

private:
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command StopWithOnOff
 */
class LevelControlStopWithOnOff : public ModelCommand {
public:
    LevelControlStopWithOnOff()
        : ModelCommand("stop-with-on-off")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster stopWithOnOffWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute CurrentLevel
 */
class ReadLevelControlCurrentLevel : public ModelCommand {
public:
    ReadLevelControlCurrentLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.CurrentLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl CurrentLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlCurrentLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlCurrentLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"LevelControl.CurrentLevel response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadLevelControlRemainingTime : public ModelCommand {
public:
    ReadLevelControlRemainingTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.RemainingTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl RemainingTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlRemainingTime : public ModelCommand {
public:
    SubscribeAttributeLevelControlRemainingTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRemainingTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"LevelControl.RemainingTime response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinLevel
 */
class ReadLevelControlMinLevel : public ModelCommand {
public:
    ReadLevelControlMinLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MinLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MinLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlMinLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlMinLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlMinLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"LevelControl.MinLevel response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxLevel
 */
class ReadLevelControlMaxLevel : public ModelCommand {
public:
    ReadLevelControlMaxLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MaxLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MaxLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlMaxLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlMaxLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlMaxLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"LevelControl.MaxLevel response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFrequency
 */
class ReadLevelControlCurrentFrequency : public ModelCommand {
public:
    ReadLevelControlCurrentFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.CurrentFrequency response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl CurrentFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlCurrentFrequency : public ModelCommand {
public:
    SubscribeAttributeLevelControlCurrentFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlCurrentFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentFrequencyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"LevelControl.CurrentFrequency response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinFrequency
 */
class ReadLevelControlMinFrequency : public ModelCommand {
public:
    ReadLevelControlMinFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MinFrequency response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MinFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlMinFrequency : public ModelCommand {
public:
    SubscribeAttributeLevelControlMinFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlMinFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinFrequencyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"LevelControl.MinFrequency response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFrequency
 */
class ReadLevelControlMaxFrequency : public ModelCommand {
public:
    ReadLevelControlMaxFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MaxFrequency response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MaxFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlMaxFrequency : public ModelCommand {
public:
    SubscribeAttributeLevelControlMaxFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlMaxFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxFrequencyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"LevelControl.MaxFrequency response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Options
 */
class ReadLevelControlOptions : public ModelCommand {
public:
    ReadLevelControlOptions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "options");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.Options response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl Options Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOptions : public ModelCommand {
public:
    WriteLevelControlOptions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOptionsWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "LevelControl Options Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeLevelControlOptions : public ModelCommand {
public:
    SubscribeAttributeLevelControlOptions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOptionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"LevelControl.Options response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnOffTransitionTime
 */
class ReadLevelControlOnOffTransitionTime : public ModelCommand {
public:
    ReadLevelControlOnOffTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnOffTransitionTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnOffTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOnOffTransitionTime : public ModelCommand {
public:
    WriteLevelControlOnOffTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeOnOffTransitionTimeWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(chipTool, "LevelControl OnOffTransitionTime Error: %s",
                                                  chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeLevelControlOnOffTransitionTime : public ModelCommand {
public:
    SubscribeAttributeLevelControlOnOffTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOnOffTransitionTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"LevelControl.OnOffTransitionTime response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnLevel
 */
class ReadLevelControlOnLevel : public ModelCommand {
public:
    ReadLevelControlOnLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOnLevel : public ModelCommand {
public:
    WriteLevelControlOnLevel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOnLevelWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "LevelControl OnLevel Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeLevelControlOnLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlOnLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"LevelControl.OnLevel response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTransitionTime
 */
class ReadLevelControlOnTransitionTime : public ModelCommand {
public:
    ReadLevelControlOnTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnTransitionTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOnTransitionTime : public ModelCommand {
public:
    WriteLevelControlOnTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster
            writeAttributeOnTransitionTimeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "LevelControl OnTransitionTime Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeLevelControlOnTransitionTime : public ModelCommand {
public:
    SubscribeAttributeLevelControlOnTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnTransitionTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"LevelControl.OnTransitionTime response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffTransitionTime
 */
class ReadLevelControlOffTransitionTime : public ModelCommand {
public:
    ReadLevelControlOffTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OffTransitionTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OffTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOffTransitionTime : public ModelCommand {
public:
    WriteLevelControlOffTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeOffTransitionTimeWithValue:value
                                        completionHandler:^(NSError * _Nullable error) {
                                            chipError = [CHIPError errorToCHIPErrorCode:error];
                                            ChipLogError(
                                                chipTool, "LevelControl OffTransitionTime Error: %s", chip::ErrorStr(chipError));
                                            SetCommandExitStatus(chipError);
                                        }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeLevelControlOffTransitionTime : public ModelCommand {
public:
    SubscribeAttributeLevelControlOffTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOffTransitionTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"LevelControl.OffTransitionTime response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DefaultMoveRate
 */
class ReadLevelControlDefaultMoveRate : public ModelCommand {
public:
    ReadLevelControlDefaultMoveRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "default-move-rate");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000014) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDefaultMoveRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.DefaultMoveRate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl DefaultMoveRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlDefaultMoveRate : public ModelCommand {
public:
    WriteLevelControlDefaultMoveRate()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeDefaultMoveRateWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "LevelControl DefaultMoveRate Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeLevelControlDefaultMoveRate : public ModelCommand {
public:
    SubscribeAttributeLevelControlDefaultMoveRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDefaultMoveRateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LevelControl.DefaultMoveRate response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpCurrentLevel
 */
class ReadLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    ReadLevelControlStartUpCurrentLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00004000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartUpCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.StartUpCurrentLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl StartUpCurrentLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    WriteLevelControlStartUpCurrentLevel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00004000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeStartUpCurrentLevelWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(chipTool, "LevelControl StartUpCurrentLevel Error: %s",
                                                  chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlStartUpCurrentLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00004000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeStartUpCurrentLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"LevelControl.StartUpCurrentLevel response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadLevelControlGeneratedCommandList : public ModelCommand {
public:
    ReadLevelControlGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLevelControlGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"LevelControl.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadLevelControlAcceptedCommandList : public ModelCommand {
public:
    ReadLevelControlAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeLevelControlAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"LevelControl.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadLevelControlAttributeList : public ModelCommand {
public:
    ReadLevelControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeLevelControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"LevelControl.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadLevelControlFeatureMap : public ModelCommand {
public:
    ReadLevelControlFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlFeatureMap : public ModelCommand {
public:
    SubscribeAttributeLevelControlFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"LevelControl.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLevelControlClusterRevision : public ModelCommand {
public:
    ReadLevelControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeLevelControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LevelControl.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LocalizationConfiguration                                   | 0x002B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActiveLocale                                                      | 0x0001 |
| * SupportedLocales                                                  | 0x0002 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute ActiveLocale
 */
class ReadLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    ReadLocalizationConfigurationActiveLocale()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-locale");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveLocaleWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.ActiveLocale response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration ActiveLocale Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    WriteLocalizationConfigurationActiveLocale()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "active-locale");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) WriteAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeActiveLocaleWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(
                                           chipTool, "LocalizationConfiguration ActiveLocale Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationActiveLocale()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-locale");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActiveLocaleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"LocalizationConfiguration.ActiveLocale response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedLocales
 */
class ReadLocalizationConfigurationSupportedLocales : public ModelCommand {
public:
    ReadLocalizationConfigurationSupportedLocales()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-locales");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationSupportedLocales() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportedLocalesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.SupportedLocales response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration SupportedLocales Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLocalizationConfigurationSupportedLocales : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationSupportedLocales()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-locales");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationSupportedLocales() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedLocalesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"LocalizationConfiguration.SupportedLocales response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadLocalizationConfigurationGeneratedCommandList : public ModelCommand {
public:
    ReadLocalizationConfigurationGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLocalizationConfigurationGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"LocalizationConfiguration.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadLocalizationConfigurationAcceptedCommandList : public ModelCommand {
public:
    ReadLocalizationConfigurationAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLocalizationConfigurationAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"LocalizationConfiguration.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLocalizationConfigurationClusterRevision : public ModelCommand {
public:
    ReadLocalizationConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLocalizationConfigurationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LocalizationConfiguration.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LowPower                                                    | 0x0508 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Sleep                                                             |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Sleep
 */
class LowPowerSleep : public ModelCommand {
public:
    LowPowerSleep()
        : ModelCommand("sleep")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster sleepWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute GeneratedCommandList
 */
class ReadLowPowerGeneratedCommandList : public ModelCommand {
public:
    ReadLowPowerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LowPower.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LowPower GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLowPowerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLowPowerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLowPowerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LowPower.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadLowPowerAcceptedCommandList : public ModelCommand {
public:
    ReadLowPowerAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LowPower.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LowPower AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLowPowerAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeLowPowerAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLowPowerAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"LowPower.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadLowPowerAttributeList : public ModelCommand {
public:
    ReadLowPowerAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LowPower.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LowPower AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLowPowerAttributeList : public ModelCommand {
public:
    SubscribeAttributeLowPowerAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLowPowerAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"LowPower.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLowPowerClusterRevision : public ModelCommand {
public:
    ReadLowPowerClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LowPower.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LowPower ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLowPowerClusterRevision : public ModelCommand {
public:
    SubscribeAttributeLowPowerClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLowPowerClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LowPower.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaInput                                                  | 0x0507 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SelectInput                                                       |   0x00 |
| * ShowInputStatus                                                   |   0x01 |
| * HideInputStatus                                                   |   0x02 |
| * RenameInput                                                       |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * InputList                                                         | 0x0000 |
| * CurrentInput                                                      | 0x0001 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command HideInputStatus
 */
class MediaInputHideInputStatus : public ModelCommand {
public:
    MediaInputHideInputStatus()
        : ModelCommand("hide-input-status")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster hideInputStatusWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command RenameInput
 */
class MediaInputRenameInput : public ModelCommand {
public:
    MediaInputRenameInput()
        : ModelCommand("rename-input")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        AddArgument("Name", &mName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaInputClusterRenameInputParams alloc] init];

        params.index = [NSNumber numberWithUnsignedChar:mIndex];

        params.name = [[NSString alloc] initWithBytes:mName.data() length:mName.size() encoding:NSUTF8StringEncoding];
        [cluster renameInputWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint8_t mIndex;
    chip::ByteSpan mName;
};

/*
 * Command SelectInput
 */
class MediaInputSelectInput : public ModelCommand {
public:
    MediaInputSelectInput()
        : ModelCommand("select-input")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaInputClusterSelectInputParams alloc] init];

        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        [cluster selectInputWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint8_t mIndex;
};

/*
 * Command ShowInputStatus
 */
class MediaInputShowInputStatus : public ModelCommand {
public:
    MediaInputShowInputStatus()
        : ModelCommand("show-input-status")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster showInputStatusWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute InputList
 */
class ReadMediaInputInputList : public ModelCommand {
public:
    ReadMediaInputInputList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "input-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputInputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInputListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.InputList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput InputList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputInputList : public ModelCommand {
public:
    SubscribeAttributeMediaInputInputList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "input-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputInputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInputListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"MediaInput.InputList response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentInput
 */
class ReadMediaInputCurrentInput : public ModelCommand {
public:
    ReadMediaInputCurrentInput()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-input");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputCurrentInput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentInputWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.CurrentInput response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput CurrentInput Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputCurrentInput : public ModelCommand {
public:
    SubscribeAttributeMediaInputCurrentInput()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-input");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputCurrentInput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentInputWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"MediaInput.CurrentInput response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadMediaInputGeneratedCommandList : public ModelCommand {
public:
    ReadMediaInputGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeMediaInputGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"MediaInput.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadMediaInputAcceptedCommandList : public ModelCommand {
public:
    ReadMediaInputAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeMediaInputAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"MediaInput.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadMediaInputAttributeList : public ModelCommand {
public:
    ReadMediaInputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputAttributeList : public ModelCommand {
public:
    SubscribeAttributeMediaInputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"MediaInput.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaInputClusterRevision : public ModelCommand {
public:
    ReadMediaInputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputClusterRevision : public ModelCommand {
public:
    SubscribeAttributeMediaInputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"MediaInput.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaPlayback                                               | 0x0506 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Play                                                              |   0x00 |
| * Pause                                                             |   0x01 |
| * StopPlayback                                                      |   0x02 |
| * StartOver                                                         |   0x03 |
| * Previous                                                          |   0x04 |
| * Next                                                              |   0x05 |
| * Rewind                                                            |   0x06 |
| * FastForward                                                       |   0x07 |
| * SkipForward                                                       |   0x08 |
| * SkipBackward                                                      |   0x09 |
| * Seek                                                              |   0x0B |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentState                                                      | 0x0000 |
| * StartTime                                                         | 0x0001 |
| * Duration                                                          | 0x0002 |
| * SampledPosition                                                   | 0x0003 |
| * PlaybackSpeed                                                     | 0x0004 |
| * SeekRangeEnd                                                      | 0x0005 |
| * SeekRangeStart                                                    | 0x0006 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command FastForward
 */
class MediaPlaybackFastForward : public ModelCommand {
public:
    MediaPlaybackFastForward()
        : ModelCommand("fast-forward")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster fastForwardWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command Next
 */
class MediaPlaybackNext : public ModelCommand {
public:
    MediaPlaybackNext()
        : ModelCommand("next")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster nextWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command Pause
 */
class MediaPlaybackPause : public ModelCommand {
public:
    MediaPlaybackPause()
        : ModelCommand("pause")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster pauseWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command Play
 */
class MediaPlaybackPlay : public ModelCommand {
public:
    MediaPlaybackPlay()
        : ModelCommand("play")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster playWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command Previous
 */
class MediaPlaybackPrevious : public ModelCommand {
public:
    MediaPlaybackPrevious()
        : ModelCommand("previous")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster previousWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command Rewind
 */
class MediaPlaybackRewind : public ModelCommand {
public:
    MediaPlaybackRewind()
        : ModelCommand("rewind")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster rewindWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command Seek
 */
class MediaPlaybackSeek : public ModelCommand {
public:
    MediaPlaybackSeek()
        : ModelCommand("seek")
    {
        AddArgument("Position", 0, UINT64_MAX, &mPosition);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaPlaybackClusterSeekParams alloc] init];

        params.position = [NSNumber numberWithUnsignedLongLong:mPosition];
        [cluster seekWithParams:params
              completionHandler:^(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                  NSLog(@"Values: %@", values);
                  chipError = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                  SetCommandExitStatus(chipError);
              }];
        return chipError;
    }

private:
    uint64_t mPosition;
};

/*
 * Command SkipBackward
 */
class MediaPlaybackSkipBackward : public ModelCommand {
public:
    MediaPlaybackSkipBackward()
        : ModelCommand("skip-backward")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mDeltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaPlaybackClusterSkipBackwardParams alloc] init];

        params.deltaPositionMilliseconds = [NSNumber numberWithUnsignedLongLong:mDeltaPositionMilliseconds];
        [cluster
            skipBackwardWithParams:params
                 completionHandler:^(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     chipError = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                     SetCommandExitStatus(chipError);
                 }];
        return chipError;
    }

private:
    uint64_t mDeltaPositionMilliseconds;
};

/*
 * Command SkipForward
 */
class MediaPlaybackSkipForward : public ModelCommand {
public:
    MediaPlaybackSkipForward()
        : ModelCommand("skip-forward")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mDeltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaPlaybackClusterSkipForwardParams alloc] init];

        params.deltaPositionMilliseconds = [NSNumber numberWithUnsignedLongLong:mDeltaPositionMilliseconds];
        [cluster
            skipForwardWithParams:params
                completionHandler:^(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                    NSLog(@"Values: %@", values);
                    chipError = [CHIPError errorToCHIPErrorCode:error];
                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                    SetCommandExitStatus(chipError);
                }];
        return chipError;
    }

private:
    uint64_t mDeltaPositionMilliseconds;
};

/*
 * Command StartOver
 */
class MediaPlaybackStartOver : public ModelCommand {
public:
    MediaPlaybackStartOver()
        : ModelCommand("start-over")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster startOverWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command StopPlayback
 */
class MediaPlaybackStopPlayback : public ModelCommand {
public:
    MediaPlaybackStopPlayback()
        : ModelCommand("stop-playback")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster stopPlaybackWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute CurrentState
 */
class ReadMediaPlaybackCurrentState : public ModelCommand {
public:
    ReadMediaPlaybackCurrentState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-state");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackCurrentState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.CurrentState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback CurrentState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackCurrentState : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackCurrentState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackCurrentState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"MediaPlayback.CurrentState response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartTime
 */
class ReadMediaPlaybackStartTime : public ModelCommand {
public:
    ReadMediaPlaybackStartTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-time");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackStartTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.StartTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback StartTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackStartTime : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackStartTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackStartTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStartTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"MediaPlayback.StartTime response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Duration
 */
class ReadMediaPlaybackDuration : public ModelCommand {
public:
    ReadMediaPlaybackDuration()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "duration");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackDuration() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDurationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.Duration response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback Duration Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackDuration : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackDuration()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "duration");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackDuration() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDurationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"MediaPlayback.Duration response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SampledPosition
 */
class ReadMediaPlaybackSampledPosition : public ModelCommand {
public:
    ReadMediaPlaybackSampledPosition()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "sampled-position");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSampledPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSampledPositionWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackPosition * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.SampledPosition response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback SampledPosition Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackSampledPosition : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackSampledPosition()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "sampled-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackSampledPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSampledPositionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(CHIPMediaPlaybackClusterPlaybackPosition * _Nullable value,
                                                        NSError * _Nullable error) {
                                                        NSLog(@"MediaPlayback.SampledPosition response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PlaybackSpeed
 */
class ReadMediaPlaybackPlaybackSpeed : public ModelCommand {
public:
    ReadMediaPlaybackPlaybackSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "playback-speed");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPlaybackSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePlaybackSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.PlaybackSpeed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback PlaybackSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackPlaybackSpeed : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackPlaybackSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "playback-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackPlaybackSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePlaybackSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"MediaPlayback.PlaybackSpeed response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeEnd
 */
class ReadMediaPlaybackSeekRangeEnd : public ModelCommand {
public:
    ReadMediaPlaybackSeekRangeEnd()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-end");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeEnd() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSeekRangeEndWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.SeekRangeEnd response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback SeekRangeEnd Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackSeekRangeEnd : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackSeekRangeEnd()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "seek-range-end");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackSeekRangeEnd() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSeekRangeEndWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"MediaPlayback.SeekRangeEnd response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeStart
 */
class ReadMediaPlaybackSeekRangeStart : public ModelCommand {
public:
    ReadMediaPlaybackSeekRangeStart()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-start");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeStart() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSeekRangeStartWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.SeekRangeStart response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback SeekRangeStart Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackSeekRangeStart : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackSeekRangeStart()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "seek-range-start");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackSeekRangeStart() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSeekRangeStartWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"MediaPlayback.SeekRangeStart response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadMediaPlaybackGeneratedCommandList : public ModelCommand {
public:
    ReadMediaPlaybackGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"MediaPlayback.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadMediaPlaybackAcceptedCommandList : public ModelCommand {
public:
    ReadMediaPlaybackAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"MediaPlayback.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadMediaPlaybackAttributeList : public ModelCommand {
public:
    ReadMediaPlaybackAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackAttributeList : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"MediaPlayback.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaPlaybackClusterRevision : public ModelCommand {
public:
    ReadMediaPlaybackClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackClusterRevision : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"MediaPlayback.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ModeSelect                                                  | 0x0050 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeToMode                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Description                                                       | 0x0000 |
| * StandardNamespace                                                 | 0x0001 |
| * SupportedModes                                                    | 0x0002 |
| * CurrentMode                                                       | 0x0003 |
| * StartUpMode                                                       | 0x0004 |
| * OnMode                                                            | 0x0005 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeToMode
 */
class ModeSelectChangeToMode : public ModelCommand {
public:
    ModeSelectChangeToMode()
        : ModelCommand("change-to-mode")
    {
        AddArgument("NewMode", 0, UINT8_MAX, &mNewMode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPModeSelectClusterChangeToModeParams alloc] init];

        params.newMode = [NSNumber numberWithUnsignedChar:mNewMode];
        [cluster changeToModeWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    uint8_t mNewMode;
};

/*
 * Attribute Description
 */
class ReadModeSelectDescription : public ModelCommand {
public:
    ReadModeSelectDescription()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDescriptionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.Description response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect Description Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectDescription : public ModelCommand {
public:
    SubscribeAttributeModeSelectDescription()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDescriptionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ModeSelect.Description response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StandardNamespace
 */
class ReadModeSelectStandardNamespace : public ModelCommand {
public:
    ReadModeSelectStandardNamespace()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "standard-namespace");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectStandardNamespace() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStandardNamespaceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.StandardNamespace response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect StandardNamespace Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectStandardNamespace : public ModelCommand {
public:
    SubscribeAttributeModeSelectStandardNamespace()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "standard-namespace");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectStandardNamespace() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStandardNamespaceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ModeSelect.StandardNamespace response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedModes
 */
class ReadModeSelectSupportedModes : public ModelCommand {
public:
    ReadModeSelectSupportedModes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-modes");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectSupportedModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportedModesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.SupportedModes response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect SupportedModes Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectSupportedModes : public ModelCommand {
public:
    SubscribeAttributeModeSelectSupportedModes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-modes");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectSupportedModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedModesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ModeSelect.SupportedModes response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMode
 */
class ReadModeSelectCurrentMode : public ModelCommand {
public:
    ReadModeSelectCurrentMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectCurrentMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.CurrentMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect CurrentMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectCurrentMode : public ModelCommand {
public:
    SubscribeAttributeModeSelectCurrentMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectCurrentMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ModeSelect.CurrentMode response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpMode
 */
class ReadModeSelectStartUpMode : public ModelCommand {
public:
    ReadModeSelectStartUpMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartUpModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.StartUpMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect StartUpMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteModeSelectStartUpMode : public ModelCommand {
public:
    WriteModeSelectStartUpMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) WriteAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeStartUpModeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "ModeSelect StartUpMode Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeModeSelectStartUpMode : public ModelCommand {
public:
    SubscribeAttributeModeSelectStartUpMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStartUpModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ModeSelect.StartUpMode response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnMode
 */
class ReadModeSelectOnMode : public ModelCommand {
public:
    ReadModeSelectOnMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.OnMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect OnMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteModeSelectOnMode : public ModelCommand {
public:
    WriteModeSelectOnMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) WriteAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOnModeWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "ModeSelect OnMode Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeModeSelectOnMode : public ModelCommand {
public:
    SubscribeAttributeModeSelectOnMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"ModeSelect.OnMode response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadModeSelectGeneratedCommandList : public ModelCommand {
public:
    ReadModeSelectGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeModeSelectGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ModeSelect.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadModeSelectAcceptedCommandList : public ModelCommand {
public:
    ReadModeSelectAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeModeSelectAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ModeSelect.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadModeSelectAttributeList : public ModelCommand {
public:
    ReadModeSelectAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectAttributeList : public ModelCommand {
public:
    SubscribeAttributeModeSelectAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ModeSelect.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadModeSelectFeatureMap : public ModelCommand {
public:
    ReadModeSelectFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectFeatureMap : public ModelCommand {
public:
    SubscribeAttributeModeSelectFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ModeSelect.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadModeSelectClusterRevision : public ModelCommand {
public:
    ReadModeSelectClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectClusterRevision : public ModelCommand {
public:
    SubscribeAttributeModeSelectClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ModeSelect.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster NetworkCommissioning                                        | 0x0031 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ScanNetworks                                                      |   0x00 |
| * AddOrUpdateWiFiNetwork                                            |   0x02 |
| * AddOrUpdateThreadNetwork                                          |   0x03 |
| * RemoveNetwork                                                     |   0x04 |
| * ConnectNetwork                                                    |   0x06 |
| * ReorderNetwork                                                    |   0x08 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxNetworks                                                       | 0x0000 |
| * Networks                                                          | 0x0001 |
| * ScanMaxTimeSeconds                                                | 0x0002 |
| * ConnectMaxTimeSeconds                                             | 0x0003 |
| * InterfaceEnabled                                                  | 0x0004 |
| * LastNetworkingStatus                                              | 0x0005 |
| * LastNetworkID                                                     | 0x0006 |
| * LastConnectErrorValue                                             | 0x0007 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddOrUpdateThreadNetwork
 */
class NetworkCommissioningAddOrUpdateThreadNetwork : public ModelCommand {
public:
    NetworkCommissioningAddOrUpdateThreadNetwork()
        : ModelCommand("add-or-update-thread-network")
    {
        AddArgument("OperationalDataset", &mOperationalDataset);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterAddOrUpdateThreadNetworkParams alloc] init];

        params.operationalDataset = [[NSData alloc] initWithBytes:mOperationalDataset.data() length:mOperationalDataset.size()];

        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster addOrUpdateThreadNetworkWithParams:params
                                  completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                                      NSError * _Nullable error) {
                                      NSLog(@"Values: %@", values);
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    chip::ByteSpan mOperationalDataset;
    uint64_t mBreadcrumb;
};

/*
 * Command AddOrUpdateWiFiNetwork
 */
class NetworkCommissioningAddOrUpdateWiFiNetwork : public ModelCommand {
public:
    NetworkCommissioningAddOrUpdateWiFiNetwork()
        : ModelCommand("add-or-update-wi-fi-network")
    {
        AddArgument("Ssid", &mSsid);
        AddArgument("Credentials", &mCredentials);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterAddOrUpdateWiFiNetworkParams alloc] init];

        params.ssid = [[NSData alloc] initWithBytes:mSsid.data() length:mSsid.size()];

        params.credentials = [[NSData alloc] initWithBytes:mCredentials.data() length:mCredentials.size()];

        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster addOrUpdateWiFiNetworkWithParams:params
                                completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    chip::ByteSpan mSsid;
    chip::ByteSpan mCredentials;
    uint64_t mBreadcrumb;
};

/*
 * Command ConnectNetwork
 */
class NetworkCommissioningConnectNetwork : public ModelCommand {
public:
    NetworkCommissioningConnectNetwork()
        : ModelCommand("connect-network")
    {
        AddArgument("NetworkID", &mNetworkID);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterConnectNetworkParams alloc] init];

        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];

        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster connectNetworkWithParams:params
                        completionHandler:^(CHIPNetworkCommissioningClusterConnectNetworkResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            chipError = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                            SetCommandExitStatus(chipError);
                        }];
        return chipError;
    }

private:
    chip::ByteSpan mNetworkID;
    uint64_t mBreadcrumb;
};

/*
 * Command RemoveNetwork
 */
class NetworkCommissioningRemoveNetwork : public ModelCommand {
public:
    NetworkCommissioningRemoveNetwork()
        : ModelCommand("remove-network")
    {
        AddArgument("NetworkID", &mNetworkID);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterRemoveNetworkParams alloc] init];

        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];

        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster removeNetworkWithParams:params
                       completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                           NSError * _Nullable error) {
                           NSLog(@"Values: %@", values);
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    chip::ByteSpan mNetworkID;
    uint64_t mBreadcrumb;
};

/*
 * Command ReorderNetwork
 */
class NetworkCommissioningReorderNetwork : public ModelCommand {
public:
    NetworkCommissioningReorderNetwork()
        : ModelCommand("reorder-network")
    {
        AddArgument("NetworkID", &mNetworkID);
        AddArgument("NetworkIndex", 0, UINT8_MAX, &mNetworkIndex);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterReorderNetworkParams alloc] init];

        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];

        params.networkIndex = [NSNumber numberWithUnsignedChar:mNetworkIndex];

        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster reorderNetworkWithParams:params
                        completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            chipError = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                            SetCommandExitStatus(chipError);
                        }];
        return chipError;
    }

private:
    chip::ByteSpan mNetworkID;
    uint8_t mNetworkIndex;
    uint64_t mBreadcrumb;
};

/*
 * Command ScanNetworks
 */
class NetworkCommissioningScanNetworks : public ModelCommand {
public:
    NetworkCommissioningScanNetworks()
        : ModelCommand("scan-networks")
    {
        AddArgument("Ssid", &mSsid);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterScanNetworksParams alloc] init];

        params.ssid = [[NSData alloc] initWithBytes:mSsid.data() length:mSsid.size()];

        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster scanNetworksWithParams:params
                      completionHandler:^(
                          CHIPNetworkCommissioningClusterScanNetworksResponseParams * _Nullable values, NSError * _Nullable error) {
                          NSLog(@"Values: %@", values);
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    chip::ByteSpan mSsid;
    uint64_t mBreadcrumb;
};

/*
 * Attribute MaxNetworks
 */
class ReadNetworkCommissioningMaxNetworks : public ModelCommand {
public:
    ReadNetworkCommissioningMaxNetworks()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-networks");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningMaxNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxNetworksWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.MaxNetworks response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning MaxNetworks Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningMaxNetworks : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningMaxNetworks()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-networks");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningMaxNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxNetworksWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"NetworkCommissioning.MaxNetworks response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Networks
 */
class ReadNetworkCommissioningNetworks : public ModelCommand {
public:
    ReadNetworkCommissioningNetworks()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "networks");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNetworksWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.Networks response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning Networks Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningNetworks : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningNetworks()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "networks");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNetworksWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"NetworkCommissioning.Networks response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ScanMaxTimeSeconds
 */
class ReadNetworkCommissioningScanMaxTimeSeconds : public ModelCommand {
public:
    ReadNetworkCommissioningScanMaxTimeSeconds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scan-max-time-seconds");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningScanMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeScanMaxTimeSecondsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ScanMaxTimeSeconds response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ScanMaxTimeSeconds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningScanMaxTimeSeconds : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningScanMaxTimeSeconds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scan-max-time-seconds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningScanMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeScanMaxTimeSecondsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"NetworkCommissioning.ScanMaxTimeSeconds response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ConnectMaxTimeSeconds
 */
class ReadNetworkCommissioningConnectMaxTimeSeconds : public ModelCommand {
public:
    ReadNetworkCommissioningConnectMaxTimeSeconds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "connect-max-time-seconds");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningConnectMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeConnectMaxTimeSecondsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ConnectMaxTimeSeconds response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ConnectMaxTimeSeconds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningConnectMaxTimeSeconds : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningConnectMaxTimeSeconds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "connect-max-time-seconds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningConnectMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeConnectMaxTimeSecondsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"NetworkCommissioning.ConnectMaxTimeSeconds response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InterfaceEnabled
 */
class ReadNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    ReadNetworkCommissioningInterfaceEnabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "interface-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInterfaceEnabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.InterfaceEnabled response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning InterfaceEnabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    WriteNetworkCommissioningInterfaceEnabled()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "interface-enabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) WriteAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeInterfaceEnabledWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           chipError = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogError(chipTool, "NetworkCommissioning InterfaceEnabled Error: %s",
                                               chip::ErrorStr(chipError));
                                           SetCommandExitStatus(chipError);
                                       }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningInterfaceEnabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "interface-enabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInterfaceEnabledWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"NetworkCommissioning.InterfaceEnabled response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastNetworkingStatus
 */
class ReadNetworkCommissioningLastNetworkingStatus : public ModelCommand {
public:
    ReadNetworkCommissioningLastNetworkingStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-networking-status");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastNetworkingStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLastNetworkingStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastNetworkingStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastNetworkingStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningLastNetworkingStatus : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningLastNetworkingStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-networking-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningLastNetworkingStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLastNetworkingStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"NetworkCommissioning.LastNetworkingStatus response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastNetworkID
 */
class ReadNetworkCommissioningLastNetworkID : public ModelCommand {
public:
    ReadNetworkCommissioningLastNetworkID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-network-id");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastNetworkID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLastNetworkIDWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastNetworkID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastNetworkID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningLastNetworkID : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningLastNetworkID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-network-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningLastNetworkID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLastNetworkIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"NetworkCommissioning.LastNetworkID response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastConnectErrorValue
 */
class ReadNetworkCommissioningLastConnectErrorValue : public ModelCommand {
public:
    ReadNetworkCommissioningLastConnectErrorValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-connect-error-value");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastConnectErrorValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLastConnectErrorValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastConnectErrorValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastConnectErrorValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningLastConnectErrorValue : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningLastConnectErrorValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-connect-error-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningLastConnectErrorValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLastConnectErrorValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"NetworkCommissioning.LastConnectErrorValue response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadNetworkCommissioningGeneratedCommandList : public ModelCommand {
public:
    ReadNetworkCommissioningGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"NetworkCommissioning.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadNetworkCommissioningAcceptedCommandList : public ModelCommand {
public:
    ReadNetworkCommissioningAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"NetworkCommissioning.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadNetworkCommissioningFeatureMap : public ModelCommand {
public:
    ReadNetworkCommissioningFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningFeatureMap : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"NetworkCommissioning.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadNetworkCommissioningClusterRevision : public ModelCommand {
public:
    ReadNetworkCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningClusterRevision : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"NetworkCommissioning.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateProvider                                   | 0x0029 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * QueryImage                                                        |   0x00 |
| * ApplyUpdateRequest                                                |   0x02 |
| * NotifyUpdateApplied                                               |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ApplyUpdateRequest
 */
class OtaSoftwareUpdateProviderApplyUpdateRequest : public ModelCommand {
public:
    OtaSoftwareUpdateProviderApplyUpdateRequest()
        : ModelCommand("apply-update-request")
    {
        AddArgument("UpdateToken", &mUpdateToken);
        AddArgument("NewVersion", 0, UINT32_MAX, &mNewVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestParams alloc] init];

        params.updateToken = [[NSData alloc] initWithBytes:mUpdateToken.data() length:mUpdateToken.size()];

        params.newVersion = [NSNumber numberWithUnsignedInt:mNewVersion];
        [cluster applyUpdateRequestWithParams:params
                            completionHandler:^(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    chip::ByteSpan mUpdateToken;
    uint32_t mNewVersion;
};

/*
 * Command NotifyUpdateApplied
 */
class OtaSoftwareUpdateProviderNotifyUpdateApplied : public ModelCommand {
public:
    OtaSoftwareUpdateProviderNotifyUpdateApplied()
        : ModelCommand("notify-update-applied")
    {
        AddArgument("UpdateToken", &mUpdateToken);
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mSoftwareVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterNotifyUpdateAppliedParams alloc] init];

        params.updateToken = [[NSData alloc] initWithBytes:mUpdateToken.data() length:mUpdateToken.size()];

        params.softwareVersion = [NSNumber numberWithUnsignedInt:mSoftwareVersion];
        [cluster notifyUpdateAppliedWithParams:params
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    chip::ByteSpan mUpdateToken;
    uint32_t mSoftwareVersion;
};

/*
 * Command QueryImage
 */
class OtaSoftwareUpdateProviderQueryImage : public ModelCommand {
public:
    OtaSoftwareUpdateProviderQueryImage()
        : ModelCommand("query-image")
        , mComplex_ProtocolsSupported(&mRequest.protocolsSupported)
    {
        AddArgument("VendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("ProductId", 0, UINT16_MAX, &mProductId);
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mSoftwareVersion);
        AddArgument("ProtocolsSupported", &mComplex_ProtocolsSupported);
        AddArgument("HardwareVersion", 0, UINT16_MAX, &mHardwareVersion);
        AddArgument("Location", &mLocation);
        AddArgument("RequestorCanConsent", 0, 1, &mRequestorCanConsent);
        AddArgument("MetadataForProvider", &mMetadataForProvider);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterQueryImageParams alloc] init];

        params.vendorId = [NSNumber numberWithUnsignedShort:mVendorId];

        params.productId = [NSNumber numberWithUnsignedShort:mProductId];

        params.softwareVersion = [NSNumber numberWithUnsignedInt:mSoftwareVersion];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.protocolsSupported) {
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0)];
                [array_0 addObject:newElement_0];
            }
            params.protocolsSupported = array_0;
        }

        params.hardwareVersion = [NSNumber numberWithUnsignedShort:mHardwareVersion];

        params.location = [[NSString alloc] initWithBytes:mLocation.data() length:mLocation.size() encoding:NSUTF8StringEncoding];

        params.requestorCanConsent = [NSNumber numberWithBool:mRequestorCanConsent];

        params.metadataForProvider = [[NSData alloc] initWithBytes:mMetadataForProvider.data() length:mMetadataForProvider.size()];
        [cluster queryImageWithParams:params
                    completionHandler:^(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseParams * _Nullable values,
                        NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        chipError = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                        SetCommandExitStatus(chipError);
                    }];
        return chipError;
    }

private:
    chip::VendorId mVendorId;
    uint16_t mProductId;
    uint32_t mSoftwareVersion;
    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::QueryImage::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::OtaSoftwareUpdateProvider::OTADownloadProtocol>>
        mComplex_ProtocolsSupported;
    uint16_t mHardwareVersion;
    chip::ByteSpan mLocation;
    bool mRequestorCanConsent;
    chip::ByteSpan mMetadataForProvider;
};

/*
 * Attribute AttributeList
 */
class ReadOtaSoftwareUpdateProviderAttributeList : public ModelCommand {
public:
    ReadOtaSoftwareUpdateProviderAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateProvider.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateProvider AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateProviderAttributeList : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateProviderAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateProviderAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"OtaSoftwareUpdateProvider.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateProviderClusterRevision : public ModelCommand {
public:
    ReadOtaSoftwareUpdateProviderClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateProvider.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateProvider ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateProviderClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateProviderClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateProviderClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OtaSoftwareUpdateProvider.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateRequestor                                  | 0x002A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AnnounceOtaProvider                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DefaultOtaProviders                                               | 0x0000 |
| * UpdatePossible                                                    | 0x0001 |
| * UpdateState                                                       | 0x0002 |
| * UpdateStateProgress                                               | 0x0003 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateTransition                                                   | 0x0000 |
| * VersionApplied                                                    | 0x0001 |
| * DownloadError                                                     | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command AnnounceOtaProvider
 */
class OtaSoftwareUpdateRequestorAnnounceOtaProvider : public ModelCommand {
public:
    OtaSoftwareUpdateRequestorAnnounceOtaProvider()
        : ModelCommand("announce-ota-provider")
    {
        AddArgument("ProviderNodeId", 0, UINT64_MAX, &mProviderNodeId);
        AddArgument("VendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("AnnouncementReason", 0, UINT8_MAX, &mAnnouncementReason);
        AddArgument("MetadataForNode", &mMetadataForNode);
        AddArgument("Endpoint", 0, UINT16_MAX, &mEndpoint);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOtaSoftwareUpdateRequestorClusterAnnounceOtaProviderParams alloc] init];

        params.providerNodeId = [NSNumber numberWithUnsignedLongLong:mProviderNodeId];

        params.vendorId = [NSNumber numberWithUnsignedShort:mVendorId];

        params.announcementReason = [NSNumber numberWithUnsignedChar:mAnnouncementReason];

        params.metadataForNode = [[NSData alloc] initWithBytes:mMetadataForNode.data() length:mMetadataForNode.size()];

        params.endpoint = [NSNumber numberWithUnsignedShort:mEndpoint];
        [cluster announceOtaProviderWithParams:params
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    chip::NodeId mProviderNodeId;
    chip::VendorId mVendorId;
    uint8_t mAnnouncementReason;
    chip::ByteSpan mMetadataForNode;
    chip::EndpointId mEndpoint;
};

/*
 * Attribute DefaultOtaProviders
 */
class ReadOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorDefaultOtaProviders()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "default-ota-providers");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster
            readAttributeDefaultOtaProvidersWithParams:params
                                     completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                         NSLog(@"OtaSoftwareUpdateRequestor.DefaultOtaProviders response %@", [value description]);
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "OtaSoftwareUpdateRequestor DefaultOtaProviders Error: %s",
                                             chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }
};

class WriteOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand {
public:
    WriteOtaSoftwareUpdateRequestorDefaultOtaProviders()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "default-ota-providers");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPOtaSoftwareUpdateRequestorClusterProviderLocation * newElement_0;
                newElement_0 = [CHIPOtaSoftwareUpdateRequestorClusterProviderLocation new];
                newElement_0.providerNodeID = [NSNumber numberWithUnsignedLongLong:entry_0.providerNodeID];
                newElement_0.endpoint = [NSNumber numberWithUnsignedShort:entry_0.endpoint];
                newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeDefaultOtaProvidersWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(chipTool, "OtaSoftwareUpdateRequestor DefaultOtaProviders Error: %s",
                                                  chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::Type> mValue;
    TypedComplexArgument<
        chip::app::DataModel::List<const chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::Type>>
        mComplex;
};

class SubscribeAttributeOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorDefaultOtaProviders()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "default-ota-providers");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDefaultOtaProvidersWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OtaSoftwareUpdateRequestor.DefaultOtaProviders response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdatePossible
 */
class ReadOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdatePossible()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-possible");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdatePossible() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUpdatePossibleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdatePossible response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdatePossible Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorUpdatePossible()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-possible");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorUpdatePossible() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUpdatePossibleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"OtaSoftwareUpdateRequestor.UpdatePossible response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdateState
 */
class ReadOtaSoftwareUpdateRequestorUpdateState : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdateState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-state");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdateState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUpdateStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdateState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdateState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorUpdateState : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorUpdateState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorUpdateState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeUpdateStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"OtaSoftwareUpdateRequestor.UpdateState response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdateStateProgress
 */
class ReadOtaSoftwareUpdateRequestorUpdateStateProgress : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdateStateProgress()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-state-progress");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdateStateProgress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUpdateStateProgressWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdateStateProgress response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdateStateProgress Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorUpdateStateProgress : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorUpdateStateProgress()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-state-progress");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorUpdateStateProgress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUpdateStateProgressWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OtaSoftwareUpdateRequestor.UpdateStateProgress response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOtaSoftwareUpdateRequestorAttributeList : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorAttributeList : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"OtaSoftwareUpdateRequestor.AttributeList response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OtaSoftwareUpdateRequestor.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OccupancySensing                                            | 0x0406 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Occupancy                                                         | 0x0000 |
| * OccupancySensorType                                               | 0x0001 |
| * OccupancySensorTypeBitmap                                         | 0x0002 |
| * PirOccupiedToUnoccupiedDelay                                      | 0x0010 |
| * PirUnoccupiedToOccupiedDelay                                      | 0x0011 |
| * PirUnoccupiedToOccupiedThreshold                                  | 0x0012 |
| * UltrasonicOccupiedToUnoccupiedDelay                               | 0x0020 |
| * UltrasonicUnoccupiedToOccupiedDelay                               | 0x0021 |
| * UltrasonicUnoccupiedToOccupiedThreshold                           | 0x0022 |
| * PhysicalContactOccupiedToUnoccupiedDelay                          | 0x0030 |
| * PhysicalContactUnoccupiedToOccupiedDelay                          | 0x0031 |
| * PhysicalContactUnoccupiedToOccupiedThreshold                      | 0x0032 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Occupancy
 */
class ReadOccupancySensingOccupancy : public ModelCommand {
public:
    ReadOccupancySensingOccupancy()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOccupancyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.Occupancy response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing Occupancy Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingOccupancy : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingOccupancy()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingOccupancy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOccupancyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"OccupancySensing.Occupancy response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorType
 */
class ReadOccupancySensingOccupancySensorType : public ModelCommand {
public:
    ReadOccupancySensingOccupancySensorType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOccupancySensorTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.OccupancySensorType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing OccupancySensorType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingOccupancySensorType : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingOccupancySensorType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingOccupancySensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOccupancySensorTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OccupancySensing.OccupancySensorType response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorTypeBitmap
 */
class ReadOccupancySensingOccupancySensorTypeBitmap : public ModelCommand {
public:
    ReadOccupancySensingOccupancySensorTypeBitmap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorTypeBitmap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeOccupancySensorTypeBitmapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OccupancySensing.OccupancySensorTypeBitmap response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OccupancySensing OccupancySensorTypeBitmap Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingOccupancySensorTypeBitmap : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingOccupancySensorTypeBitmap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingOccupancySensorTypeBitmap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOccupancySensorTypeBitmapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"OccupancySensing.OccupancySensorTypeBitmap response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadOccupancySensingGeneratedCommandList : public ModelCommand {
public:
    ReadOccupancySensingGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"OccupancySensing.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadOccupancySensingAcceptedCommandList : public ModelCommand {
public:
    ReadOccupancySensingAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OccupancySensing.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOccupancySensingAttributeList : public ModelCommand {
public:
    ReadOccupancySensingAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingAttributeList : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"OccupancySensing.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOccupancySensingClusterRevision : public ModelCommand {
public:
    ReadOccupancySensingClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OccupancySensing.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOff                                                       | 0x0006 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Off                                                               |   0x00 |
| * On                                                                |   0x01 |
| * Toggle                                                            |   0x02 |
| * OffWithEffect                                                     |   0x40 |
| * OnWithRecallGlobalScene                                           |   0x41 |
| * OnWithTimedOff                                                    |   0x42 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OnOff                                                             | 0x0000 |
| * GlobalSceneControl                                                | 0x4000 |
| * OnTime                                                            | 0x4001 |
| * OffWaitTime                                                       | 0x4002 |
| * StartUpOnOff                                                      | 0x4003 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Off
 */
class OnOffOff : public ModelCommand {
public:
    OnOffOff()
        : ModelCommand("off")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster offWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command OffWithEffect
 */
class OnOffOffWithEffect : public ModelCommand {
public:
    OnOffOffWithEffect()
        : ModelCommand("off-with-effect")
    {
        AddArgument("EffectId", 0, UINT8_MAX, &mEffectId);
        AddArgument("EffectVariant", 0, UINT8_MAX, &mEffectVariant);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000040) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOnOffClusterOffWithEffectParams alloc] init];

        params.effectId = [NSNumber numberWithUnsignedChar:mEffectId];

        params.effectVariant = [NSNumber numberWithUnsignedChar:mEffectVariant];
        [cluster offWithEffectWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint8_t mEffectId;
    uint8_t mEffectVariant;
};

/*
 * Command On
 */
class OnOffOn : public ModelCommand {
public:
    OnOffOn()
        : ModelCommand("on")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster onWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command OnWithRecallGlobalScene
 */
class OnOffOnWithRecallGlobalScene : public ModelCommand {
public:
    OnOffOnWithRecallGlobalScene()
        : ModelCommand("on-with-recall-global-scene")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000041) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster onWithRecallGlobalSceneWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command OnWithTimedOff
 */
class OnOffOnWithTimedOff : public ModelCommand {
public:
    OnOffOnWithTimedOff()
        : ModelCommand("on-with-timed-off")
    {
        AddArgument("OnOffControl", 0, UINT8_MAX, &mOnOffControl);
        AddArgument("OnTime", 0, UINT16_MAX, &mOnTime);
        AddArgument("OffWaitTime", 0, UINT16_MAX, &mOffWaitTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000042) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOnOffClusterOnWithTimedOffParams alloc] init];

        params.onOffControl = [NSNumber numberWithUnsignedChar:mOnOffControl];

        params.onTime = [NSNumber numberWithUnsignedShort:mOnTime];

        params.offWaitTime = [NSNumber numberWithUnsignedShort:mOffWaitTime];
        [cluster onWithTimedOffWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            chipError = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                            SetCommandExitStatus(chipError);
                        }];
        return chipError;
    }

private:
    uint8_t mOnOffControl;
    uint16_t mOnTime;
    uint16_t mOffWaitTime;
};

/*
 * Command Toggle
 */
class OnOffToggle : public ModelCommand {
public:
    OnOffToggle()
        : ModelCommand("toggle")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster toggleWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute OnOff
 */
class ReadOnOffOnOff : public ModelCommand {
public:
    ReadOnOffOnOff()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OnOff response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OnOff Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffOnOff : public ModelCommand {
public:
    SubscribeAttributeOnOffOnOff()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnOffWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"OnOff.OnOff response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GlobalSceneControl
 */
class ReadOnOffGlobalSceneControl : public ModelCommand {
public:
    ReadOnOffGlobalSceneControl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "global-scene-control");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffGlobalSceneControl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGlobalSceneControlWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.GlobalSceneControl response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff GlobalSceneControl Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffGlobalSceneControl : public ModelCommand {
public:
    SubscribeAttributeOnOffGlobalSceneControl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "global-scene-control");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffGlobalSceneControl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGlobalSceneControlWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"OnOff.GlobalSceneControl response %@", [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTime
 */
class ReadOnOffOnTime : public ModelCommand {
public:
    ReadOnOffOnTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OnTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OnTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteOnOffOnTime : public ModelCommand {
public:
    WriteOnOffOnTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeOnTimeWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "OnOff OnTime Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeOnOffOnTime : public ModelCommand {
public:
    SubscribeAttributeOnOffOnTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"OnOff.OnTime response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffWaitTime
 */
class ReadOnOffOffWaitTime : public ModelCommand {
public:
    ReadOnOffOffWaitTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "off-wait-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OffWaitTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OffWaitTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteOnOffOffWaitTime : public ModelCommand {
public:
    WriteOnOffOffWaitTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeOffWaitTimeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "OnOff OffWaitTime Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeOnOffOffWaitTime : public ModelCommand {
public:
    SubscribeAttributeOnOffOffWaitTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOffWaitTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"OnOff.OffWaitTime response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpOnOff
 */
class ReadOnOffStartUpOnOff : public ModelCommand {
public:
    ReadOnOffStartUpOnOff()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartUpOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.StartUpOnOff response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff StartUpOnOff Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteOnOffStartUpOnOff : public ModelCommand {
public:
    WriteOnOffStartUpOnOff()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeStartUpOnOffWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "OnOff StartUpOnOff Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeOnOffStartUpOnOff : public ModelCommand {
public:
    SubscribeAttributeOnOffStartUpOnOff()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStartUpOnOffWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"OnOff.StartUpOnOff response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadOnOffGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOnOffGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"OnOff.GeneratedCommandList response %@", [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadOnOffAcceptedCommandList : public ModelCommand {
public:
    ReadOnOffAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeOnOffAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OnOff.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOnOffAttributeList : public ModelCommand {
public:
    ReadOnOffAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffAttributeList : public ModelCommand {
public:
    SubscribeAttributeOnOffAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"OnOff.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadOnOffFeatureMap : public ModelCommand {
public:
    ReadOnOffFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffFeatureMap : public ModelCommand {
public:
    SubscribeAttributeOnOffFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"OnOff.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffClusterRevision : public ModelCommand {
public:
    ReadOnOffClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOnOffClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OnOff.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOffSwitchConfiguration                                    | 0x0007 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SwitchType                                                        | 0x0000 |
| * SwitchActions                                                     | 0x0010 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute SwitchType
 */
class ReadOnOffSwitchConfigurationSwitchType : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationSwitchType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-type");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSwitchTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.SwitchType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationSwitchType : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationSwitchType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "switch-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationSwitchType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSwitchTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"OnOffSwitchConfiguration.SwitchType response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SwitchActions
 */
class ReadOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-actions");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSwitchActionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.SwitchActions response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchActions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    WriteOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) WriteAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeSwitchActionsWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        chipError = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchActions Error: %s",
                                            chip::ErrorStr(chipError));
                                        SetCommandExitStatus(chipError);
                                    }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSwitchActionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"OnOffSwitchConfiguration.SwitchActions response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadOnOffSwitchConfigurationGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"OnOffSwitchConfiguration.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadOnOffSwitchConfigurationAcceptedCommandList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OnOffSwitchConfiguration.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOnOffSwitchConfigurationAttributeList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationAttributeList : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"OnOffSwitchConfiguration.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffSwitchConfigurationClusterRevision : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OnOffSwitchConfiguration.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OperationalCredentials                                      | 0x003E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AttestationRequest                                                |   0x00 |
| * CertificateChainRequest                                           |   0x02 |
| * CSRRequest                                                        |   0x04 |
| * AddNOC                                                            |   0x06 |
| * UpdateNOC                                                         |   0x07 |
| * UpdateFabricLabel                                                 |   0x09 |
| * RemoveFabric                                                      |   0x0A |
| * AddTrustedRootCertificate                                         |   0x0B |
| * RemoveTrustedRootCertificate                                      |   0x0C |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NOCs                                                              | 0x0000 |
| * Fabrics                                                           | 0x0001 |
| * SupportedFabrics                                                  | 0x0002 |
| * CommissionedFabrics                                               | 0x0003 |
| * TrustedRootCertificates                                           | 0x0004 |
| * CurrentFabricIndex                                                | 0x0005 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddNOC
 */
class OperationalCredentialsAddNOC : public ModelCommand {
public:
    OperationalCredentialsAddNOC()
        : ModelCommand("add-noc")
    {
        AddArgument("NOCValue", &mNOCValue);
        AddArgument("ICACValue", &mICACValue);
        AddArgument("IPKValue", &mIPKValue);
        AddArgument("CaseAdminNode", 0, UINT64_MAX, &mCaseAdminNode);
        AddArgument("AdminVendorId", 0, UINT16_MAX, &mAdminVendorId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterAddNOCParams alloc] init];

        params.nocValue = [[NSData alloc] initWithBytes:mNOCValue.data() length:mNOCValue.size()];

        params.icacValue = [[NSData alloc] initWithBytes:mICACValue.data() length:mICACValue.size()];

        params.ipkValue = [[NSData alloc] initWithBytes:mIPKValue.data() length:mIPKValue.size()];

        params.caseAdminNode = [NSNumber numberWithUnsignedLongLong:mCaseAdminNode];

        params.adminVendorId = [NSNumber numberWithUnsignedShort:mAdminVendorId];
        [cluster
             addNOCWithParams:params
            completionHandler:^(CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                NSLog(@"Values: %@", values);
                chipError = [CHIPError errorToCHIPErrorCode:error];
                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                SetCommandExitStatus(chipError);
            }];
        return chipError;
    }

private:
    chip::ByteSpan mNOCValue;
    chip::ByteSpan mICACValue;
    chip::ByteSpan mIPKValue;
    chip::NodeId mCaseAdminNode;
    uint16_t mAdminVendorId;
};

/*
 * Command AddTrustedRootCertificate
 */
class OperationalCredentialsAddTrustedRootCertificate : public ModelCommand {
public:
    OperationalCredentialsAddTrustedRootCertificate()
        : ModelCommand("add-trusted-root-certificate")
    {
        AddArgument("RootCertificate", &mRootCertificate);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterAddTrustedRootCertificateParams alloc] init];

        params.rootCertificate = [[NSData alloc] initWithBytes:mRootCertificate.data() length:mRootCertificate.size()];
        [cluster addTrustedRootCertificateWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    chip::ByteSpan mRootCertificate;
};

/*
 * Command AttestationRequest
 */
class OperationalCredentialsAttestationRequest : public ModelCommand {
public:
    OperationalCredentialsAttestationRequest()
        : ModelCommand("attestation-request")
    {
        AddArgument("AttestationNonce", &mAttestationNonce);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterAttestationRequestParams alloc] init];

        params.attestationNonce = [[NSData alloc] initWithBytes:mAttestationNonce.data() length:mAttestationNonce.size()];
        [cluster attestationRequestWithParams:params
                            completionHandler:^(CHIPOperationalCredentialsClusterAttestationResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    chip::ByteSpan mAttestationNonce;
};

/*
 * Command CSRRequest
 */
class OperationalCredentialsCSRRequest : public ModelCommand {
public:
    OperationalCredentialsCSRRequest()
        : ModelCommand("csrrequest")
    {
        AddArgument("CSRNonce", &mCSRNonce);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterCSRRequestParams alloc] init];

        params.csrNonce = [[NSData alloc] initWithBytes:mCSRNonce.data() length:mCSRNonce.size()];
        [cluster CSRRequestWithParams:params
                    completionHandler:^(
                        CHIPOperationalCredentialsClusterCSRResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        chipError = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                        SetCommandExitStatus(chipError);
                    }];
        return chipError;
    }

private:
    chip::ByteSpan mCSRNonce;
};

/*
 * Command CertificateChainRequest
 */
class OperationalCredentialsCertificateChainRequest : public ModelCommand {
public:
    OperationalCredentialsCertificateChainRequest()
        : ModelCommand("certificate-chain-request")
    {
        AddArgument("CertificateType", 0, UINT8_MAX, &mCertificateType);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterCertificateChainRequestParams alloc] init];

        params.certificateType = [NSNumber numberWithUnsignedChar:mCertificateType];
        [cluster
            certificateChainRequestWithParams:params
                            completionHandler:^(CHIPOperationalCredentialsClusterCertificateChainResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mCertificateType;
};

/*
 * Command RemoveFabric
 */
class OperationalCredentialsRemoveFabric : public ModelCommand {
public:
    OperationalCredentialsRemoveFabric()
        : ModelCommand("remove-fabric")
    {
        AddArgument("FabricIndex", 0, UINT8_MAX, &mFabricIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterRemoveFabricParams alloc] init];

        params.fabricIndex = [NSNumber numberWithUnsignedChar:mFabricIndex];
        [cluster removeFabricWithParams:params
                      completionHandler:^(
                          CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                          NSLog(@"Values: %@", values);
                          chipError = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                          SetCommandExitStatus(chipError);
                      }];
        return chipError;
    }

private:
    chip::FabricIndex mFabricIndex;
};

/*
 * Command RemoveTrustedRootCertificate
 */
class OperationalCredentialsRemoveTrustedRootCertificate : public ModelCommand {
public:
    OperationalCredentialsRemoveTrustedRootCertificate()
        : ModelCommand("remove-trusted-root-certificate")
    {
        AddArgument("TrustedRootIdentifier", &mTrustedRootIdentifier);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterRemoveTrustedRootCertificateParams alloc] init];

        params.trustedRootIdentifier = [[NSData alloc] initWithBytes:mTrustedRootIdentifier.data()
                                                              length:mTrustedRootIdentifier.size()];
        [cluster removeTrustedRootCertificateWithParams:params
                                      completionHandler:^(NSError * _Nullable error) {
                                          chipError = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                          SetCommandExitStatus(chipError);
                                      }];
        return chipError;
    }

private:
    chip::ByteSpan mTrustedRootIdentifier;
};

/*
 * Command UpdateFabricLabel
 */
class OperationalCredentialsUpdateFabricLabel : public ModelCommand {
public:
    OperationalCredentialsUpdateFabricLabel()
        : ModelCommand("update-fabric-label")
    {
        AddArgument("Label", &mLabel);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterUpdateFabricLabelParams alloc] init];

        params.label = [[NSString alloc] initWithBytes:mLabel.data() length:mLabel.size() encoding:NSUTF8StringEncoding];
        [cluster updateFabricLabelWithParams:params
                           completionHandler:^(
                               CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                               NSLog(@"Values: %@", values);
                               chipError = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                               SetCommandExitStatus(chipError);
                           }];
        return chipError;
    }

private:
    chip::ByteSpan mLabel;
};

/*
 * Command UpdateNOC
 */
class OperationalCredentialsUpdateNOC : public ModelCommand {
public:
    OperationalCredentialsUpdateNOC()
        : ModelCommand("update-noc")
    {
        AddArgument("NOCValue", &mNOCValue);
        AddArgument("ICACValue", &mICACValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterUpdateNOCParams alloc] init];

        params.nocValue = [[NSData alloc] initWithBytes:mNOCValue.data() length:mNOCValue.size()];

        params.icacValue = [[NSData alloc] initWithBytes:mICACValue.data() length:mICACValue.size()];
        [cluster updateNOCWithParams:params
                   completionHandler:^(
                       CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       chipError = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                       SetCommandExitStatus(chipError);
                   }];
        return chipError;
    }

private:
    chip::ByteSpan mNOCValue;
    chip::ByteSpan mICACValue;
};

/*
 * Attribute NOCs
 */
class ReadOperationalCredentialsNOCs : public ModelCommand {
public:
    ReadOperationalCredentialsNOCs()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nocs");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsNOCs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeNOCsWithParams:params
                           completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                               NSLog(@"OperationalCredentials.NOCs response %@", [value description]);
                               err = [CHIPError errorToCHIPErrorCode:error];

                               ChipLogError(chipTool, "OperationalCredentials NOCs Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsNOCs : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsNOCs()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nocs");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsNOCs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNOCsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                params:params
                               subscriptionEstablished:nullptr
                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                             NSLog(@"OperationalCredentials.NOCs response %@", [value description]);
                                             if (error || !mWait) {
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }
                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Fabrics
 */
class ReadOperationalCredentialsFabrics : public ModelCommand {
public:
    ReadOperationalCredentialsFabrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeFabricsWithParams:params
                              completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                  NSLog(@"OperationalCredentials.Fabrics response %@", [value description]);
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "OperationalCredentials Fabrics Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsFabrics : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsFabrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFabricsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"OperationalCredentials.Fabrics response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedFabrics
 */
class ReadOperationalCredentialsSupportedFabrics : public ModelCommand {
public:
    ReadOperationalCredentialsSupportedFabrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsSupportedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportedFabricsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.SupportedFabrics response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials SupportedFabrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsSupportedFabrics : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsSupportedFabrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsSupportedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedFabricsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"OperationalCredentials.SupportedFabrics response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CommissionedFabrics
 */
class ReadOperationalCredentialsCommissionedFabrics : public ModelCommand {
public:
    ReadOperationalCredentialsCommissionedFabrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCommissionedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCommissionedFabricsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.CommissionedFabrics response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials CommissionedFabrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsCommissionedFabrics : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsCommissionedFabrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsCommissionedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCommissionedFabricsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OperationalCredentials.CommissionedFabrics response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TrustedRootCertificates
 */
class ReadOperationalCredentialsTrustedRootCertificates : public ModelCommand {
public:
    ReadOperationalCredentialsTrustedRootCertificates()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsTrustedRootCertificates() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTrustedRootCertificatesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.TrustedRootCertificates response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials TrustedRootCertificates Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsTrustedRootCertificates : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsTrustedRootCertificates()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsTrustedRootCertificates() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTrustedRootCertificatesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"OperationalCredentials.TrustedRootCertificates response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFabricIndex
 */
class ReadOperationalCredentialsCurrentFabricIndex : public ModelCommand {
public:
    ReadOperationalCredentialsCurrentFabricIndex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCurrentFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentFabricIndexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.CurrentFabricIndex response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials CurrentFabricIndex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsCurrentFabricIndex : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsCurrentFabricIndex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-fabric-index");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsCurrentFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentFabricIndexWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"OperationalCredentials.CurrentFabricIndex response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadOperationalCredentialsGeneratedCommandList : public ModelCommand {
public:
    ReadOperationalCredentialsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"OperationalCredentials.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadOperationalCredentialsAcceptedCommandList : public ModelCommand {
public:
    ReadOperationalCredentialsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OperationalCredentials.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOperationalCredentialsAttributeList : public ModelCommand {
public:
    ReadOperationalCredentialsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsAttributeList : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"OperationalCredentials.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOperationalCredentialsClusterRevision : public ModelCommand {
public:
    ReadOperationalCredentialsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OperationalCredentials.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSource                                                 | 0x002F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Status                                                            | 0x0000 |
| * Order                                                             | 0x0001 |
| * Description                                                       | 0x0002 |
| * WiredAssessedInputVoltage                                         | 0x0003 |
| * WiredAssessedInputFrequency                                       | 0x0004 |
| * WiredCurrentType                                                  | 0x0005 |
| * WiredAssessedCurrent                                              | 0x0006 |
| * WiredNominalVoltage                                               | 0x0007 |
| * WiredMaximumCurrent                                               | 0x0008 |
| * WiredPresent                                                      | 0x0009 |
| * ActiveWiredFaults                                                 | 0x000A |
| * BatteryVoltage                                                    | 0x000B |
| * BatteryPercentRemaining                                           | 0x000C |
| * BatteryTimeRemaining                                              | 0x000D |
| * BatteryChargeLevel                                                | 0x000E |
| * BatteryReplacementNeeded                                          | 0x000F |
| * BatteryReplaceability                                             | 0x0010 |
| * BatteryPresent                                                    | 0x0011 |
| * ActiveBatteryFaults                                               | 0x0012 |
| * BatteryReplacementDescription                                     | 0x0013 |
| * BatteryCommonDesignation                                          | 0x0014 |
| * BatteryANSIDesignation                                            | 0x0015 |
| * BatteryIECDesignation                                             | 0x0016 |
| * BatteryApprovedChemistry                                          | 0x0017 |
| * BatteryCapacity                                                   | 0x0018 |
| * BatteryQuantity                                                   | 0x0019 |
| * BatteryChargeState                                                | 0x001A |
| * BatteryTimeToFullCharge                                           | 0x001B |
| * BatteryFunctionalWhileCharging                                    | 0x001C |
| * BatteryChargingCurrent                                            | 0x001D |
| * ActiveBatteryChargeFaults                                         | 0x001E |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Status
 */
class ReadPowerSourceStatus : public ModelCommand {
public:
    ReadPowerSourceStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "status");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Status response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Status Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceStatus : public ModelCommand {
public:
    SubscribeAttributePowerSourceStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"PowerSource.Status response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Order
 */
class ReadPowerSourceOrder : public ModelCommand {
public:
    ReadPowerSourceOrder()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "order");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceOrder() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOrderWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Order response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Order Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceOrder : public ModelCommand {
public:
    SubscribeAttributePowerSourceOrder()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "order");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceOrder() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOrderWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PowerSource.Order response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadPowerSourceDescription : public ModelCommand {
public:
    ReadPowerSourceDescription()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDescriptionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Description response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Description Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceDescription : public ModelCommand {
public:
    SubscribeAttributePowerSourceDescription()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDescriptionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"PowerSource.Description response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryVoltage
 */
class ReadPowerSourceBatteryVoltage : public ModelCommand {
public:
    ReadPowerSourceBatteryVoltage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBatteryVoltageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryVoltage response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryVoltage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryVoltage : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryVoltage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBatteryVoltageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"PowerSource.BatteryVoltage response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryPercentRemaining
 */
class ReadPowerSourceBatteryPercentRemaining : public ModelCommand {
public:
    ReadPowerSourceBatteryPercentRemaining()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryPercentRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeBatteryPercentRemainingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSource.BatteryPercentRemaining response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSource BatteryPercentRemaining Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryPercentRemaining : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryPercentRemaining()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryPercentRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBatteryPercentRemainingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"PowerSource.BatteryPercentRemaining response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryTimeRemaining
 */
class ReadPowerSourceBatteryTimeRemaining : public ModelCommand {
public:
    ReadPowerSourceBatteryTimeRemaining()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-time-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryTimeRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBatteryTimeRemainingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryTimeRemaining response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryTimeRemaining Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryTimeRemaining : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryTimeRemaining()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-time-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryTimeRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBatteryTimeRemainingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PowerSource.BatteryTimeRemaining response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeLevel
 */
class ReadPowerSourceBatteryChargeLevel : public ModelCommand {
public:
    ReadPowerSourceBatteryChargeLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-level");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBatteryChargeLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryChargeLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryChargeLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryChargeLevel : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryChargeLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-charge-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryChargeLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBatteryChargeLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PowerSource.BatteryChargeLevel response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveBatteryFaults
 */
class ReadPowerSourceActiveBatteryFaults : public ModelCommand {
public:
    ReadPowerSourceActiveBatteryFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-battery-faults");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceActiveBatteryFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveBatteryFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.ActiveBatteryFaults response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource ActiveBatteryFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceActiveBatteryFaults : public ModelCommand {
public:
    SubscribeAttributePowerSourceActiveBatteryFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-battery-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceActiveBatteryFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActiveBatteryFaultsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"PowerSource.ActiveBatteryFaults response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeState
 */
class ReadPowerSourceBatteryChargeState : public ModelCommand {
public:
    ReadPowerSourceBatteryChargeState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-state");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000001A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBatteryChargeStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryChargeState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryChargeState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryChargeState : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryChargeState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-charge-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryChargeState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000001A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBatteryChargeStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PowerSource.BatteryChargeState response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadPowerSourceGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePowerSourceGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PowerSource.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadPowerSourceAcceptedCommandList : public ModelCommand {
public:
    ReadPowerSourceAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributePowerSourceAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"PowerSource.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPowerSourceAttributeList : public ModelCommand {
public:
    ReadPowerSourceAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceAttributeList : public ModelCommand {
public:
    SubscribeAttributePowerSourceAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PowerSource.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadPowerSourceFeatureMap : public ModelCommand {
public:
    ReadPowerSourceFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceFeatureMap : public ModelCommand {
public:
    SubscribeAttributePowerSourceFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"PowerSource.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceClusterRevision : public ModelCommand {
public:
    ReadPowerSourceClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceClusterRevision : public ModelCommand {
public:
    SubscribeAttributePowerSourceClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PowerSource.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSourceConfiguration                                    | 0x002E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Sources                                                           | 0x0000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Sources
 */
class ReadPowerSourceConfigurationSources : public ModelCommand {
public:
    ReadPowerSourceConfigurationSources()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "sources");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationSources() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSourcesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.Sources response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration Sources Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationSources : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationSources()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "sources");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationSources() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSourcesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PowerSourceConfiguration.Sources response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadPowerSourceConfigurationGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceConfigurationGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"PowerSourceConfiguration.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadPowerSourceConfigurationAcceptedCommandList : public ModelCommand {
public:
    ReadPowerSourceConfigurationAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"PowerSourceConfiguration.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPowerSourceConfigurationAttributeList : public ModelCommand {
public:
    ReadPowerSourceConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationAttributeList : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"PowerSourceConfiguration.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceConfigurationClusterRevision : public ModelCommand {
public:
    ReadPowerSourceConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationClusterRevision : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PowerSourceConfiguration.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PressureMeasurement                                         | 0x0403 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ScaledValue                                                       | 0x0010 |
| * MinScaledValue                                                    | 0x0011 |
| * MaxScaledValue                                                    | 0x0012 |
| * ScaledTolerance                                                   | 0x0013 |
| * Scale                                                             | 0x0014 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadPressureMeasurementMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PressureMeasurement.MeasuredValue response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadPressureMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"PressureMeasurement.MinMeasuredValue response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadPressureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"PressureMeasurement.MaxMeasuredValue response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPressureMeasurementAttributeList : public ModelCommand {
public:
    ReadPressureMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PressureMeasurement.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPressureMeasurementClusterRevision : public ModelCommand {
public:
    ReadPressureMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"PressureMeasurement.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PumpConfigurationAndControl                                 | 0x0200 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxPressure                                                       | 0x0000 |
| * MaxSpeed                                                          | 0x0001 |
| * MaxFlow                                                           | 0x0002 |
| * MinConstPressure                                                  | 0x0003 |
| * MaxConstPressure                                                  | 0x0004 |
| * MinCompPressure                                                   | 0x0005 |
| * MaxCompPressure                                                   | 0x0006 |
| * MinConstSpeed                                                     | 0x0007 |
| * MaxConstSpeed                                                     | 0x0008 |
| * MinConstFlow                                                      | 0x0009 |
| * MaxConstFlow                                                      | 0x000A |
| * MinConstTemp                                                      | 0x000B |
| * MaxConstTemp                                                      | 0x000C |
| * PumpStatus                                                        | 0x0010 |
| * EffectiveOperationMode                                            | 0x0011 |
| * EffectiveControlMode                                              | 0x0012 |
| * Capacity                                                          | 0x0013 |
| * Speed                                                             | 0x0014 |
| * LifetimeRunningHours                                              | 0x0015 |
| * Power                                                             | 0x0016 |
| * LifetimeEnergyConsumed                                            | 0x0017 |
| * OperationMode                                                     | 0x0020 |
| * ControlMode                                                       | 0x0021 |
| * AlarmMask                                                         | 0x0022 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SupplyVoltageLow                                                  | 0x0000 |
| * SupplyVoltageHigh                                                 | 0x0001 |
| * PowerMissingPhase                                                 | 0x0002 |
| * SystemPressureLow                                                 | 0x0003 |
| * SystemPressureHigh                                                | 0x0004 |
| * DryRunning                                                        | 0x0005 |
| * MotorTemperatureHigh                                              | 0x0006 |
| * PumpMotorFatalFailure                                             | 0x0007 |
| * ElectronicTemperatureHigh                                         | 0x0008 |
| * PumpBlocked                                                       | 0x0009 |
| * SensorFailure                                                     | 0x000A |
| * ElectronicNonFatalFailure                                         | 0x000B |
| * ElectronicFatalFailure                                            | 0x000C |
| * GeneralFault                                                      | 0x000D |
| * Leakage                                                           | 0x000E |
| * AirDetection                                                      | 0x000F |
| * TurbineOperation                                                  | 0x0010 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MaxPressure
 */
class ReadPumpConfigurationAndControlMaxPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"PumpConfigurationAndControl.MaxPressure response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxSpeed
 */
class ReadPumpConfigurationAndControlMaxSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxSpeed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxSpeed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"PumpConfigurationAndControl.MaxSpeed response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFlow
 */
class ReadPumpConfigurationAndControlMaxFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxFlow response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxFlow : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxFlowWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MaxFlow response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstPressure
 */
class ReadPumpConfigurationAndControlMinConstPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinConstPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinConstPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinConstPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"PumpConfigurationAndControl.MinConstPressure response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstPressure
 */
class ReadPumpConfigurationAndControlMaxConstPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxConstPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxConstPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxConstPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"PumpConfigurationAndControl.MaxConstPressure response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCompPressure
 */
class ReadPumpConfigurationAndControlMinCompPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinCompPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinCompPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinCompPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinCompPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinCompPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinCompPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PumpConfigurationAndControl.MinCompPressure response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCompPressure
 */
class ReadPumpConfigurationAndControlMaxCompPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxCompPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxCompPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxCompPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxCompPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxCompPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxCompPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PumpConfigurationAndControl.MaxCompPressure response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstSpeed
 */
class ReadPumpConfigurationAndControlMinConstSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstSpeed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinConstSpeed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinConstSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinConstSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PumpConfigurationAndControl.MinConstSpeed response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstSpeed
 */
class ReadPumpConfigurationAndControlMaxConstSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstSpeed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxConstSpeed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxConstSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxConstSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PumpConfigurationAndControl.MaxConstSpeed response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstFlow
 */
class ReadPumpConfigurationAndControlMinConstFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstFlow response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinConstFlow : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinConstFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinConstFlowWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MinConstFlow response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstFlow
 */
class ReadPumpConfigurationAndControlMaxConstFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstFlow response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxConstFlow : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxConstFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxConstFlowWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MaxConstFlow response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstTemp
 */
class ReadPumpConfigurationAndControlMinConstTemp : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstTemp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstTemp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstTemp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinConstTemp : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinConstTemp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinConstTempWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MinConstTemp response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstTemp
 */
class ReadPumpConfigurationAndControlMaxConstTemp : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstTemp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstTemp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstTemp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxConstTemp : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxConstTemp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxConstTempWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MaxConstTemp response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PumpStatus
 */
class ReadPumpConfigurationAndControlPumpStatus : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPumpStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pump-status");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePumpStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.PumpStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl PumpStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlPumpStatus : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlPumpStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pump-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlPumpStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributePumpStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PumpConfigurationAndControl.PumpStatus response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveOperationMode
 */
class ReadPumpConfigurationAndControlEffectiveOperationMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlEffectiveOperationMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEffectiveOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.EffectiveOperationMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl EffectiveOperationMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlEffectiveOperationMode : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlEffectiveOperationMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "effective-operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlEffectiveOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeEffectiveOperationModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"PumpConfigurationAndControl.EffectiveOperationMode response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveControlMode
 */
class ReadPumpConfigurationAndControlEffectiveControlMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlEffectiveControlMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEffectiveControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.EffectiveControlMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl EffectiveControlMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlEffectiveControlMode : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlEffectiveControlMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "effective-control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlEffectiveControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEffectiveControlModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"PumpConfigurationAndControl.EffectiveControlMode response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Capacity
 */
class ReadPumpConfigurationAndControlCapacity : public ModelCommand {
public:
    ReadPumpConfigurationAndControlCapacity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "capacity");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlCapacity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCapacityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Capacity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Capacity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlCapacity : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlCapacity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "capacity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlCapacity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCapacityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"PumpConfigurationAndControl.Capacity response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Speed
 */
class ReadPumpConfigurationAndControlSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000014) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Speed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Speed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlSpeed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PumpConfigurationAndControl.Speed response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeRunningHours
 */
class ReadPumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    ReadPumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000015) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLifetimeRunningHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.LifetimeRunningHours response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeRunningHours Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WritePumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    WritePumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeLifetimeRunningHoursWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeRunningHours Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributePumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLifetimeRunningHoursWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"PumpConfigurationAndControl.LifetimeRunningHours response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Power
 */
class ReadPumpConfigurationAndControlPower : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "power");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000016) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Power response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Power Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlPower : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlPower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlPower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePowerWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PumpConfigurationAndControl.Power response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeEnergyConsumed
 */
class ReadPumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000017) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLifetimeEnergyConsumedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.LifetimeEnergyConsumed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeEnergyConsumed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WritePumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    WritePumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster
            writeAttributeLifetimeEnergyConsumedWithValue:value
                                        completionHandler:^(NSError * _Nullable error) {
                                            chipError = [CHIPError errorToCHIPErrorCode:error];
                                            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeEnergyConsumed Error: %s",
                                                chip::ErrorStr(chipError));
                                            SetCommandExitStatus(chipError);
                                        }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributePumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeLifetimeEnergyConsumedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"PumpConfigurationAndControl.LifetimeEnergyConsumed response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationMode
 */
class ReadPumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlOperationMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000020) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.OperationMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl OperationMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WritePumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    WritePumpConfigurationAndControlOperationMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000020) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOperationModeWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        chipError = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "PumpConfigurationAndControl OperationMode Error: %s",
                                            chip::ErrorStr(chipError));
                                        SetCommandExitStatus(chipError);
                                    }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributePumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlOperationMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000020) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOperationModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PumpConfigurationAndControl.OperationMode response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlMode
 */
class ReadPumpConfigurationAndControlControlMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlControlMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000021) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.ControlMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl ControlMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WritePumpConfigurationAndControlControlMode : public ModelCommand {
public:
    WritePumpConfigurationAndControlControlMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeControlModeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(
                                          chipTool, "PumpConfigurationAndControl ControlMode Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributePumpConfigurationAndControlControlMode : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlControlMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeControlModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"PumpConfigurationAndControl.ControlMode response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AlarmMask
 */
class ReadPumpConfigurationAndControlAlarmMask : public ModelCommand {
public:
    ReadPumpConfigurationAndControlAlarmMask()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "alarm-mask");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAlarmMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000022) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAlarmMaskWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.AlarmMask response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl AlarmMask Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlAlarmMask : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlAlarmMask()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "alarm-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlAlarmMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000022) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAlarmMaskWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"PumpConfigurationAndControl.AlarmMask response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadPumpConfigurationAndControlGeneratedCommandList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"PumpConfigurationAndControl.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadPumpConfigurationAndControlAcceptedCommandList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"PumpConfigurationAndControl.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPumpConfigurationAndControlAttributeList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlAttributeList : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PumpConfigurationAndControl.AttributeList response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadPumpConfigurationAndControlFeatureMap : public ModelCommand {
public:
    ReadPumpConfigurationAndControlFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlFeatureMap : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PumpConfigurationAndControl.FeatureMap response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPumpConfigurationAndControlClusterRevision : public ModelCommand {
public:
    ReadPumpConfigurationAndControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PumpConfigurationAndControl.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster RelativeHumidityMeasurement                                 | 0x0405 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadRelativeHumidityMeasurementMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"RelativeHumidityMeasurement.MeasuredValue response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"RelativeHumidityMeasurement.MinMeasuredValue response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"RelativeHumidityMeasurement.MaxMeasuredValue response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadRelativeHumidityMeasurementTolerance : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.Tolerance response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementTolerance : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeToleranceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"RelativeHumidityMeasurement.Tolerance response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadRelativeHumidityMeasurementGeneratedCommandList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"RelativeHumidityMeasurement.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadRelativeHumidityMeasurementAcceptedCommandList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"RelativeHumidityMeasurement.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadRelativeHumidityMeasurementAttributeList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"RelativeHumidityMeasurement.AttributeList response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadRelativeHumidityMeasurementClusterRevision : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"RelativeHumidityMeasurement.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Scenes                                                      | 0x0005 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddScene                                                          |   0x00 |
| * ViewScene                                                         |   0x01 |
| * RemoveScene                                                       |   0x02 |
| * RemoveAllScenes                                                   |   0x03 |
| * StoreScene                                                        |   0x04 |
| * RecallScene                                                       |   0x05 |
| * GetSceneMembership                                                |   0x06 |
| * EnhancedAddScene                                                  |   0x40 |
| * EnhancedViewScene                                                 |   0x41 |
| * CopyScene                                                         |   0x42 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SceneCount                                                        | 0x0000 |
| * CurrentScene                                                      | 0x0001 |
| * CurrentGroup                                                      | 0x0002 |
| * SceneValid                                                        | 0x0003 |
| * NameSupport                                                       | 0x0004 |
| * LastConfiguredBy                                                  | 0x0005 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddScene
 */
class ScenesAddScene : public ModelCommand {
public:
    ScenesAddScene()
        : ModelCommand("add-scene")
        , mComplex_ExtensionFieldSets(&mRequest.extensionFieldSets)
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("SceneName", &mSceneName);
        AddArgument("ExtensionFieldSets", &mComplex_ExtensionFieldSets);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterAddSceneParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];

        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];

        params.sceneName = [[NSString alloc] initWithBytes:mSceneName.data()
                                                    length:mSceneName.size()
                                                  encoding:NSUTF8StringEncoding];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.extensionFieldSets) {
                CHIPScenesClusterSceneExtensionFieldSet * newElement_0;
                newElement_0 = [CHIPScenesClusterSceneExtensionFieldSet new];
                newElement_0.clusterId = [NSNumber numberWithUnsignedInt:entry_0.clusterId];
                newElement_0.length = [NSNumber numberWithUnsignedChar:entry_0.length];
                newElement_0.value = [NSNumber numberWithUnsignedChar:entry_0.value];
                [array_0 addObject:newElement_0];
            }
            params.extensionFieldSets = array_0;
        }
        [cluster addSceneWithParams:params
                  completionHandler:^(CHIPScenesClusterAddSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                      NSLog(@"Values: %@", values);
                      chipError = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                      SetCommandExitStatus(chipError);
                  }];
        return chipError;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
    uint16_t mTransitionTime;
    chip::ByteSpan mSceneName;
    chip::app::Clusters::Scenes::Commands::AddScene::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::Scenes::Structs::SceneExtensionFieldSet::Type>>
        mComplex_ExtensionFieldSets;
};

/*
 * Command GetSceneMembership
 */
class ScenesGetSceneMembership : public ModelCommand {
public:
    ScenesGetSceneMembership()
        : ModelCommand("get-scene-membership")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterGetSceneMembershipParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster getSceneMembershipWithParams:params
                            completionHandler:^(
                                CHIPScenesClusterGetSceneMembershipResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint16_t mGroupId;
};

/*
 * Command RecallScene
 */
class ScenesRecallScene : public ModelCommand {
public:
    ScenesRecallScene()
        : ModelCommand("recall-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterRecallSceneParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];

        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];

        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster recallSceneWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
    uint16_t mTransitionTime;
};

/*
 * Command RemoveAllScenes
 */
class ScenesRemoveAllScenes : public ModelCommand {
public:
    ScenesRemoveAllScenes()
        : ModelCommand("remove-all-scenes")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterRemoveAllScenesParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster removeAllScenesWithParams:params
                         completionHandler:^(
                             CHIPScenesClusterRemoveAllScenesResponseParams * _Nullable values, NSError * _Nullable error) {
                             NSLog(@"Values: %@", values);
                             chipError = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                             SetCommandExitStatus(chipError);
                         }];
        return chipError;
    }

private:
    uint16_t mGroupId;
};

/*
 * Command RemoveScene
 */
class ScenesRemoveScene : public ModelCommand {
public:
    ScenesRemoveScene()
        : ModelCommand("remove-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterRemoveSceneParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];

        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster removeSceneWithParams:params
                     completionHandler:^(CHIPScenesClusterRemoveSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         chipError = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                         SetCommandExitStatus(chipError);
                     }];
        return chipError;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Command StoreScene
 */
class ScenesStoreScene : public ModelCommand {
public:
    ScenesStoreScene()
        : ModelCommand("store-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterStoreSceneParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];

        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster storeSceneWithParams:params
                    completionHandler:^(CHIPScenesClusterStoreSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        chipError = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                        SetCommandExitStatus(chipError);
                    }];
        return chipError;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Command ViewScene
 */
class ScenesViewScene : public ModelCommand {
public:
    ScenesViewScene()
        : ModelCommand("view-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterViewSceneParams alloc] init];

        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];

        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster viewSceneWithParams:params
                   completionHandler:^(CHIPScenesClusterViewSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       chipError = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                       SetCommandExitStatus(chipError);
                   }];
        return chipError;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Attribute SceneCount
 */
class ReadScenesSceneCount : public ModelCommand {
public:
    ReadScenesSceneCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-count");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSceneCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.SceneCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes SceneCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesSceneCount : public ModelCommand {
public:
    SubscribeAttributeScenesSceneCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scene-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesSceneCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSceneCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Scenes.SceneCount response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentScene
 */
class ReadScenesCurrentScene : public ModelCommand {
public:
    ReadScenesCurrentScene()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-scene");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentScene() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentSceneWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.CurrentScene response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes CurrentScene Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesCurrentScene : public ModelCommand {
public:
    SubscribeAttributeScenesCurrentScene()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-scene");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesCurrentScene() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentSceneWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Scenes.CurrentScene response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentGroup
 */
class ReadScenesCurrentGroup : public ModelCommand {
public:
    ReadScenesCurrentGroup()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-group");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentGroup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentGroupWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.CurrentGroup response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes CurrentGroup Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesCurrentGroup : public ModelCommand {
public:
    SubscribeAttributeScenesCurrentGroup()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-group");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesCurrentGroup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentGroupWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Scenes.CurrentGroup response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SceneValid
 */
class ReadScenesSceneValid : public ModelCommand {
public:
    ReadScenesSceneValid()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-valid");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneValid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSceneValidWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.SceneValid response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes SceneValid Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesSceneValid : public ModelCommand {
public:
    SubscribeAttributeScenesSceneValid()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scene-valid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesSceneValid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSceneValidWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Scenes.SceneValid response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NameSupport
 */
class ReadScenesNameSupport : public ModelCommand {
public:
    ReadScenesNameSupport()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadScenesNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNameSupportWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.NameSupport response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes NameSupport Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesNameSupport : public ModelCommand {
public:
    SubscribeAttributeScenesNameSupport()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNameSupportWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Scenes.NameSupport response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadScenesGeneratedCommandList : public ModelCommand {
public:
    ReadScenesGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeScenesGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"Scenes.GeneratedCommandList response %@", [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadScenesAcceptedCommandList : public ModelCommand {
public:
    ReadScenesAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeScenesAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Scenes.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadScenesAttributeList : public ModelCommand {
public:
    ReadScenesAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesAttributeList : public ModelCommand {
public:
    SubscribeAttributeScenesAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Scenes.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadScenesClusterRevision : public ModelCommand {
public:
    ReadScenesClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadScenesClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesClusterRevision : public ModelCommand {
public:
    SubscribeAttributeScenesClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Scenes.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster SoftwareDiagnostics                                         | 0x0034 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetWatermarks                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ThreadMetrics                                                     | 0x0000 |
| * CurrentHeapFree                                                   | 0x0001 |
| * CurrentHeapUsed                                                   | 0x0002 |
| * CurrentHeapHighWatermark                                          | 0x0003 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SoftwareFault                                                     | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetWatermarks
 */
class SoftwareDiagnosticsResetWatermarks : public ModelCommand {
public:
    SoftwareDiagnosticsResetWatermarks()
        : ModelCommand("reset-watermarks")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster resetWatermarksWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute ThreadMetrics
 */
class ReadSoftwareDiagnosticsThreadMetrics : public ModelCommand {
public:
    ReadSoftwareDiagnosticsThreadMetrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "thread-metrics");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsThreadMetrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeThreadMetricsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.ThreadMetrics response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics ThreadMetrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsThreadMetrics : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsThreadMetrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "thread-metrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsThreadMetrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeThreadMetricsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"SoftwareDiagnostics.ThreadMetrics response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapFree
 */
class ReadSoftwareDiagnosticsCurrentHeapFree : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapFree()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-free");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapFree() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentHeapFreeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.CurrentHeapFree response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapFree Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsCurrentHeapFree : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsCurrentHeapFree()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-free");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsCurrentHeapFree() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentHeapFreeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"SoftwareDiagnostics.CurrentHeapFree response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapUsed
 */
class ReadSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapUsed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-used");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapUsed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentHeapUsedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.CurrentHeapUsed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapUsed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsCurrentHeapUsed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-used");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsCurrentHeapUsed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentHeapUsedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"SoftwareDiagnostics.CurrentHeapUsed response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapHighWatermark
 */
class ReadSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapHighWatermark()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapHighWatermark() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeCurrentHeapHighWatermarkWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"SoftwareDiagnostics.CurrentHeapHighWatermark response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapHighWatermark Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsCurrentHeapHighWatermark()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsCurrentHeapHighWatermark() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentHeapHighWatermarkWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"SoftwareDiagnostics.CurrentHeapHighWatermark response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadSoftwareDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"SoftwareDiagnostics.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadSoftwareDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"SoftwareDiagnostics.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadSoftwareDiagnosticsAttributeList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"SoftwareDiagnostics.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadSoftwareDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadSoftwareDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsFeatureMap : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"SoftwareDiagnostics.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSoftwareDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadSoftwareDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"SoftwareDiagnostics.ClusterRevision response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Switch                                                      | 0x003B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NumberOfPositions                                                 | 0x0000 |
| * CurrentPosition                                                   | 0x0001 |
| * MultiPressMax                                                     | 0x0002 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SwitchLatched                                                     | 0x0000 |
| * InitialPress                                                      | 0x0001 |
| * LongPress                                                         | 0x0002 |
| * ShortRelease                                                      | 0x0003 |
| * LongRelease                                                       | 0x0004 |
| * MultiPressOngoing                                                 | 0x0005 |
| * MultiPressComplete                                                | 0x0006 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute NumberOfPositions
 */
class ReadSwitchNumberOfPositions : public ModelCommand {
public:
    ReadSwitchNumberOfPositions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-positions");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchNumberOfPositions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfPositionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.NumberOfPositions response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch NumberOfPositions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchNumberOfPositions : public ModelCommand {
public:
    SubscribeAttributeSwitchNumberOfPositions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-positions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchNumberOfPositions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNumberOfPositionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"Switch.NumberOfPositions response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPosition
 */
class ReadSwitchCurrentPosition : public ModelCommand {
public:
    ReadSwitchCurrentPosition()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchCurrentPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.CurrentPosition response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch CurrentPosition Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchCurrentPosition : public ModelCommand {
public:
    SubscribeAttributeSwitchCurrentPosition()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchCurrentPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentPositionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Switch.CurrentPosition response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MultiPressMax
 */
class ReadSwitchMultiPressMax : public ModelCommand {
public:
    ReadSwitchMultiPressMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "multi-press-max");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMultiPressMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.MultiPressMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch MultiPressMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchMultiPressMax : public ModelCommand {
public:
    SubscribeAttributeSwitchMultiPressMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "multi-press-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchMultiPressMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMultiPressMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Switch.MultiPressMax response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadSwitchGeneratedCommandList : public ModelCommand {
public:
    ReadSwitchGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeSwitchGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"Switch.GeneratedCommandList response %@", [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadSwitchAcceptedCommandList : public ModelCommand {
public:
    ReadSwitchAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeSwitchAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Switch.AcceptedCommandList response %@", [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadSwitchAttributeList : public ModelCommand {
public:
    ReadSwitchAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchAttributeList : public ModelCommand {
public:
    SubscribeAttributeSwitchAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Switch.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadSwitchFeatureMap : public ModelCommand {
public:
    ReadSwitchFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchFeatureMap : public ModelCommand {
public:
    SubscribeAttributeSwitchFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Switch.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSwitchClusterRevision : public ModelCommand {
public:
    ReadSwitchClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchClusterRevision : public ModelCommand {
public:
    SubscribeAttributeSwitchClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Switch.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TargetNavigator                                             | 0x0505 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * NavigateTarget                                                    |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TargetList                                                        | 0x0000 |
| * CurrentTarget                                                     | 0x0001 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command NavigateTarget
 */
class TargetNavigatorNavigateTarget : public ModelCommand {
public:
    TargetNavigatorNavigateTarget()
        : ModelCommand("navigate-target")
    {
        AddArgument("Target", 0, UINT8_MAX, &mTarget);
        AddArgument("Data", &mData);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTargetNavigatorClusterNavigateTargetParams alloc] init];

        params.target = [NSNumber numberWithUnsignedChar:mTarget];

        params.data = [[NSString alloc] initWithBytes:mData.data() length:mData.size() encoding:NSUTF8StringEncoding];
        [cluster navigateTargetWithParams:params
                        completionHandler:^(
                            CHIPTargetNavigatorClusterNavigateTargetResponseParams * _Nullable values, NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            chipError = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                            SetCommandExitStatus(chipError);
                        }];
        return chipError;
    }

private:
    uint8_t mTarget;
    chip::ByteSpan mData;
};

/*
 * Attribute TargetList
 */
class ReadTargetNavigatorTargetList : public ModelCommand {
public:
    ReadTargetNavigatorTargetList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorTargetList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTargetListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.TargetList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator TargetList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorTargetList : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorTargetList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorTargetList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTargetListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"TargetNavigator.TargetList response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentTarget
 */
class ReadTargetNavigatorCurrentTarget : public ModelCommand {
public:
    ReadTargetNavigatorCurrentTarget()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-target");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorCurrentTarget() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentTargetWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.CurrentTarget response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator CurrentTarget Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorCurrentTarget : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorCurrentTarget()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-target");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorCurrentTarget() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentTargetWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TargetNavigator.CurrentTarget response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadTargetNavigatorGeneratedCommandList : public ModelCommand {
public:
    ReadTargetNavigatorGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"TargetNavigator.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadTargetNavigatorAcceptedCommandList : public ModelCommand {
public:
    ReadTargetNavigatorAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"TargetNavigator.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTargetNavigatorAttributeList : public ModelCommand {
public:
    ReadTargetNavigatorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorAttributeList : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TargetNavigator.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTargetNavigatorClusterRevision : public ModelCommand {
public:
    ReadTargetNavigatorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorClusterRevision : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TargetNavigator.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TemperatureMeasurement                                      | 0x0402 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadTemperatureMeasurementMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TemperatureMeasurement.MeasuredValue response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadTemperatureMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TemperatureMeasurement.MinMeasuredValue response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadTemperatureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TemperatureMeasurement.MaxMeasuredValue response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadTemperatureMeasurementTolerance : public ModelCommand {
public:
    ReadTemperatureMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.Tolerance response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementTolerance : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeToleranceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"TemperatureMeasurement.Tolerance response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTemperatureMeasurementAttributeList : public ModelCommand {
public:
    ReadTemperatureMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TemperatureMeasurement.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTemperatureMeasurementClusterRevision : public ModelCommand {
public:
    ReadTemperatureMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TemperatureMeasurement.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TestCluster                                                 | 0x050F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Test                                                              |   0x00 |
| * TestNotHandled                                                    |   0x01 |
| * TestSpecific                                                      |   0x02 |
| * TestUnknownCommand                                                |   0x03 |
| * TestAddArguments                                                  |   0x04 |
| * TestSimpleArgumentRequest                                         |   0x05 |
| * TestStructArrayArgumentRequest                                    |   0x06 |
| * TestStructArgumentRequest                                         |   0x07 |
| * TestNestedStructArgumentRequest                                   |   0x08 |
| * TestListStructArgumentRequest                                     |   0x09 |
| * TestListInt8UArgumentRequest                                      |   0x0A |
| * TestNestedStructListArgumentRequest                               |   0x0B |
| * TestListNestedStructListArgumentRequest                           |   0x0C |
| * TestListInt8UReverseRequest                                       |   0x0D |
| * TestEnumsRequest                                                  |   0x0E |
| * TestNullableOptionalRequest                                       |   0x0F |
| * TestComplexNullableOptionalRequest                                |   0x10 |
| * SimpleStructEchoRequest                                           |   0x11 |
| * TimedInvokeRequest                                                |   0x12 |
| * TestSimpleOptionalArgumentRequest                                 |   0x13 |
| * TestEmitTestEventRequest                                          |   0x14 |
| * TestEmitTestFabricScopedEventRequest                              |   0x15 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Boolean                                                           | 0x0000 |
| * Bitmap8                                                           | 0x0001 |
| * Bitmap16                                                          | 0x0002 |
| * Bitmap32                                                          | 0x0003 |
| * Bitmap64                                                          | 0x0004 |
| * Int8u                                                             | 0x0005 |
| * Int16u                                                            | 0x0006 |
| * Int24u                                                            | 0x0007 |
| * Int32u                                                            | 0x0008 |
| * Int40u                                                            | 0x0009 |
| * Int48u                                                            | 0x000A |
| * Int56u                                                            | 0x000B |
| * Int64u                                                            | 0x000C |
| * Int8s                                                             | 0x000D |
| * Int16s                                                            | 0x000E |
| * Int24s                                                            | 0x000F |
| * Int32s                                                            | 0x0010 |
| * Int40s                                                            | 0x0011 |
| * Int48s                                                            | 0x0012 |
| * Int56s                                                            | 0x0013 |
| * Int64s                                                            | 0x0014 |
| * Enum8                                                             | 0x0015 |
| * Enum16                                                            | 0x0016 |
| * FloatSingle                                                       | 0x0017 |
| * FloatDouble                                                       | 0x0018 |
| * OctetString                                                       | 0x0019 |
| * ListInt8u                                                         | 0x001A |
| * ListOctetString                                                   | 0x001B |
| * ListStructOctetString                                             | 0x001C |
| * LongOctetString                                                   | 0x001D |
| * CharString                                                        | 0x001E |
| * LongCharString                                                    | 0x001F |
| * EpochUs                                                           | 0x0020 |
| * EpochS                                                            | 0x0021 |
| * VendorId                                                          | 0x0022 |
| * ListNullablesAndOptionalsStruct                                   | 0x0023 |
| * EnumAttr                                                          | 0x0024 |
| * StructAttr                                                        | 0x0025 |
| * RangeRestrictedInt8u                                              | 0x0026 |
| * RangeRestrictedInt8s                                              | 0x0027 |
| * RangeRestrictedInt16u                                             | 0x0028 |
| * RangeRestrictedInt16s                                             | 0x0029 |
| * ListLongOctetString                                               | 0x002A |
| * ListFabricScoped                                                  | 0x002B |
| * TimedWriteBoolean                                                 | 0x0030 |
| * GeneralErrorBoolean                                               | 0x0031 |
| * ClusterErrorBoolean                                               | 0x0032 |
| * Unsupported                                                       | 0x00FF |
| * NullableBoolean                                                   | 0x4000 |
| * NullableBitmap8                                                   | 0x4001 |
| * NullableBitmap16                                                  | 0x4002 |
| * NullableBitmap32                                                  | 0x4003 |
| * NullableBitmap64                                                  | 0x4004 |
| * NullableInt8u                                                     | 0x4005 |
| * NullableInt16u                                                    | 0x4006 |
| * NullableInt24u                                                    | 0x4007 |
| * NullableInt32u                                                    | 0x4008 |
| * NullableInt40u                                                    | 0x4009 |
| * NullableInt48u                                                    | 0x400A |
| * NullableInt56u                                                    | 0x400B |
| * NullableInt64u                                                    | 0x400C |
| * NullableInt8s                                                     | 0x400D |
| * NullableInt16s                                                    | 0x400E |
| * NullableInt24s                                                    | 0x400F |
| * NullableInt32s                                                    | 0x4010 |
| * NullableInt40s                                                    | 0x4011 |
| * NullableInt48s                                                    | 0x4012 |
| * NullableInt56s                                                    | 0x4013 |
| * NullableInt64s                                                    | 0x4014 |
| * NullableEnum8                                                     | 0x4015 |
| * NullableEnum16                                                    | 0x4016 |
| * NullableFloatSingle                                               | 0x4017 |
| * NullableFloatDouble                                               | 0x4018 |
| * NullableOctetString                                               | 0x4019 |
| * NullableCharString                                                | 0x401E |
| * NullableEnumAttr                                                  | 0x4024 |
| * NullableStruct                                                    | 0x4025 |
| * NullableRangeRestrictedInt8u                                      | 0x4026 |
| * NullableRangeRestrictedInt8s                                      | 0x4027 |
| * NullableRangeRestrictedInt16u                                     | 0x4028 |
| * NullableRangeRestrictedInt16s                                     | 0x4029 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * TestEvent                                                         | 0x0001 |
| * TestFabricScopedEvent                                             | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command SimpleStructEchoRequest
 */
class TestClusterSimpleStructEchoRequest : public ModelCommand {
public:
    TestClusterSimpleStructEchoRequest()
        : ModelCommand("simple-struct-echo-request")
        , mComplex_Arg1(&mRequest.arg1)
    {
        AddArgument("Arg1", &mComplex_Arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterSimpleStructEchoRequestParams alloc] init];

        params.arg1 = [CHIPTestClusterClusterSimpleStruct new];
        params.arg1.a = [NSNumber numberWithUnsignedChar:mRequest.arg1.a];
        params.arg1.b = [NSNumber numberWithBool:mRequest.arg1.b];
        params.arg1.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(mRequest.arg1.c)];
        params.arg1.d = [NSData dataWithBytes:mRequest.arg1.d.data() length:mRequest.arg1.d.size()];
        params.arg1.e = [[NSString alloc] initWithBytes:mRequest.arg1.e.data()
                                                 length:mRequest.arg1.e.size()
                                               encoding:NSUTF8StringEncoding];
        params.arg1.f = [NSNumber numberWithUnsignedChar:mRequest.arg1.f.Raw()];
        params.arg1.g = [NSNumber numberWithFloat:mRequest.arg1.g];
        params.arg1.h = [NSNumber numberWithDouble:mRequest.arg1.h];
        [cluster simpleStructEchoRequestWithParams:params
                                 completionHandler:^(CHIPTestClusterClusterSimpleStructResponseParams * _Nullable values,
                                     NSError * _Nullable error) {
                                     NSLog(@"Values: %@", values);
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Commands::SimpleStructEchoRequest::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type> mComplex_Arg1;
};

/*
 * Command Test
 */
class TestClusterTest : public ModelCommand {
public:
    TestClusterTest()
        : ModelCommand("test")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster testWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command TestAddArguments
 */
class TestClusterTestAddArguments : public ModelCommand {
public:
    TestClusterTestAddArguments()
        : ModelCommand("test-add-arguments")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestAddArgumentsParams alloc] init];

        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];

        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];
        [cluster testAddArgumentsWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable values, NSError * _Nullable error) {
                              NSLog(@"Values: %@", values);
                              chipError = [CHIPError errorToCHIPErrorCode:error];
                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                              SetCommandExitStatus(chipError);
                          }];
        return chipError;
    }

private:
    uint8_t mArg1;
    uint8_t mArg2;
};

/*
 * Command TestEmitTestEventRequest
 */
class TestClusterTestEmitTestEventRequest : public ModelCommand {
public:
    TestClusterTestEmitTestEventRequest()
        : ModelCommand("test-emit-test-event-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        AddArgument("Arg3", 0, 1, &mArg3);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000014) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestEmitTestEventRequestParams alloc] init];

        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];

        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];

        params.arg3 = [NSNumber numberWithBool:mArg3];
        [cluster testEmitTestEventRequestWithParams:params
                                  completionHandler:^(CHIPTestClusterClusterTestEmitTestEventResponseParams * _Nullable values,
                                      NSError * _Nullable error) {
                                      NSLog(@"Values: %@", values);
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint8_t mArg1;
    uint8_t mArg2;
    bool mArg3;
};

/*
 * Command TestEnumsRequest
 */
class TestClusterTestEnumsRequest : public ModelCommand {
public:
    TestClusterTestEnumsRequest()
        : ModelCommand("test-enums-request")
    {
        AddArgument("Arg1", 0, UINT16_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestEnumsRequestParams alloc] init];

        params.arg1 = [NSNumber numberWithUnsignedShort:mArg1];

        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];
        [cluster testEnumsRequestWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestEnumsResponseParams * _Nullable values, NSError * _Nullable error) {
                              NSLog(@"Values: %@", values);
                              chipError = [CHIPError errorToCHIPErrorCode:error];
                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                              SetCommandExitStatus(chipError);
                          }];
        return chipError;
    }

private:
    chip::VendorId mArg1;
    uint8_t mArg2;
};

/*
 * Command TestListInt8UArgumentRequest
 */
class TestClusterTestListInt8UArgumentRequest : public ModelCommand {
public:
    TestClusterTestListInt8UArgumentRequest()
        : ModelCommand("test-list-int8uargument-request")
        , mComplex_Arg1(&mRequest.arg1)
    {
        AddArgument("Arg1", &mComplex_Arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UArgumentRequestParams alloc] init];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.arg1) {
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
                [array_0 addObject:newElement_0];
            }
            params.arg1 = array_0;
        }
        [cluster testListInt8UArgumentRequestWithParams:params
                                      completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                          NSError * _Nullable error) {
                                          NSLog(@"Values: %@", values);
                                          chipError = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                          SetCommandExitStatus(chipError);
                                      }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const uint8_t>> mComplex_Arg1;
};

/*
 * Command TestListInt8UReverseRequest
 */
class TestClusterTestListInt8UReverseRequest : public ModelCommand {
public:
    TestClusterTestListInt8UReverseRequest()
        : ModelCommand("test-list-int8ureverse-request")
        , mComplex_Arg1(&mRequest.arg1)
    {
        AddArgument("Arg1", &mComplex_Arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UReverseRequestParams alloc] init];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.arg1) {
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
                [array_0 addObject:newElement_0];
            }
            params.arg1 = array_0;
        }
        [cluster
            testListInt8UReverseRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestListInt8UReverseResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const uint8_t>> mComplex_Arg1;
};

/*
 * Command TestListNestedStructListArgumentRequest
 */
class TestClusterTestListNestedStructListArgumentRequest : public ModelCommand {
public:
    TestClusterTestListNestedStructListArgumentRequest()
        : ModelCommand("test-list-nested-struct-list-argument-request")
        , mComplex_Arg1(&mRequest.arg1)
    {
        AddArgument("Arg1", &mComplex_Arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestListNestedStructListArgumentRequestParams alloc] init];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.arg1) {
                CHIPTestClusterClusterNestedStructList * newElement_0;
                newElement_0 = [CHIPTestClusterClusterNestedStructList new];
                newElement_0.a = [NSNumber numberWithUnsignedChar:entry_0.a];
                newElement_0.b = [NSNumber numberWithBool:entry_0.b];
                newElement_0.c = [CHIPTestClusterClusterSimpleStruct new];
                newElement_0.c.a = [NSNumber numberWithUnsignedChar:entry_0.c.a];
                newElement_0.c.b = [NSNumber numberWithBool:entry_0.c.b];
                newElement_0.c.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.c.c)];
                newElement_0.c.d = [NSData dataWithBytes:entry_0.c.d.data() length:entry_0.c.d.size()];
                newElement_0.c.e = [[NSString alloc] initWithBytes:entry_0.c.e.data()
                                                            length:entry_0.c.e.size()
                                                          encoding:NSUTF8StringEncoding];
                newElement_0.c.f = [NSNumber numberWithUnsignedChar:entry_0.c.f.Raw()];
                newElement_0.c.g = [NSNumber numberWithFloat:entry_0.c.g];
                newElement_0.c.h = [NSNumber numberWithDouble:entry_0.c.h];
                { // Scope for our temporary variables
                    auto * array_2 = [NSMutableArray new];
                    for (auto & entry_2 : entry_0.d) {
                        CHIPTestClusterClusterSimpleStruct * newElement_2;
                        newElement_2 = [CHIPTestClusterClusterSimpleStruct new];
                        newElement_2.a = [NSNumber numberWithUnsignedChar:entry_2.a];
                        newElement_2.b = [NSNumber numberWithBool:entry_2.b];
                        newElement_2.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_2.c)];
                        newElement_2.d = [NSData dataWithBytes:entry_2.d.data() length:entry_2.d.size()];
                        newElement_2.e = [[NSString alloc] initWithBytes:entry_2.e.data()
                                                                  length:entry_2.e.size()
                                                                encoding:NSUTF8StringEncoding];
                        newElement_2.f = [NSNumber numberWithUnsignedChar:entry_2.f.Raw()];
                        newElement_2.g = [NSNumber numberWithFloat:entry_2.g];
                        newElement_2.h = [NSNumber numberWithDouble:entry_2.h];
                        [array_2 addObject:newElement_2];
                    }
                    newElement_0.d = array_2;
                }
                { // Scope for our temporary variables
                    auto * array_2 = [NSMutableArray new];
                    for (auto & entry_2 : entry_0.e) {
                        NSNumber * newElement_2;
                        newElement_2 = [NSNumber numberWithUnsignedInt:entry_2];
                        [array_2 addObject:newElement_2];
                    }
                    newElement_0.e = array_2;
                }
                { // Scope for our temporary variables
                    auto * array_2 = [NSMutableArray new];
                    for (auto & entry_2 : entry_0.f) {
                        NSData * newElement_2;
                        newElement_2 = [NSData dataWithBytes:entry_2.data() length:entry_2.size()];
                        [array_2 addObject:newElement_2];
                    }
                    newElement_0.f = array_2;
                }
                { // Scope for our temporary variables
                    auto * array_2 = [NSMutableArray new];
                    for (auto & entry_2 : entry_0.g) {
                        NSNumber * newElement_2;
                        newElement_2 = [NSNumber numberWithUnsignedChar:entry_2];
                        [array_2 addObject:newElement_2];
                    }
                    newElement_0.g = array_2;
                }
                [array_0 addObject:newElement_0];
            }
            params.arg1 = array_0;
        }
        [cluster testListNestedStructListArgumentRequestWithParams:params
                                                 completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                     NSError * _Nullable error) {
                                                     NSLog(@"Values: %@", values);
                                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                                     SetCommandExitStatus(chipError);
                                                 }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>>
        mComplex_Arg1;
};

/*
 * Command TestListStructArgumentRequest
 */
class TestClusterTestListStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestListStructArgumentRequest()
        : ModelCommand("test-list-struct-argument-request")
        , mComplex_Arg1(&mRequest.arg1)
    {
        AddArgument("Arg1", &mComplex_Arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestListStructArgumentRequestParams alloc] init];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.arg1) {
                CHIPTestClusterClusterSimpleStruct * newElement_0;
                newElement_0 = [CHIPTestClusterClusterSimpleStruct new];
                newElement_0.a = [NSNumber numberWithUnsignedChar:entry_0.a];
                newElement_0.b = [NSNumber numberWithBool:entry_0.b];
                newElement_0.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.c)];
                newElement_0.d = [NSData dataWithBytes:entry_0.d.data() length:entry_0.d.size()];
                newElement_0.e = [[NSString alloc] initWithBytes:entry_0.e.data()
                                                          length:entry_0.e.size()
                                                        encoding:NSUTF8StringEncoding];
                newElement_0.f = [NSNumber numberWithUnsignedChar:entry_0.f.Raw()];
                newElement_0.g = [NSNumber numberWithFloat:entry_0.g];
                newElement_0.h = [NSNumber numberWithDouble:entry_0.h];
                [array_0 addObject:newElement_0];
            }
            params.arg1 = array_0;
        }
        [cluster testListStructArgumentRequestWithParams:params
                                       completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                           NSError * _Nullable error) {
                                           NSLog(@"Values: %@", values);
                                           chipError = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                           SetCommandExitStatus(chipError);
                                       }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>>
        mComplex_Arg1;
};

/*
 * Command TestNestedStructArgumentRequest
 */
class TestClusterTestNestedStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestNestedStructArgumentRequest()
        : ModelCommand("test-nested-struct-argument-request")
        , mComplex_Arg1(&mRequest.arg1)
    {
        AddArgument("Arg1", &mComplex_Arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructArgumentRequestParams alloc] init];

        params.arg1 = [CHIPTestClusterClusterNestedStruct new];
        params.arg1.a = [NSNumber numberWithUnsignedChar:mRequest.arg1.a];
        params.arg1.b = [NSNumber numberWithBool:mRequest.arg1.b];
        params.arg1.c = [CHIPTestClusterClusterSimpleStruct new];
        params.arg1.c.a = [NSNumber numberWithUnsignedChar:mRequest.arg1.c.a];
        params.arg1.c.b = [NSNumber numberWithBool:mRequest.arg1.c.b];
        params.arg1.c.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(mRequest.arg1.c.c)];
        params.arg1.c.d = [NSData dataWithBytes:mRequest.arg1.c.d.data() length:mRequest.arg1.c.d.size()];
        params.arg1.c.e = [[NSString alloc] initWithBytes:mRequest.arg1.c.e.data()
                                                   length:mRequest.arg1.c.e.size()
                                                 encoding:NSUTF8StringEncoding];
        params.arg1.c.f = [NSNumber numberWithUnsignedChar:mRequest.arg1.c.f.Raw()];
        params.arg1.c.g = [NSNumber numberWithFloat:mRequest.arg1.c.g];
        params.arg1.c.h = [NSNumber numberWithDouble:mRequest.arg1.c.h];
        [cluster testNestedStructArgumentRequestWithParams:params
                                         completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                             NSError * _Nullable error) {
                                             NSLog(@"Values: %@", values);
                                             chipError = [CHIPError errorToCHIPErrorCode:error];
                                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                             SetCommandExitStatus(chipError);
                                         }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::TestCluster::Structs::NestedStruct::Type> mComplex_Arg1;
};

/*
 * Command TestNestedStructListArgumentRequest
 */
class TestClusterTestNestedStructListArgumentRequest : public ModelCommand {
public:
    TestClusterTestNestedStructListArgumentRequest()
        : ModelCommand("test-nested-struct-list-argument-request")
        , mComplex_Arg1(&mRequest.arg1)
    {
        AddArgument("Arg1", &mComplex_Arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructListArgumentRequestParams alloc] init];

        params.arg1 = [CHIPTestClusterClusterNestedStructList new];
        params.arg1.a = [NSNumber numberWithUnsignedChar:mRequest.arg1.a];
        params.arg1.b = [NSNumber numberWithBool:mRequest.arg1.b];
        params.arg1.c = [CHIPTestClusterClusterSimpleStruct new];
        params.arg1.c.a = [NSNumber numberWithUnsignedChar:mRequest.arg1.c.a];
        params.arg1.c.b = [NSNumber numberWithBool:mRequest.arg1.c.b];
        params.arg1.c.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(mRequest.arg1.c.c)];
        params.arg1.c.d = [NSData dataWithBytes:mRequest.arg1.c.d.data() length:mRequest.arg1.c.d.size()];
        params.arg1.c.e = [[NSString alloc] initWithBytes:mRequest.arg1.c.e.data()
                                                   length:mRequest.arg1.c.e.size()
                                                 encoding:NSUTF8StringEncoding];
        params.arg1.c.f = [NSNumber numberWithUnsignedChar:mRequest.arg1.c.f.Raw()];
        params.arg1.c.g = [NSNumber numberWithFloat:mRequest.arg1.c.g];
        params.arg1.c.h = [NSNumber numberWithDouble:mRequest.arg1.c.h];
        { // Scope for our temporary variables
            auto * array_1 = [NSMutableArray new];
            for (auto & entry_1 : mRequest.arg1.d) {
                CHIPTestClusterClusterSimpleStruct * newElement_1;
                newElement_1 = [CHIPTestClusterClusterSimpleStruct new];
                newElement_1.a = [NSNumber numberWithUnsignedChar:entry_1.a];
                newElement_1.b = [NSNumber numberWithBool:entry_1.b];
                newElement_1.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_1.c)];
                newElement_1.d = [NSData dataWithBytes:entry_1.d.data() length:entry_1.d.size()];
                newElement_1.e = [[NSString alloc] initWithBytes:entry_1.e.data()
                                                          length:entry_1.e.size()
                                                        encoding:NSUTF8StringEncoding];
                newElement_1.f = [NSNumber numberWithUnsignedChar:entry_1.f.Raw()];
                newElement_1.g = [NSNumber numberWithFloat:entry_1.g];
                newElement_1.h = [NSNumber numberWithDouble:entry_1.h];
                [array_1 addObject:newElement_1];
            }
            params.arg1.d = array_1;
        }
        { // Scope for our temporary variables
            auto * array_1 = [NSMutableArray new];
            for (auto & entry_1 : mRequest.arg1.e) {
                NSNumber * newElement_1;
                newElement_1 = [NSNumber numberWithUnsignedInt:entry_1];
                [array_1 addObject:newElement_1];
            }
            params.arg1.e = array_1;
        }
        { // Scope for our temporary variables
            auto * array_1 = [NSMutableArray new];
            for (auto & entry_1 : mRequest.arg1.f) {
                NSData * newElement_1;
                newElement_1 = [NSData dataWithBytes:entry_1.data() length:entry_1.size()];
                [array_1 addObject:newElement_1];
            }
            params.arg1.f = array_1;
        }
        { // Scope for our temporary variables
            auto * array_1 = [NSMutableArray new];
            for (auto & entry_1 : mRequest.arg1.g) {
                NSNumber * newElement_1;
                newElement_1 = [NSNumber numberWithUnsignedChar:entry_1];
                [array_1 addObject:newElement_1];
            }
            params.arg1.g = array_1;
        }
        [cluster testNestedStructListArgumentRequestWithParams:params
                                             completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                 NSError * _Nullable error) {
                                                 NSLog(@"Values: %@", values);
                                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                                 SetCommandExitStatus(chipError);
                                             }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type> mComplex_Arg1;
};

/*
 * Command TestNotHandled
 */
class TestClusterTestNotHandled : public ModelCommand {
public:
    TestClusterTestNotHandled()
        : ModelCommand("test-not-handled")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster testNotHandledWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command TestNullableOptionalRequest
 */
class TestClusterTestNullableOptionalRequest : public ModelCommand {
public:
    TestClusterTestNullableOptionalRequest()
        : ModelCommand("test-nullable-optional-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestNullableOptionalRequestParams alloc] init];

        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];
        [cluster
            testNullableOptionalRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestNullableOptionalResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    uint8_t mArg1;
};

/*
 * Command TestSimpleOptionalArgumentRequest
 */
class TestClusterTestSimpleOptionalArgumentRequest : public ModelCommand {
public:
    TestClusterTestSimpleOptionalArgumentRequest()
        : ModelCommand("test-simple-optional-argument-request")
    {
        AddArgument("Arg1", 0, 1, &mArg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestSimpleOptionalArgumentRequestParams alloc] init];

        params.arg1 = [NSNumber numberWithBool:mArg1];
        [cluster testSimpleOptionalArgumentRequestWithParams:params
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    bool mArg1;
};

/*
 * Command TestSpecific
 */
class TestClusterTestSpecific : public ModelCommand {
public:
    TestClusterTestSpecific()
        : ModelCommand("test-specific")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster testSpecificWithCompletionHandler:^(
            CHIPTestClusterClusterTestSpecificResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command TestStructArgumentRequest
 */
class TestClusterTestStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestStructArgumentRequest()
        : ModelCommand("test-struct-argument-request")
        , mComplex_Arg1(&mRequest.arg1)
    {
        AddArgument("Arg1", &mComplex_Arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestStructArgumentRequestParams alloc] init];

        params.arg1 = [CHIPTestClusterClusterSimpleStruct new];
        params.arg1.a = [NSNumber numberWithUnsignedChar:mRequest.arg1.a];
        params.arg1.b = [NSNumber numberWithBool:mRequest.arg1.b];
        params.arg1.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(mRequest.arg1.c)];
        params.arg1.d = [NSData dataWithBytes:mRequest.arg1.d.data() length:mRequest.arg1.d.size()];
        params.arg1.e = [[NSString alloc] initWithBytes:mRequest.arg1.e.data()
                                                 length:mRequest.arg1.e.size()
                                               encoding:NSUTF8StringEncoding];
        params.arg1.f = [NSNumber numberWithUnsignedChar:mRequest.arg1.f.Raw()];
        params.arg1.g = [NSNumber numberWithFloat:mRequest.arg1.g];
        params.arg1.h = [NSNumber numberWithDouble:mRequest.arg1.h];
        [cluster testStructArgumentRequestWithParams:params
                                   completionHandler:^(
                                       CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable error) {
                                       NSLog(@"Values: %@", values);
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type mRequest;
    TypedComplexArgument<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type> mComplex_Arg1;
};

/*
 * Command TestUnknownCommand
 */
class TestClusterTestUnknownCommand : public ModelCommand {
public:
    TestClusterTestUnknownCommand()
        : ModelCommand("test-unknown-command")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster testUnknownCommandWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command TimedInvokeRequest
 */
class TestClusterTimedInvokeRequest : public ModelCommand {
public:
    TestClusterTimedInvokeRequest()
        : ModelCommand("timed-invoke-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster timedInvokeRequestWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute Boolean
 */
class ReadTestClusterBoolean : public ModelCommand {
public:
    ReadTestClusterBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Boolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Boolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBoolean : public ModelCommand {
public:
    WriteTestClusterBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeBooleanWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "TestCluster Boolean Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"TestCluster.Boolean response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap8
 */
class ReadTestClusterBitmap8 : public ModelCommand {
public:
    ReadTestClusterBitmap8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap8 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBitmap8 : public ModelCommand {
public:
    WriteTestClusterBitmap8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeBitmap8WithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "TestCluster Bitmap8 Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterBitmap8 : public ModelCommand {
public:
    SubscribeAttributeTestClusterBitmap8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBitmap8WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"TestCluster.Bitmap8 response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap16
 */
class ReadTestClusterBitmap16 : public ModelCommand {
public:
    ReadTestClusterBitmap16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap16 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBitmap16 : public ModelCommand {
public:
    WriteTestClusterBitmap16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeBitmap16WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster Bitmap16 Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterBitmap16 : public ModelCommand {
public:
    SubscribeAttributeTestClusterBitmap16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBitmap16WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.Bitmap16 response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap32
 */
class ReadTestClusterBitmap32 : public ModelCommand {
public:
    ReadTestClusterBitmap32()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap32 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap32 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBitmap32 : public ModelCommand {
public:
    WriteTestClusterBitmap32()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeBitmap32WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster Bitmap32 Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterBitmap32 : public ModelCommand {
public:
    SubscribeAttributeTestClusterBitmap32()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBitmap32WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.Bitmap32 response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap64
 */
class ReadTestClusterBitmap64 : public ModelCommand {
public:
    ReadTestClusterBitmap64()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap64 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap64 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBitmap64 : public ModelCommand {
public:
    WriteTestClusterBitmap64()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeBitmap64WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster Bitmap64 Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterBitmap64 : public ModelCommand {
public:
    SubscribeAttributeTestClusterBitmap64()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBitmap64WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.Bitmap64 response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8u
 */
class ReadTestClusterInt8u : public ModelCommand {
public:
    ReadTestClusterInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt8u : public ModelCommand {
public:
    WriteTestClusterInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeInt8uWithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogError(chipTool, "TestCluster Int8u Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"TestCluster.Int8u response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16u
 */
class ReadTestClusterInt16u : public ModelCommand {
public:
    ReadTestClusterInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int16u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt16u : public ModelCommand {
public:
    WriteTestClusterInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeInt16uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int16u Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterInt16u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt16uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int16u response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int24u
 */
class ReadTestClusterInt24u : public ModelCommand {
public:
    ReadTestClusterInt24u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int24u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt24uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int24u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int24u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt24u : public ModelCommand {
public:
    WriteTestClusterInt24u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int24u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeInt24uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int24u Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterInt24u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt24u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int24u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt24uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int24u response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32u
 */
class ReadTestClusterInt32u : public ModelCommand {
public:
    ReadTestClusterInt32u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int32u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int32u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt32u : public ModelCommand {
public:
    WriteTestClusterInt32u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeInt32uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int32u Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterInt32u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt32u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt32uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int32u response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int40u
 */
class ReadTestClusterInt40u : public ModelCommand {
public:
    ReadTestClusterInt40u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int40u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt40uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int40u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int40u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt40u : public ModelCommand {
public:
    WriteTestClusterInt40u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int40u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeInt40uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int40u Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterInt40u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt40u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int40u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt40uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int40u response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int48u
 */
class ReadTestClusterInt48u : public ModelCommand {
public:
    ReadTestClusterInt48u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int48u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt48uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int48u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int48u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt48u : public ModelCommand {
public:
    WriteTestClusterInt48u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int48u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeInt48uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int48u Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterInt48u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt48u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int48u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt48uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int48u response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int56u
 */
class ReadTestClusterInt56u : public ModelCommand {
public:
    ReadTestClusterInt56u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int56u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt56uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int56u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int56u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt56u : public ModelCommand {
public:
    WriteTestClusterInt56u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int56u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeInt56uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int56u Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterInt56u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt56u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int56u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt56uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int56u response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64u
 */
class ReadTestClusterInt64u : public ModelCommand {
public:
    ReadTestClusterInt64u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int64u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int64u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt64u : public ModelCommand {
public:
    WriteTestClusterInt64u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeInt64uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int64u Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterInt64u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt64u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt64uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int64u response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8s
 */
class ReadTestClusterInt8s : public ModelCommand {
public:
    ReadTestClusterInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int8s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt8s : public ModelCommand {
public:
    WriteTestClusterInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];

        [cluster writeAttributeInt8sWithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogError(chipTool, "TestCluster Int8s Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeTestClusterInt8s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt8sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"TestCluster.Int8s response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16s
 */
class ReadTestClusterInt16s : public ModelCommand {
public:
    ReadTestClusterInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int16s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt16s : public ModelCommand {
public:
    WriteTestClusterInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeInt16sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int16s Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeTestClusterInt16s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt16sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int16s response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int24s
 */
class ReadTestClusterInt24s : public ModelCommand {
public:
    ReadTestClusterInt24s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int24s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt24sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int24s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int24s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt24s : public ModelCommand {
public:
    WriteTestClusterInt24s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int24s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithInt:mValue];

        [cluster writeAttributeInt24sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int24s Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    int32_t mValue;
};

class SubscribeAttributeTestClusterInt24s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt24s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int24s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt24sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int24s response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32s
 */
class ReadTestClusterInt32s : public ModelCommand {
public:
    ReadTestClusterInt32s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int32s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int32s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt32s : public ModelCommand {
public:
    WriteTestClusterInt32s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithInt:mValue];

        [cluster writeAttributeInt32sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int32s Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    int32_t mValue;
};

class SubscribeAttributeTestClusterInt32s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt32s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt32sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int32s response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int40s
 */
class ReadTestClusterInt40s : public ModelCommand {
public:
    ReadTestClusterInt40s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int40s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt40sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int40s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int40s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt40s : public ModelCommand {
public:
    WriteTestClusterInt40s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int40s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeInt40sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int40s Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterInt40s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt40s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int40s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt40sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int40s response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int48s
 */
class ReadTestClusterInt48s : public ModelCommand {
public:
    ReadTestClusterInt48s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int48s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt48sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int48s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int48s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt48s : public ModelCommand {
public:
    WriteTestClusterInt48s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int48s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeInt48sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int48s Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterInt48s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt48s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int48s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt48sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int48s response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int56s
 */
class ReadTestClusterInt56s : public ModelCommand {
public:
    ReadTestClusterInt56s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int56s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt56sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int56s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int56s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt56s : public ModelCommand {
public:
    WriteTestClusterInt56s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int56s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeInt56sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int56s Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterInt56s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt56s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int56s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt56sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int56s response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64s
 */
class ReadTestClusterInt64s : public ModelCommand {
public:
    ReadTestClusterInt64s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000014) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int64s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int64s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt64s : public ModelCommand {
public:
    WriteTestClusterInt64s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeInt64sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int64s Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterInt64s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt64s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt64sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int64s response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum8
 */
class ReadTestClusterEnum8 : public ModelCommand {
public:
    ReadTestClusterEnum8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000015) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Enum8 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Enum8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEnum8 : public ModelCommand {
public:
    WriteTestClusterEnum8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeEnum8WithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogError(chipTool, "TestCluster Enum8 Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterEnum8 : public ModelCommand {
public:
    SubscribeAttributeTestClusterEnum8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnum8WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"TestCluster.Enum8 response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum16
 */
class ReadTestClusterEnum16 : public ModelCommand {
public:
    ReadTestClusterEnum16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000016) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Enum16 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Enum16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEnum16 : public ModelCommand {
public:
    WriteTestClusterEnum16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeEnum16WithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Enum16 Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterEnum16 : public ModelCommand {
public:
    SubscribeAttributeTestClusterEnum16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnum16WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Enum16 response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FloatSingle
 */
class ReadTestClusterFloatSingle : public ModelCommand {
public:
    ReadTestClusterFloatSingle()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "float-single");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000017) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.FloatSingle response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster FloatSingle Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterFloatSingle : public ModelCommand {
public:
    WriteTestClusterFloatSingle()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "float-single");
        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithFloat:mValue];

        [cluster writeAttributeFloatSingleWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster FloatSingle Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    float mValue;
};

class SubscribeAttributeTestClusterFloatSingle : public ModelCommand {
public:
    SubscribeAttributeTestClusterFloatSingle()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "float-single");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFloatSingleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"TestCluster.FloatSingle response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FloatDouble
 */
class ReadTestClusterFloatDouble : public ModelCommand {
public:
    ReadTestClusterFloatDouble()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "float-double");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000018) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.FloatDouble response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster FloatDouble Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterFloatDouble : public ModelCommand {
public:
    WriteTestClusterFloatDouble()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "float-double");
        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000018) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithDouble:mValue];

        [cluster writeAttributeFloatDoubleWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster FloatDouble Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    double mValue;
};

class SubscribeAttributeTestClusterFloatDouble : public ModelCommand {
public:
    SubscribeAttributeTestClusterFloatDouble()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "float-double");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000018) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFloatDoubleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"TestCluster.FloatDouble response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OctetString
 */
class ReadTestClusterOctetString : public ModelCommand {
public:
    ReadTestClusterOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000019) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.OctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster OctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterOctetString : public ModelCommand {
public:
    WriteTestClusterOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSData * _Nonnull value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];

        [cluster writeAttributeOctetStringWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster OctetString Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"TestCluster.OctetString response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListInt8u
 */
class ReadTestClusterListInt8u : public ModelCommand {
public:
    ReadTestClusterListInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListInt8uWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListInt8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterListInt8u : public ModelCommand {
public:
    WriteTestClusterListInt8u()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "list-int8u");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeListInt8uWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogError(chipTool, "TestCluster ListInt8u Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const uint8_t> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const uint8_t>> mComplex;
};

class SubscribeAttributeTestClusterListInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterListInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeListInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"TestCluster.ListInt8u response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListOctetString
 */
class ReadTestClusterListOctetString : public ModelCommand {
public:
    ReadTestClusterListOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterListOctetString : public ModelCommand {
public:
    WriteTestClusterListOctetString()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "list-octet-string");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                NSData * newElement_0;
                newElement_0 = [NSData dataWithBytes:entry_0.data() length:entry_0.size()];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster
            writeAttributeListOctetStringWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TestCluster ListOctetString Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::ByteSpan> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const chip::ByteSpan>> mComplex;
};

class SubscribeAttributeTestClusterListOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterListOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeListOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.ListOctetString response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListStructOctetString
 */
class ReadTestClusterListStructOctetString : public ModelCommand {
public:
    ReadTestClusterListStructOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListStructOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListStructOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListStructOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterListStructOctetString : public ModelCommand {
public:
    WriteTestClusterListStructOctetString()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "list-struct-octet-string");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPTestClusterClusterTestListStructOctet * newElement_0;
                newElement_0 = [CHIPTestClusterClusterTestListStructOctet new];
                newElement_0.fabricIndex = [NSNumber numberWithUnsignedLongLong:entry_0.fabricIndex];
                newElement_0.operationalCert = [NSData dataWithBytes:entry_0.operationalCert.data()
                                                              length:entry_0.operationalCert.size()];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeListStructOctetStringWithValue:value
                                            completionHandler:^(NSError * _Nullable error) {
                                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                                ChipLogError(chipTool, "TestCluster ListStructOctetString Error: %s",
                                                    chip::ErrorStr(chipError));
                                                SetCommandExitStatus(chipError);
                                            }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>>
        mComplex;
};

class SubscribeAttributeTestClusterListStructOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterListStructOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeListStructOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TestCluster.ListStructOctetString response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongOctetString
 */
class ReadTestClusterLongOctetString : public ModelCommand {
public:
    ReadTestClusterLongOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLongOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.LongOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster LongOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterLongOctetString : public ModelCommand {
public:
    WriteTestClusterLongOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSData * _Nonnull value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];

        [cluster
            writeAttributeLongOctetStringWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TestCluster LongOctetString Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterLongOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterLongOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLongOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.LongOctetString response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CharString
 */
class ReadTestClusterCharString : public ModelCommand {
public:
    ReadTestClusterCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.CharString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster CharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterCharString : public ModelCommand {
public:
    WriteTestClusterCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeCharStringWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TestCluster CharString Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterCharString : public ModelCommand {
public:
    SubscribeAttributeTestClusterCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCharStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"TestCluster.CharString response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongCharString
 */
class ReadTestClusterLongCharString : public ModelCommand {
public:
    ReadTestClusterLongCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "long-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLongCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.LongCharString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster LongCharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterLongCharString : public ModelCommand {
public:
    WriteTestClusterLongCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLongCharStringWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster LongCharString Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterLongCharString : public ModelCommand {
public:
    SubscribeAttributeTestClusterLongCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLongCharStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.LongCharString response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochUs
 */
class ReadTestClusterEpochUs : public ModelCommand {
public:
    ReadTestClusterEpochUs()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-us");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000020) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EpochUs response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EpochUs Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEpochUs : public ModelCommand {
public:
    WriteTestClusterEpochUs()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000020) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeEpochUsWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "TestCluster EpochUs Error: %s", chip::ErrorStr(chipError));
                                  SetCommandExitStatus(chipError);
                              }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterEpochUs : public ModelCommand {
public:
    SubscribeAttributeTestClusterEpochUs()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000020) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEpochUsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"TestCluster.EpochUs response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochS
 */
class ReadTestClusterEpochS : public ModelCommand {
public:
    ReadTestClusterEpochS()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000021) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EpochS response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EpochS Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEpochS : public ModelCommand {
public:
    WriteTestClusterEpochS()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeEpochSWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster EpochS Error: %s", chip::ErrorStr(chipError));
                                 SetCommandExitStatus(chipError);
                             }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterEpochS : public ModelCommand {
public:
    SubscribeAttributeTestClusterEpochS()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEpochSWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:nullptr
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.EpochS response %@", [value description]);
                                               if (error || !mWait) {
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorId
 */
class ReadTestClusterVendorId : public ModelCommand {
public:
    ReadTestClusterVendorId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000022) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.VendorId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster VendorId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterVendorId : public ModelCommand {
public:
    WriteTestClusterVendorId()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000022) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeVendorIdWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster VendorId Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    chip::VendorId mValue;
};

class SubscribeAttributeTestClusterVendorId : public ModelCommand {
public:
    SubscribeAttributeTestClusterVendorId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000022) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.VendorId response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListNullablesAndOptionalsStruct
 */
class ReadTestClusterListNullablesAndOptionalsStruct : public ModelCommand {
public:
    ReadTestClusterListNullablesAndOptionalsStruct()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000023) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListNullablesAndOptionalsStructWithCompletionHandler:^(
            NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListNullablesAndOptionalsStruct response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListNullablesAndOptionalsStruct Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterListNullablesAndOptionalsStruct : public ModelCommand {
public:
    WriteTestClusterListNullablesAndOptionalsStruct()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000023) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPTestClusterClusterNullablesAndOptionalsStruct * newElement_0;
                newElement_0 = [CHIPTestClusterClusterNullablesAndOptionalsStruct new];
                if (entry_0.nullableInt.IsNull()) {
                    newElement_0.nullableInt = nil;
                } else {
                    newElement_0.nullableInt = [NSNumber numberWithUnsignedShort:entry_0.nullableInt.Value()];
                }
                if (entry_0.optionalInt.HasValue()) {
                    newElement_0.optionalInt = [NSNumber numberWithUnsignedShort:entry_0.optionalInt.Value()];
                } else {
                    newElement_0.optionalInt = nil;
                }
                if (entry_0.nullableOptionalInt.HasValue()) {
                    if (entry_0.nullableOptionalInt.Value().IsNull()) {
                        newElement_0.nullableOptionalInt = nil;
                    } else {
                        newElement_0.nullableOptionalInt =
                            [NSNumber numberWithUnsignedShort:entry_0.nullableOptionalInt.Value().Value()];
                    }
                } else {
                    newElement_0.nullableOptionalInt = nil;
                }
                if (entry_0.nullableString.IsNull()) {
                    newElement_0.nullableString = nil;
                } else {
                    newElement_0.nullableString = [[NSString alloc] initWithBytes:entry_0.nullableString.Value().data()
                                                                           length:entry_0.nullableString.Value().size()
                                                                         encoding:NSUTF8StringEncoding];
                }
                if (entry_0.optionalString.HasValue()) {
                    newElement_0.optionalString = [[NSString alloc] initWithBytes:entry_0.optionalString.Value().data()
                                                                           length:entry_0.optionalString.Value().size()
                                                                         encoding:NSUTF8StringEncoding];
                } else {
                    newElement_0.optionalString = nil;
                }
                if (entry_0.nullableOptionalString.HasValue()) {
                    if (entry_0.nullableOptionalString.Value().IsNull()) {
                        newElement_0.nullableOptionalString = nil;
                    } else {
                        newElement_0.nullableOptionalString =
                            [[NSString alloc] initWithBytes:entry_0.nullableOptionalString.Value().Value().data()
                                                     length:entry_0.nullableOptionalString.Value().Value().size()
                                                   encoding:NSUTF8StringEncoding];
                    }
                } else {
                    newElement_0.nullableOptionalString = nil;
                }
                if (entry_0.nullableStruct.IsNull()) {
                    newElement_0.nullableStruct = nil;
                } else {
                    newElement_0.nullableStruct = [CHIPTestClusterClusterSimpleStruct new];
                    newElement_0.nullableStruct.a = [NSNumber numberWithUnsignedChar:entry_0.nullableStruct.Value().a];
                    newElement_0.nullableStruct.b = [NSNumber numberWithBool:entry_0.nullableStruct.Value().b];
                    newElement_0.nullableStruct.c =
                        [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.nullableStruct.Value().c)];
                    newElement_0.nullableStruct.d = [NSData dataWithBytes:entry_0.nullableStruct.Value().d.data()
                                                                   length:entry_0.nullableStruct.Value().d.size()];
                    newElement_0.nullableStruct.e = [[NSString alloc] initWithBytes:entry_0.nullableStruct.Value().e.data()
                                                                             length:entry_0.nullableStruct.Value().e.size()
                                                                           encoding:NSUTF8StringEncoding];
                    newElement_0.nullableStruct.f = [NSNumber numberWithUnsignedChar:entry_0.nullableStruct.Value().f.Raw()];
                    newElement_0.nullableStruct.g = [NSNumber numberWithFloat:entry_0.nullableStruct.Value().g];
                    newElement_0.nullableStruct.h = [NSNumber numberWithDouble:entry_0.nullableStruct.Value().h];
                }
                if (entry_0.optionalStruct.HasValue()) {
                    newElement_0.optionalStruct = [CHIPTestClusterClusterSimpleStruct new];
                    newElement_0.optionalStruct.a = [NSNumber numberWithUnsignedChar:entry_0.optionalStruct.Value().a];
                    newElement_0.optionalStruct.b = [NSNumber numberWithBool:entry_0.optionalStruct.Value().b];
                    newElement_0.optionalStruct.c =
                        [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.optionalStruct.Value().c)];
                    newElement_0.optionalStruct.d = [NSData dataWithBytes:entry_0.optionalStruct.Value().d.data()
                                                                   length:entry_0.optionalStruct.Value().d.size()];
                    newElement_0.optionalStruct.e = [[NSString alloc] initWithBytes:entry_0.optionalStruct.Value().e.data()
                                                                             length:entry_0.optionalStruct.Value().e.size()
                                                                           encoding:NSUTF8StringEncoding];
                    newElement_0.optionalStruct.f = [NSNumber numberWithUnsignedChar:entry_0.optionalStruct.Value().f.Raw()];
                    newElement_0.optionalStruct.g = [NSNumber numberWithFloat:entry_0.optionalStruct.Value().g];
                    newElement_0.optionalStruct.h = [NSNumber numberWithDouble:entry_0.optionalStruct.Value().h];
                } else {
                    newElement_0.optionalStruct = nil;
                }
                if (entry_0.nullableOptionalStruct.HasValue()) {
                    if (entry_0.nullableOptionalStruct.Value().IsNull()) {
                        newElement_0.nullableOptionalStruct = nil;
                    } else {
                        newElement_0.nullableOptionalStruct = [CHIPTestClusterClusterSimpleStruct new];
                        newElement_0.nullableOptionalStruct.a =
                            [NSNumber numberWithUnsignedChar:entry_0.nullableOptionalStruct.Value().Value().a];
                        newElement_0.nullableOptionalStruct.b =
                            [NSNumber numberWithBool:entry_0.nullableOptionalStruct.Value().Value().b];
                        newElement_0.nullableOptionalStruct.c =
                            [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.nullableOptionalStruct.Value().Value().c)];
                        newElement_0.nullableOptionalStruct.d =
                            [NSData dataWithBytes:entry_0.nullableOptionalStruct.Value().Value().d.data()
                                           length:entry_0.nullableOptionalStruct.Value().Value().d.size()];
                        newElement_0.nullableOptionalStruct.e =
                            [[NSString alloc] initWithBytes:entry_0.nullableOptionalStruct.Value().Value().e.data()
                                                     length:entry_0.nullableOptionalStruct.Value().Value().e.size()
                                                   encoding:NSUTF8StringEncoding];
                        newElement_0.nullableOptionalStruct.f =
                            [NSNumber numberWithUnsignedChar:entry_0.nullableOptionalStruct.Value().Value().f.Raw()];
                        newElement_0.nullableOptionalStruct.g =
                            [NSNumber numberWithFloat:entry_0.nullableOptionalStruct.Value().Value().g];
                        newElement_0.nullableOptionalStruct.h =
                            [NSNumber numberWithDouble:entry_0.nullableOptionalStruct.Value().Value().h];
                    }
                } else {
                    newElement_0.nullableOptionalStruct = nil;
                }
                if (entry_0.nullableList.IsNull()) {
                    newElement_0.nullableList = nil;
                } else {
                    { // Scope for our temporary variables
                        auto * array_3 = [NSMutableArray new];
                        for (auto & entry_3 : entry_0.nullableList.Value()) {
                            NSNumber * newElement_3;
                            newElement_3 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_3)];
                            [array_3 addObject:newElement_3];
                        }
                        newElement_0.nullableList = array_3;
                    }
                }
                if (entry_0.optionalList.HasValue()) {
                    { // Scope for our temporary variables
                        auto * array_3 = [NSMutableArray new];
                        for (auto & entry_3 : entry_0.optionalList.Value()) {
                            NSNumber * newElement_3;
                            newElement_3 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_3)];
                            [array_3 addObject:newElement_3];
                        }
                        newElement_0.optionalList = array_3;
                    }
                } else {
                    newElement_0.optionalList = nil;
                }
                if (entry_0.nullableOptionalList.HasValue()) {
                    if (entry_0.nullableOptionalList.Value().IsNull()) {
                        newElement_0.nullableOptionalList = nil;
                    } else {
                        { // Scope for our temporary variables
                            auto * array_4 = [NSMutableArray new];
                            for (auto & entry_4 : entry_0.nullableOptionalList.Value().Value()) {
                                NSNumber * newElement_4;
                                newElement_4 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_4)];
                                [array_4 addObject:newElement_4];
                            }
                            newElement_0.nullableOptionalList = array_4;
                        }
                    }
                } else {
                    newElement_0.nullableOptionalList = nil;
                }
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster
            writeAttributeListNullablesAndOptionalsStructWithValue:value
                                                 completionHandler:^(NSError * _Nullable error) {
                                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                                     ChipLogError(chipTool, "TestCluster ListNullablesAndOptionalsStruct Error: %s",
                                                         chip::ErrorStr(chipError));
                                                     SetCommandExitStatus(chipError);
                                                 }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type> mValue;
    TypedComplexArgument<
        chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>>
        mComplex;
};

class SubscribeAttributeTestClusterListNullablesAndOptionalsStruct : public ModelCommand {
public:
    SubscribeAttributeTestClusterListNullablesAndOptionalsStruct()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000023) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeListNullablesAndOptionalsStructWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                      params:params
                                                     subscriptionEstablished:nullptr
                                                               reportHandler:^(
                                                                   NSArray * _Nullable value, NSError * _Nullable error) {
                                                                   NSLog(@"TestCluster.ListNullablesAndOptionalsStruct response %@",
                                                                       [value description]);
                                                                   if (error || !mWait) {
                                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                   }
                                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnumAttr
 */
class ReadTestClusterEnumAttr : public ModelCommand {
public:
    ReadTestClusterEnumAttr()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000024) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EnumAttr response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EnumAttr Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEnumAttr : public ModelCommand {
public:
    WriteTestClusterEnumAttr()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum-attr");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000024) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeEnumAttrWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster EnumAttr Error: %s", chip::ErrorStr(chipError));
                                   SetCommandExitStatus(chipError);
                               }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterEnumAttr : public ModelCommand {
public:
    SubscribeAttributeTestClusterEnumAttr()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000024) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnumAttrWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.EnumAttr response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StructAttr
 */
class ReadTestClusterStructAttr : public ModelCommand {
public:
    ReadTestClusterStructAttr()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "struct-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterStructAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000025) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStructAttrWithCompletionHandler:^(
            CHIPTestClusterClusterSimpleStruct * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.StructAttr response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster StructAttr Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterStructAttr : public ModelCommand {
public:
    WriteTestClusterStructAttr()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "struct-attr");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterStructAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000025) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        CHIPTestClusterClusterSimpleStruct * _Nonnull value;
        value = [CHIPTestClusterClusterSimpleStruct new];
        value.a = [NSNumber numberWithUnsignedChar:mValue.a];
        value.b = [NSNumber numberWithBool:mValue.b];
        value.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(mValue.c)];
        value.d = [NSData dataWithBytes:mValue.d.data() length:mValue.d.size()];
        value.e = [[NSString alloc] initWithBytes:mValue.e.data() length:mValue.e.size() encoding:NSUTF8StringEncoding];
        value.f = [NSNumber numberWithUnsignedChar:mValue.f.Raw()];
        value.g = [NSNumber numberWithFloat:mValue.g];
        value.h = [NSNumber numberWithDouble:mValue.h];

        [cluster writeAttributeStructAttrWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TestCluster StructAttr Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type mValue;
    TypedComplexArgument<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type> mComplex;
};

class SubscribeAttributeTestClusterStructAttr : public ModelCommand {
public:
    SubscribeAttributeTestClusterStructAttr()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "struct-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterStructAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000025) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStructAttrWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(CHIPTestClusterClusterSimpleStruct * _Nullable value,
                                                   NSError * _Nullable error) {
                                                   NSLog(@"TestCluster.StructAttr response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt8u
 */
class ReadTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000026) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000026) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeRangeRestrictedInt8uWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "TestCluster RangeRestrictedInt8u Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterRangeRestrictedInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000026) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRangeRestrictedInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.RangeRestrictedInt8u response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt8s
 */
class ReadTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000027) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt8s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000027) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];

        [cluster writeAttributeRangeRestrictedInt8sWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "TestCluster RangeRestrictedInt8s Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    SubscribeAttributeTestClusterRangeRestrictedInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000027) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRangeRestrictedInt8sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.RangeRestrictedInt8s response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt16u
 */
class ReadTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000028) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt16u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000028) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeRangeRestrictedInt16uWithValue:value
                                            completionHandler:^(NSError * _Nullable error) {
                                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                                ChipLogError(chipTool, "TestCluster RangeRestrictedInt16u Error: %s",
                                                    chip::ErrorStr(chipError));
                                                SetCommandExitStatus(chipError);
                                            }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    SubscribeAttributeTestClusterRangeRestrictedInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000028) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRangeRestrictedInt16uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TestCluster.RangeRestrictedInt16u response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt16s
 */
class ReadTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000029) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt16s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000029) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeRangeRestrictedInt16sWithValue:value
                                            completionHandler:^(NSError * _Nullable error) {
                                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                                ChipLogError(chipTool, "TestCluster RangeRestrictedInt16s Error: %s",
                                                    chip::ErrorStr(chipError));
                                                SetCommandExitStatus(chipError);
                                            }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    SubscribeAttributeTestClusterRangeRestrictedInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000029) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRangeRestrictedInt16sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TestCluster.RangeRestrictedInt16s response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListLongOctetString
 */
class ReadTestClusterListLongOctetString : public ModelCommand {
public:
    ReadTestClusterListLongOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000002A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListLongOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListLongOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListLongOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterListLongOctetString : public ModelCommand {
public:
    WriteTestClusterListLongOctetString()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "list-long-octet-string");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterListLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000002A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                NSData * newElement_0;
                newElement_0 = [NSData dataWithBytes:entry_0.data() length:entry_0.size()];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeListLongOctetStringWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(
                                                  chipTool, "TestCluster ListLongOctetString Error: %s", chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::ByteSpan> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const chip::ByteSpan>> mComplex;
};

class SubscribeAttributeTestClusterListLongOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterListLongOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-long-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000002A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeListLongOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.ListLongOctetString response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListFabricScoped
 */
class ReadTestClusterListFabricScoped : public ModelCommand {
public:
    ReadTestClusterListFabricScoped()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-fabric-scoped");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListFabricScoped() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000002B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeListFabricScopedWithParams:params
                                       completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                           NSLog(@"TestCluster.ListFabricScoped response %@", [value description]);
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogError(chipTool, "TestCluster ListFabricScoped Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }
};

class WriteTestClusterListFabricScoped : public ModelCommand {
public:
    WriteTestClusterListFabricScoped()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "list-fabric-scoped");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterListFabricScoped() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000002B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPTestClusterClusterTestFabricScoped * newElement_0;
                newElement_0 = [CHIPTestClusterClusterTestFabricScoped new];
                newElement_0.fabricSensitiveInt8u = [NSNumber numberWithUnsignedChar:entry_0.fabricSensitiveInt8u];
                if (entry_0.optionalFabricSensitiveInt8u.HasValue()) {
                    newElement_0.optionalFabricSensitiveInt8u =
                        [NSNumber numberWithUnsignedChar:entry_0.optionalFabricSensitiveInt8u.Value()];
                } else {
                    newElement_0.optionalFabricSensitiveInt8u = nil;
                }
                if (entry_0.nullableFabricSensitiveInt8u.IsNull()) {
                    newElement_0.nullableFabricSensitiveInt8u = nil;
                } else {
                    newElement_0.nullableFabricSensitiveInt8u =
                        [NSNumber numberWithUnsignedChar:entry_0.nullableFabricSensitiveInt8u.Value()];
                }
                if (entry_0.nullableOptionalFabricSensitiveInt8u.HasValue()) {
                    if (entry_0.nullableOptionalFabricSensitiveInt8u.Value().IsNull()) {
                        newElement_0.nullableOptionalFabricSensitiveInt8u = nil;
                    } else {
                        newElement_0.nullableOptionalFabricSensitiveInt8u =
                            [NSNumber numberWithUnsignedChar:entry_0.nullableOptionalFabricSensitiveInt8u.Value().Value()];
                    }
                } else {
                    newElement_0.nullableOptionalFabricSensitiveInt8u = nil;
                }
                newElement_0.fabricSensitiveCharString = [[NSString alloc] initWithBytes:entry_0.fabricSensitiveCharString.data()
                                                                                  length:entry_0.fabricSensitiveCharString.size()
                                                                                encoding:NSUTF8StringEncoding];
                newElement_0.fabricSensitiveStruct = [CHIPTestClusterClusterSimpleStruct new];
                newElement_0.fabricSensitiveStruct.a = [NSNumber numberWithUnsignedChar:entry_0.fabricSensitiveStruct.a];
                newElement_0.fabricSensitiveStruct.b = [NSNumber numberWithBool:entry_0.fabricSensitiveStruct.b];
                newElement_0.fabricSensitiveStruct.c =
                    [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.fabricSensitiveStruct.c)];
                newElement_0.fabricSensitiveStruct.d = [NSData dataWithBytes:entry_0.fabricSensitiveStruct.d.data()
                                                                      length:entry_0.fabricSensitiveStruct.d.size()];
                newElement_0.fabricSensitiveStruct.e = [[NSString alloc] initWithBytes:entry_0.fabricSensitiveStruct.e.data()
                                                                                length:entry_0.fabricSensitiveStruct.e.size()
                                                                              encoding:NSUTF8StringEncoding];
                newElement_0.fabricSensitiveStruct.f = [NSNumber numberWithUnsignedChar:entry_0.fabricSensitiveStruct.f.Raw()];
                newElement_0.fabricSensitiveStruct.g = [NSNumber numberWithFloat:entry_0.fabricSensitiveStruct.g];
                newElement_0.fabricSensitiveStruct.h = [NSNumber numberWithDouble:entry_0.fabricSensitiveStruct.h];
                { // Scope for our temporary variables
                    auto * array_2 = [NSMutableArray new];
                    for (auto & entry_2 : entry_0.fabricSensitiveInt8uList) {
                        NSNumber * newElement_2;
                        newElement_2 = [NSNumber numberWithUnsignedChar:entry_2];
                        [array_2 addObject:newElement_2];
                    }
                    newElement_0.fabricSensitiveInt8uList = array_2;
                }
                newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster
            writeAttributeListFabricScopedWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster ListFabricScoped Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestFabricScoped::Type> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestFabricScoped::Type>>
        mComplex;
};

class SubscribeAttributeTestClusterListFabricScoped : public ModelCommand {
public:
    SubscribeAttributeTestClusterListFabricScoped()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-fabric-scoped");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListFabricScoped() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000002B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeListFabricScopedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.ListFabricScoped response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TimedWriteBoolean
 */
class ReadTestClusterTimedWriteBoolean : public ModelCommand {
public:
    ReadTestClusterTimedWriteBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "timed-write-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000030) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTimedWriteBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.TimedWriteBoolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster TimedWriteBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterTimedWriteBoolean : public ModelCommand {
public:
    WriteTestClusterTimedWriteBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "timed-write-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000030) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster
            writeAttributeTimedWriteBooleanWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "TestCluster TimedWriteBoolean Error: %s", chip::ErrorStr(chipError));
                                       SetCommandExitStatus(chipError);
                                   }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterTimedWriteBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterTimedWriteBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "timed-write-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000030) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTimedWriteBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"TestCluster.TimedWriteBoolean response %@", [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneralErrorBoolean
 */
class ReadTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    ReadTestClusterGeneralErrorBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "general-error-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000031) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneralErrorBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.GeneralErrorBoolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster GeneralErrorBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    WriteTestClusterGeneralErrorBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "general-error-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000031) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeGeneralErrorBooleanWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(
                                                  chipTool, "TestCluster GeneralErrorBoolean Error: %s", chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterGeneralErrorBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "general-error-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000031) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneralErrorBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.GeneralErrorBoolean response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterErrorBoolean
 */
class ReadTestClusterClusterErrorBoolean : public ModelCommand {
public:
    ReadTestClusterClusterErrorBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000032) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterErrorBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ClusterErrorBoolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ClusterErrorBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterClusterErrorBoolean : public ModelCommand {
public:
    WriteTestClusterClusterErrorBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000032) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeClusterErrorBooleanWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(
                                                  chipTool, "TestCluster ClusterErrorBoolean Error: %s", chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterClusterErrorBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterClusterErrorBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000032) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterErrorBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.ClusterErrorBoolean response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Unsupported
 */
class ReadTestClusterUnsupported : public ModelCommand {
public:
    ReadTestClusterUnsupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "unsupported");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x000000FF) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUnsupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Unsupported response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Unsupported Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterUnsupported : public ModelCommand {
public:
    WriteTestClusterUnsupported()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x000000FF) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeUnsupportedWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster Unsupported Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterUnsupported : public ModelCommand {
public:
    SubscribeAttributeTestClusterUnsupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x000000FF) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUnsupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"TestCluster.Unsupported response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBoolean
 */
class ReadTestClusterNullableBoolean : public ModelCommand {
public:
    ReadTestClusterNullableBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBoolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBoolean : public ModelCommand {
public:
    WriteTestClusterNullableBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithBool:mValue];

        [cluster
            writeAttributeNullableBooleanWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TestCluster NullableBoolean Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterNullableBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.NullableBoolean response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap8
 */
class ReadTestClusterNullableBitmap8 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap8 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBitmap8 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeNullableBitmap8WithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TestCluster NullableBitmap8 Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableBitmap8 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBitmap8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBitmap8WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.NullableBitmap8 response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap16
 */
class ReadTestClusterNullableBitmap16 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap16 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBitmap16 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster
            writeAttributeNullableBitmap16WithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster NullableBitmap16 Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterNullableBitmap16 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBitmap16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBitmap16WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.NullableBitmap16 response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap32
 */
class ReadTestClusterNullableBitmap32 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap32()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap32 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap32 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBitmap32 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap32()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster
            writeAttributeNullableBitmap32WithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster NullableBitmap32 Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterNullableBitmap32 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBitmap32()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBitmap32WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.NullableBitmap32 response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap64
 */
class ReadTestClusterNullableBitmap64 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap64()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap64 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap64 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBitmap64 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap64()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster
            writeAttributeNullableBitmap64WithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster NullableBitmap64 Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableBitmap64 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBitmap64()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBitmap64WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.NullableBitmap64 response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8u
 */
class ReadTestClusterNullableInt8u : public ModelCommand {
public:
    ReadTestClusterNullableInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt8u : public ModelCommand {
public:
    WriteTestClusterNullableInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeNullableInt8uWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        chipError = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "TestCluster NullableInt8u Error: %s", chip::ErrorStr(chipError));
                                        SetCommandExitStatus(chipError);
                                    }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.NullableInt8u response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16u
 */
class ReadTestClusterNullableInt16u : public ModelCommand {
public:
    ReadTestClusterNullableInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt16u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt16u : public ModelCommand {
public:
    WriteTestClusterNullableInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeNullableInt16uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt16u Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterNullableInt16u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt16uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt16u response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt24u
 */
class ReadTestClusterNullableInt24u : public ModelCommand {
public:
    ReadTestClusterNullableInt24u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int24u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt24uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt24u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt24u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt24u : public ModelCommand {
public:
    WriteTestClusterNullableInt24u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int24u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeNullableInt24uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt24u Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterNullableInt24u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt24u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int24u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt24uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt24u response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32u
 */
class ReadTestClusterNullableInt32u : public ModelCommand {
public:
    ReadTestClusterNullableInt32u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt32u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt32u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt32u : public ModelCommand {
public:
    WriteTestClusterNullableInt32u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeNullableInt32uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt32u Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterNullableInt32u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt32u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt32uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt32u response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt40u
 */
class ReadTestClusterNullableInt40u : public ModelCommand {
public:
    ReadTestClusterNullableInt40u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int40u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt40uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt40u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt40u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt40u : public ModelCommand {
public:
    WriteTestClusterNullableInt40u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int40u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableInt40uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt40u Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt40u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt40u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int40u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt40uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt40u response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt48u
 */
class ReadTestClusterNullableInt48u : public ModelCommand {
public:
    ReadTestClusterNullableInt48u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int48u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000400A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt48uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt48u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt48u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt48u : public ModelCommand {
public:
    WriteTestClusterNullableInt48u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int48u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000400A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableInt48uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt48u Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt48u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt48u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int48u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000400A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt48uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt48u response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt56u
 */
class ReadTestClusterNullableInt56u : public ModelCommand {
public:
    ReadTestClusterNullableInt56u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int56u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000400B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt56uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt56u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt56u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt56u : public ModelCommand {
public:
    WriteTestClusterNullableInt56u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int56u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000400B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableInt56uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt56u Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt56u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt56u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int56u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000400B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt56uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt56u response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64u
 */
class ReadTestClusterNullableInt64u : public ModelCommand {
public:
    ReadTestClusterNullableInt64u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000400C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt64u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt64u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt64u : public ModelCommand {
public:
    WriteTestClusterNullableInt64u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000400C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableInt64uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt64u Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt64u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt64u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000400C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt64uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt64u response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8s
 */
class ReadTestClusterNullableInt8s : public ModelCommand {
public:
    ReadTestClusterNullableInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000400D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt8s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt8s : public ModelCommand {
public:
    WriteTestClusterNullableInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000400D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithChar:mValue];

        [cluster writeAttributeNullableInt8sWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        chipError = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "TestCluster NullableInt8s Error: %s", chip::ErrorStr(chipError));
                                        SetCommandExitStatus(chipError);
                                    }];
        return chipError;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeTestClusterNullableInt8s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000400D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt8sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.NullableInt8s response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16s
 */
class ReadTestClusterNullableInt16s : public ModelCommand {
public:
    ReadTestClusterNullableInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000400E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt16s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt16s : public ModelCommand {
public:
    WriteTestClusterNullableInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000400E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeNullableInt16sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt16s Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeTestClusterNullableInt16s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000400E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt16sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt16s response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt24s
 */
class ReadTestClusterNullableInt24s : public ModelCommand {
public:
    ReadTestClusterNullableInt24s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int24s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000400F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt24sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt24s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt24s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt24s : public ModelCommand {
public:
    WriteTestClusterNullableInt24s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int24s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000400F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithInt:mValue];

        [cluster writeAttributeNullableInt24sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt24s Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    int32_t mValue;
};

class SubscribeAttributeTestClusterNullableInt24s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt24s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int24s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000400F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt24sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt24s response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32s
 */
class ReadTestClusterNullableInt32s : public ModelCommand {
public:
    ReadTestClusterNullableInt32s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt32s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt32s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt32s : public ModelCommand {
public:
    WriteTestClusterNullableInt32s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithInt:mValue];

        [cluster writeAttributeNullableInt32sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt32s Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    int32_t mValue;
};

class SubscribeAttributeTestClusterNullableInt32s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt32s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt32sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt32s response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt40s
 */
class ReadTestClusterNullableInt40s : public ModelCommand {
public:
    ReadTestClusterNullableInt40s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int40s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt40sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt40s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt40s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt40s : public ModelCommand {
public:
    WriteTestClusterNullableInt40s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int40s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeNullableInt40sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt40s Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt40s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt40s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int40s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt40sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt40s response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt48s
 */
class ReadTestClusterNullableInt48s : public ModelCommand {
public:
    ReadTestClusterNullableInt48s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int48s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt48sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt48s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt48s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt48s : public ModelCommand {
public:
    WriteTestClusterNullableInt48s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int48s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeNullableInt48sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt48s Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt48s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt48s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int48s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt48sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt48s response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt56s
 */
class ReadTestClusterNullableInt56s : public ModelCommand {
public:
    ReadTestClusterNullableInt56s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int56s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt56sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt56s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt56s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt56s : public ModelCommand {
public:
    WriteTestClusterNullableInt56s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int56s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeNullableInt56sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt56s Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt56s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt56s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int56s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt56sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt56s response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64s
 */
class ReadTestClusterNullableInt64s : public ModelCommand {
public:
    ReadTestClusterNullableInt64s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004014) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt64s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt64s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt64s : public ModelCommand {
public:
    WriteTestClusterNullableInt64s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeNullableInt64sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt64s Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt64s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt64s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt64sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt64s response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum8
 */
class ReadTestClusterNullableEnum8 : public ModelCommand {
public:
    ReadTestClusterNullableEnum8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004015) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnum8 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnum8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableEnum8 : public ModelCommand {
public:
    WriteTestClusterNullableEnum8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeNullableEnum8WithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        chipError = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "TestCluster NullableEnum8 Error: %s", chip::ErrorStr(chipError));
                                        SetCommandExitStatus(chipError);
                                    }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableEnum8 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableEnum8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableEnum8WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.NullableEnum8 response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum16
 */
class ReadTestClusterNullableEnum16 : public ModelCommand {
public:
    ReadTestClusterNullableEnum16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004016) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnum16 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnum16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableEnum16 : public ModelCommand {
public:
    WriteTestClusterNullableEnum16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeNullableEnum16WithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableEnum16 Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterNullableEnum16 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableEnum16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableEnum16WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableEnum16 response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableFloatSingle
 */
class ReadTestClusterNullableFloatSingle : public ModelCommand {
public:
    ReadTestClusterNullableFloatSingle()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-float-single");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004017) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableFloatSingle response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableFloatSingle Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableFloatSingle : public ModelCommand {
public:
    WriteTestClusterNullableFloatSingle()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-float-single");
        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithFloat:mValue];

        [cluster writeAttributeNullableFloatSingleWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(
                                                  chipTool, "TestCluster NullableFloatSingle Error: %s", chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    float mValue;
};

class SubscribeAttributeTestClusterNullableFloatSingle : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableFloatSingle()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-float-single");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableFloatSingleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableFloatSingle response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableFloatDouble
 */
class ReadTestClusterNullableFloatDouble : public ModelCommand {
public:
    ReadTestClusterNullableFloatDouble()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-float-double");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004018) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableFloatDouble response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableFloatDouble Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableFloatDouble : public ModelCommand {
public:
    WriteTestClusterNullableFloatDouble()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-float-double");
        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004018) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithDouble:mValue];

        [cluster writeAttributeNullableFloatDoubleWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(
                                                  chipTool, "TestCluster NullableFloatDouble Error: %s", chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    double mValue;
};

class SubscribeAttributeTestClusterNullableFloatDouble : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableFloatDouble()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-float-double");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004018) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableFloatDoubleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableFloatDouble response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableOctetString
 */
class ReadTestClusterNullableOctetString : public ModelCommand {
public:
    ReadTestClusterNullableOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004019) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableOctetString : public ModelCommand {
public:
    WriteTestClusterNullableOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSData * _Nullable value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];

        [cluster writeAttributeNullableOctetStringWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(
                                                  chipTool, "TestCluster NullableOctetString Error: %s", chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterNullableOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableOctetString response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableCharString
 */
class ReadTestClusterNullableCharString : public ModelCommand {
public:
    ReadTestClusterNullableCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000401E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableCharString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableCharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableCharString : public ModelCommand {
public:
    WriteTestClusterNullableCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000401E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSString * _Nullable value = [[NSString alloc] initWithBytes:mValue.data()
                                                              length:mValue.size()
                                                            encoding:NSUTF8StringEncoding];

        [cluster writeAttributeNullableCharStringWithValue:value
                                         completionHandler:^(NSError * _Nullable error) {
                                             chipError = [CHIPError errorToCHIPErrorCode:error];
                                             ChipLogError(
                                                 chipTool, "TestCluster NullableCharString Error: %s", chip::ErrorStr(chipError));
                                             SetCommandExitStatus(chipError);
                                         }];
        return chipError;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterNullableCharString : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000401E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableCharStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.NullableCharString response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnumAttr
 */
class ReadTestClusterNullableEnumAttr : public ModelCommand {
public:
    ReadTestClusterNullableEnumAttr()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004024) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnumAttr response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnumAttr Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableEnumAttr : public ModelCommand {
public:
    WriteTestClusterNullableEnumAttr()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004024) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeNullableEnumAttrWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      chipError = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster NullableEnumAttr Error: %s", chip::ErrorStr(chipError));
                                      SetCommandExitStatus(chipError);
                                  }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableEnumAttr : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableEnumAttr()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004024) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableEnumAttrWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.NullableEnumAttr response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableStruct
 */
class ReadTestClusterNullableStruct : public ModelCommand {
public:
    ReadTestClusterNullableStruct()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-struct");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004025) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableStructWithCompletionHandler:^(
            CHIPTestClusterClusterSimpleStruct * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableStruct response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableStruct Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableStruct : public ModelCommand {
public:
    WriteTestClusterNullableStruct()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "nullable-struct");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004025) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        CHIPTestClusterClusterSimpleStruct * _Nullable value;
        if (mValue.IsNull()) {
            value = nil;
        } else {
            value = [CHIPTestClusterClusterSimpleStruct new];
            value.a = [NSNumber numberWithUnsignedChar:mValue.Value().a];
            value.b = [NSNumber numberWithBool:mValue.Value().b];
            value.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(mValue.Value().c)];
            value.d = [NSData dataWithBytes:mValue.Value().d.data() length:mValue.Value().d.size()];
            value.e = [[NSString alloc] initWithBytes:mValue.Value().e.data()
                                               length:mValue.Value().e.size()
                                             encoding:NSUTF8StringEncoding];
            value.f = [NSNumber numberWithUnsignedChar:mValue.Value().f.Raw()];
            value.g = [NSNumber numberWithFloat:mValue.Value().g];
            value.h = [NSNumber numberWithDouble:mValue.Value().h];
        }

        [cluster writeAttributeNullableStructWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         chipError = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableStruct Error: %s", chip::ErrorStr(chipError));
                                         SetCommandExitStatus(chipError);
                                     }];
        return chipError;
    }

private:
    chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type> mValue;
    TypedComplexArgument<chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>> mComplex;
};

class SubscribeAttributeTestClusterNullableStruct : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableStruct()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-struct");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004025) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableStructWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(CHIPTestClusterClusterSimpleStruct * _Nullable value,
                                                       NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableStruct response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt8u
 */
class ReadTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004026) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004026) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:value
                                                   completionHandler:^(NSError * _Nullable error) {
                                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                                       ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8u Error: %s",
                                                           chip::ErrorStr(chipError));
                                                       SetCommandExitStatus(chipError);
                                                   }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004026) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableRangeRestrictedInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"TestCluster.NullableRangeRestrictedInt8u response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt8s
 */
class ReadTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004027) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt8s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004027) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithChar:mValue];

        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:value
                                                   completionHandler:^(NSError * _Nullable error) {
                                                       chipError = [CHIPError errorToCHIPErrorCode:error];
                                                       ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8s Error: %s",
                                                           chip::ErrorStr(chipError));
                                                       SetCommandExitStatus(chipError);
                                                   }];
        return chipError;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004027) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableRangeRestrictedInt8sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"TestCluster.NullableRangeRestrictedInt8s response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt16u
 */
class ReadTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004028) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt16u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004028) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster
            writeAttributeNullableRangeRestrictedInt16uWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                                   ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16u Error: %s",
                                                       chip::ErrorStr(chipError));
                                                   SetCommandExitStatus(chipError);
                                               }];
        return chipError;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004028) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableRangeRestrictedInt16uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"TestCluster.NullableRangeRestrictedInt16u response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt16s
 */
class ReadTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00004029) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt16s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00004029) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithShort:mValue];

        [cluster
            writeAttributeNullableRangeRestrictedInt16sWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   chipError = [CHIPError errorToCHIPErrorCode:error];
                                                   ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16s Error: %s",
                                                       chip::ErrorStr(chipError));
                                                   SetCommandExitStatus(chipError);
                                               }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00004029) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableRangeRestrictedInt16sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"TestCluster.NullableRangeRestrictedInt16s response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadTestClusterGeneratedCommandList : public ModelCommand {
public:
    ReadTestClusterGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTestClusterGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadTestClusterAcceptedCommandList : public ModelCommand {
public:
    ReadTestClusterAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeTestClusterAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTestClusterAttributeList : public ModelCommand {
public:
    ReadTestClusterAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterAttributeList : public ModelCommand {
public:
    SubscribeAttributeTestClusterAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTestClusterClusterRevision : public ModelCommand {
public:
    ReadTestClusterClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterClusterRevision : public ModelCommand {
public:
    SubscribeAttributeTestClusterClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Thermostat                                                  | 0x0201 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SetpointRaiseLower                                                |   0x00 |
| * SetWeeklySchedule                                                 |   0x01 |
| * GetWeeklySchedule                                                 |   0x02 |
| * ClearWeeklySchedule                                               |   0x03 |
| * GetRelayStatusLog                                                 |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LocalTemperature                                                  | 0x0000 |
| * OutdoorTemperature                                                | 0x0001 |
| * Occupancy                                                         | 0x0002 |
| * AbsMinHeatSetpointLimit                                           | 0x0003 |
| * AbsMaxHeatSetpointLimit                                           | 0x0004 |
| * AbsMinCoolSetpointLimit                                           | 0x0005 |
| * AbsMaxCoolSetpointLimit                                           | 0x0006 |
| * PiCoolingDemand                                                   | 0x0007 |
| * PiHeatingDemand                                                   | 0x0008 |
| * HvacSystemTypeConfiguration                                       | 0x0009 |
| * LocalTemperatureCalibration                                       | 0x0010 |
| * OccupiedCoolingSetpoint                                           | 0x0011 |
| * OccupiedHeatingSetpoint                                           | 0x0012 |
| * UnoccupiedCoolingSetpoint                                         | 0x0013 |
| * UnoccupiedHeatingSetpoint                                         | 0x0014 |
| * MinHeatSetpointLimit                                              | 0x0015 |
| * MaxHeatSetpointLimit                                              | 0x0016 |
| * MinCoolSetpointLimit                                              | 0x0017 |
| * MaxCoolSetpointLimit                                              | 0x0018 |
| * MinSetpointDeadBand                                               | 0x0019 |
| * RemoteSensing                                                     | 0x001A |
| * ControlSequenceOfOperation                                        | 0x001B |
| * SystemMode                                                        | 0x001C |
| * AlarmMask                                                         | 0x001D |
| * ThermostatRunningMode                                             | 0x001E |
| * StartOfWeek                                                       | 0x0020 |
| * NumberOfWeeklyTransitions                                         | 0x0021 |
| * NumberOfDailyTransitions                                          | 0x0022 |
| * TemperatureSetpointHold                                           | 0x0023 |
| * TemperatureSetpointHoldDuration                                   | 0x0024 |
| * ThermostatProgrammingOperationMode                                | 0x0025 |
| * ThermostatRunningState                                            | 0x0029 |
| * SetpointChangeSource                                              | 0x0030 |
| * SetpointChangeAmount                                              | 0x0031 |
| * SetpointChangeSourceTimestamp                                     | 0x0032 |
| * AcType                                                            | 0x0040 |
| * AcCapacity                                                        | 0x0041 |
| * AcRefrigerantType                                                 | 0x0042 |
| * AcCompressorType                                                  | 0x0043 |
| * AcErrorCode                                                       | 0x0044 |
| * AcLouverPosition                                                  | 0x0045 |
| * AcCoilTemperature                                                 | 0x0046 |
| * AcCapacityFormat                                                  | 0x0047 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearWeeklySchedule
 */
class ThermostatClearWeeklySchedule : public ModelCommand {
public:
    ThermostatClearWeeklySchedule()
        : ModelCommand("clear-weekly-schedule")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster clearWeeklyScheduleWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command GetRelayStatusLog
 */
class ThermostatGetRelayStatusLog : public ModelCommand {
public:
    ThermostatGetRelayStatusLog()
        : ModelCommand("get-relay-status-log")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster getRelayStatusLogWithCompletionHandler:^(
            CHIPThermostatClusterGetRelayStatusLogResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command GetWeeklySchedule
 */
class ThermostatGetWeeklySchedule : public ModelCommand {
public:
    ThermostatGetWeeklySchedule()
        : ModelCommand("get-weekly-schedule")
    {
        AddArgument("DaysToReturn", 0, UINT8_MAX, &mDaysToReturn);
        AddArgument("ModeToReturn", 0, UINT8_MAX, &mModeToReturn);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPThermostatClusterGetWeeklyScheduleParams alloc] init];

        params.daysToReturn = [NSNumber numberWithUnsignedChar:mDaysToReturn];

        params.modeToReturn = [NSNumber numberWithUnsignedChar:mModeToReturn];
        [cluster getWeeklyScheduleWithParams:params
                           completionHandler:^(
                               CHIPThermostatClusterGetWeeklyScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                               NSLog(@"Values: %@", values);
                               chipError = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                               SetCommandExitStatus(chipError);
                           }];
        return chipError;
    }

private:
    uint8_t mDaysToReturn;
    uint8_t mModeToReturn;
};

/*
 * Command SetWeeklySchedule
 */
class ThermostatSetWeeklySchedule : public ModelCommand {
public:
    ThermostatSetWeeklySchedule()
        : ModelCommand("set-weekly-schedule")
        , mComplex_Payload(&mRequest.payload)
    {
        AddArgument("NumberOfTransitionsForSequence", 0, UINT8_MAX, &mNumberOfTransitionsForSequence);
        AddArgument("DayOfWeekForSequence", 0, UINT8_MAX, &mDayOfWeekForSequence);
        AddArgument("ModeForSequence", 0, UINT8_MAX, &mModeForSequence);
        AddArgument("Payload", &mComplex_Payload);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPThermostatClusterSetWeeklyScheduleParams alloc] init];

        params.numberOfTransitionsForSequence = [NSNumber numberWithUnsignedChar:mNumberOfTransitionsForSequence];

        params.dayOfWeekForSequence = [NSNumber numberWithUnsignedChar:mDayOfWeekForSequence];

        params.modeForSequence = [NSNumber numberWithUnsignedChar:mModeForSequence];

        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mRequest.payload) {
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
                [array_0 addObject:newElement_0];
            }
            params.payload = array_0;
        }
        [cluster setWeeklyScheduleWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               chipError = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                               SetCommandExitStatus(chipError);
                           }];
        return chipError;
    }

private:
    uint8_t mNumberOfTransitionsForSequence;
    uint8_t mDayOfWeekForSequence;
    uint8_t mModeForSequence;
    chip::app::Clusters::Thermostat::Commands::SetWeeklySchedule::Type mRequest;
    TypedComplexArgument<chip::app::DataModel::List<const uint8_t>> mComplex_Payload;
};

/*
 * Command SetpointRaiseLower
 */
class ThermostatSetpointRaiseLower : public ModelCommand {
public:
    ThermostatSetpointRaiseLower()
        : ModelCommand("setpoint-raise-lower")
    {
        AddArgument("Mode", 0, UINT8_MAX, &mMode);
        AddArgument("Amount", INT8_MIN, INT8_MAX, &mAmount);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPThermostatClusterSetpointRaiseLowerParams alloc] init];

        params.mode = [NSNumber numberWithUnsignedChar:mMode];

        params.amount = [NSNumber numberWithChar:mAmount];
        [cluster setpointRaiseLowerWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mMode;
    int8_t mAmount;
};

/*
 * Attribute LocalTemperature
 */
class ReadThermostatLocalTemperature : public ModelCommand {
public:
    ReadThermostatLocalTemperature()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "local-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatLocalTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLocalTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.LocalTemperature response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat LocalTemperature Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatLocalTemperature : public ModelCommand {
public:
    SubscribeAttributeThermostatLocalTemperature()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "local-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatLocalTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLocalTemperatureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"Thermostat.LocalTemperature response %@", [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinHeatSetpointLimit
 */
class ReadThermostatAbsMinHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMinHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeAbsMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMinHeatSetpointLimit response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMinHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatAbsMinHeatSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatAbsMinHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAbsMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAbsMinHeatSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.AbsMinHeatSetpointLimit response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxHeatSetpointLimit
 */
class ReadThermostatAbsMaxHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMaxHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeAbsMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMaxHeatSetpointLimit response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMaxHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatAbsMaxHeatSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatAbsMaxHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAbsMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAbsMaxHeatSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.AbsMaxHeatSetpointLimit response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinCoolSetpointLimit
 */
class ReadThermostatAbsMinCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMinCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeAbsMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMinCoolSetpointLimit response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMinCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatAbsMinCoolSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatAbsMinCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAbsMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAbsMinCoolSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.AbsMinCoolSetpointLimit response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxCoolSetpointLimit
 */
class ReadThermostatAbsMaxCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMaxCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeAbsMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMaxCoolSetpointLimit response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMaxCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatAbsMaxCoolSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatAbsMaxCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAbsMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAbsMaxCoolSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.AbsMaxCoolSetpointLimit response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedCoolingSetpoint
 */
class ReadThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    ReadThermostatOccupiedCoolingSetpoint()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeOccupiedCoolingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.OccupiedCoolingSetpoint response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat OccupiedCoolingSetpoint Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    WriteThermostatOccupiedCoolingSetpoint()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeOccupiedCoolingSetpointWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                                  ChipLogError(chipTool, "Thermostat OccupiedCoolingSetpoint Error: %s",
                                                      chip::ErrorStr(chipError));
                                                  SetCommandExitStatus(chipError);
                                              }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    SubscribeAttributeThermostatOccupiedCoolingSetpoint()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOccupiedCoolingSetpointWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.OccupiedCoolingSetpoint response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedHeatingSetpoint
 */
class ReadThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    ReadThermostatOccupiedHeatingSetpoint()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeOccupiedHeatingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.OccupiedHeatingSetpoint response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat OccupiedHeatingSetpoint Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    WriteThermostatOccupiedHeatingSetpoint()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeOccupiedHeatingSetpointWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  chipError = [CHIPError errorToCHIPErrorCode:error];
                                                  ChipLogError(chipTool, "Thermostat OccupiedHeatingSetpoint Error: %s",
                                                      chip::ErrorStr(chipError));
                                                  SetCommandExitStatus(chipError);
                                              }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    SubscribeAttributeThermostatOccupiedHeatingSetpoint()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOccupiedHeatingSetpointWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.OccupiedHeatingSetpoint response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinHeatSetpointLimit
 */
class ReadThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatMinHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000015) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinHeatSetpointLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinHeatSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    WriteThermostatMinHeatSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeMinHeatSetpointLimitWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "Thermostat MinHeatSetpointLimit Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatMinHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinHeatSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.MinHeatSetpointLimit response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxHeatSetpointLimit
 */
class ReadThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatMaxHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000016) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MaxHeatSetpointLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MaxHeatSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    WriteThermostatMaxHeatSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeMaxHeatSetpointLimitWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "Thermostat MaxHeatSetpointLimit Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatMaxHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxHeatSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.MaxHeatSetpointLimit response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCoolSetpointLimit
 */
class ReadThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatMinCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000017) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinCoolSetpointLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinCoolSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    WriteThermostatMinCoolSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeMinCoolSetpointLimitWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "Thermostat MinCoolSetpointLimit Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatMinCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinCoolSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.MinCoolSetpointLimit response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCoolSetpointLimit
 */
class ReadThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatMaxCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000018) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MaxCoolSetpointLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MaxCoolSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    WriteThermostatMaxCoolSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000018) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeMaxCoolSetpointLimitWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               chipError = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "Thermostat MaxCoolSetpointLimit Error: %s",
                                                   chip::ErrorStr(chipError));
                                               SetCommandExitStatus(chipError);
                                           }];
        return chipError;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatMaxCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000018) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxCoolSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.MaxCoolSetpointLimit response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinSetpointDeadBand
 */
class ReadThermostatMinSetpointDeadBand : public ModelCommand {
public:
    ReadThermostatMinSetpointDeadBand()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000019) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinSetpointDeadBandWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinSetpointDeadBand response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinSetpointDeadBand Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMinSetpointDeadBand : public ModelCommand {
public:
    WriteThermostatMinSetpointDeadBand()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];

        [cluster writeAttributeMinSetpointDeadBandWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              chipError = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(
                                                  chipTool, "Thermostat MinSetpointDeadBand Error: %s", chip::ErrorStr(chipError));
                                              SetCommandExitStatus(chipError);
                                          }];
        return chipError;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeThermostatMinSetpointDeadBand : public ModelCommand {
public:
    SubscribeAttributeThermostatMinSetpointDeadBand()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinSetpointDeadBandWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"Thermostat.MinSetpointDeadBand response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlSequenceOfOperation
 */
class ReadThermostatControlSequenceOfOperation : public ModelCommand {
public:
    ReadThermostatControlSequenceOfOperation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000001B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeControlSequenceOfOperationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.ControlSequenceOfOperation response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat ControlSequenceOfOperation Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteThermostatControlSequenceOfOperation : public ModelCommand {
public:
    WriteThermostatControlSequenceOfOperation()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x0000001B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeControlSequenceOfOperationWithValue:value
                                                 completionHandler:^(NSError * _Nullable error) {
                                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                                     ChipLogError(chipTool, "Thermostat ControlSequenceOfOperation Error: %s",
                                                         chip::ErrorStr(chipError));
                                                     SetCommandExitStatus(chipError);
                                                 }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatControlSequenceOfOperation : public ModelCommand {
public:
    SubscribeAttributeThermostatControlSequenceOfOperation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000001B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeControlSequenceOfOperationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Thermostat.ControlSequenceOfOperation response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SystemMode
 */
class ReadThermostatSystemMode : public ModelCommand {
public:
    ReadThermostatSystemMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "system-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000001C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSystemModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.SystemMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat SystemMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatSystemMode : public ModelCommand {
public:
    WriteThermostatSystemMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x0000001C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeSystemModeWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     chipError = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "Thermostat SystemMode Error: %s", chip::ErrorStr(chipError));
                                     SetCommandExitStatus(chipError);
                                 }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatSystemMode : public ModelCommand {
public:
    SubscribeAttributeThermostatSystemMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000001C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSystemModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Thermostat.SystemMode response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartOfWeek
 */
class ReadThermostatStartOfWeek : public ModelCommand {
public:
    ReadThermostatStartOfWeek()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-of-week");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatStartOfWeek() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000020) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartOfWeekWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.StartOfWeek response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat StartOfWeek Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatStartOfWeek : public ModelCommand {
public:
    SubscribeAttributeThermostatStartOfWeek()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-of-week");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatStartOfWeek() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000020) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStartOfWeekWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Thermostat.StartOfWeek response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfWeeklyTransitions
 */
class ReadThermostatNumberOfWeeklyTransitions : public ModelCommand {
public:
    ReadThermostatNumberOfWeeklyTransitions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfWeeklyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000021) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfWeeklyTransitionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.NumberOfWeeklyTransitions response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat NumberOfWeeklyTransitions Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatNumberOfWeeklyTransitions : public ModelCommand {
public:
    SubscribeAttributeThermostatNumberOfWeeklyTransitions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatNumberOfWeeklyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfWeeklyTransitionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"Thermostat.NumberOfWeeklyTransitions response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfDailyTransitions
 */
class ReadThermostatNumberOfDailyTransitions : public ModelCommand {
public:
    ReadThermostatNumberOfDailyTransitions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfDailyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000022) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfDailyTransitionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.NumberOfDailyTransitions response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat NumberOfDailyTransitions Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatNumberOfDailyTransitions : public ModelCommand {
public:
    SubscribeAttributeThermostatNumberOfDailyTransitions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatNumberOfDailyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000022) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfDailyTransitionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Thermostat.NumberOfDailyTransitions response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThermostatAttributeList : public ModelCommand {
public:
    ReadThermostatAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatAttributeList : public ModelCommand {
public:
    SubscribeAttributeThermostatAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Thermostat.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadThermostatFeatureMap : public ModelCommand {
public:
    ReadThermostatFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatFeatureMap : public ModelCommand {
public:
    SubscribeAttributeThermostatFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Thermostat.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatClusterRevision : public ModelCommand {
public:
    ReadThermostatClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatClusterRevision : public ModelCommand {
public:
    SubscribeAttributeThermostatClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThermostatUserInterfaceConfiguration                        | 0x0204 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TemperatureDisplayMode                                            | 0x0000 |
| * KeypadLockout                                                     | 0x0001 |
| * ScheduleProgrammingVisibility                                     | 0x0002 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute TemperatureDisplayMode
 */
class ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "temperature-display-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTemperatureDisplayModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.TemperatureDisplayMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration TemperatureDisplayMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeTemperatureDisplayModeWithValue:value
                                             completionHandler:^(NSError * _Nullable error) {
                                                 chipError = [CHIPError errorToCHIPErrorCode:error];
                                                 ChipLogError(chipTool,
                                                     "ThermostatUserInterfaceConfiguration TemperatureDisplayMode Error: %s",
                                                     chip::ErrorStr(chipError));
                                                 SetCommandExitStatus(chipError);
                                             }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTemperatureDisplayModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ThermostatUserInterfaceConfiguration.TemperatureDisplayMode "
                                                                     @"response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute KeypadLockout
 */
class ReadThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "keypad-lockout");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeKeypadLockoutWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.KeypadLockout response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration KeypadLockout Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeKeypadLockoutWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        chipError = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration KeypadLockout Error: %s",
                                            chip::ErrorStr(chipError));
                                        SetCommandExitStatus(chipError);
                                    }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeKeypadLockoutWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ThermostatUserInterfaceConfiguration.KeypadLockout response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ScheduleProgrammingVisibility
 */
class ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeScheduleProgrammingVisibilityWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.ScheduleProgrammingVisibility response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(
                chipTool, "ThermostatUserInterfaceConfiguration ScheduleProgrammingVisibility Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeScheduleProgrammingVisibilityWithValue:value
                                                    completionHandler:^(NSError * _Nullable error) {
                                                        chipError = [CHIPError errorToCHIPErrorCode:error];
                                                        ChipLogError(chipTool,
                                                            "ThermostatUserInterfaceConfiguration ScheduleProgrammingVisibility "
                                                            "Error: %s",
                                                            chip::ErrorStr(chipError));
                                                        SetCommandExitStatus(chipError);
                                                    }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeScheduleProgrammingVisibilityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"ThermostatUserInterfaceConfiguration."
                                                                       @"ScheduleProgrammingVisibility response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadThermostatUserInterfaceConfigurationGeneratedCommandList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatUserInterfaceConfigurationGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ThermostatUserInterfaceConfiguration.GeneratedCommandList "
                                                                   @"response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadThermostatUserInterfaceConfigurationAcceptedCommandList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatUserInterfaceConfigurationAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(
                                                           @"ThermostatUserInterfaceConfiguration.AcceptedCommandList response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThermostatUserInterfaceConfigurationAttributeList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatUserInterfaceConfigurationAttributeList : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ThermostatUserInterfaceConfiguration.AttributeList response %@",
                                                          [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThermostatUserInterfaceConfiguration.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThreadNetworkDiagnostics                                    | 0x0035 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Channel                                                           | 0x0000 |
| * RoutingRole                                                       | 0x0001 |
| * NetworkName                                                       | 0x0002 |
| * PanId                                                             | 0x0003 |
| * ExtendedPanId                                                     | 0x0004 |
| * MeshLocalPrefix                                                   | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * NeighborTableList                                                 | 0x0007 |
| * RouteTableList                                                    | 0x0008 |
| * PartitionId                                                       | 0x0009 |
| * Weighting                                                         | 0x000A |
| * DataVersion                                                       | 0x000B |
| * StableDataVersion                                                 | 0x000C |
| * LeaderRouterId                                                    | 0x000D |
| * DetachedRoleCount                                                 | 0x000E |
| * ChildRoleCount                                                    | 0x000F |
| * RouterRoleCount                                                   | 0x0010 |
| * LeaderRoleCount                                                   | 0x0011 |
| * AttachAttemptCount                                                | 0x0012 |
| * PartitionIdChangeCount                                            | 0x0013 |
| * BetterPartitionAttachAttemptCount                                 | 0x0014 |
| * ParentChangeCount                                                 | 0x0015 |
| * TxTotalCount                                                      | 0x0016 |
| * TxUnicastCount                                                    | 0x0017 |
| * TxBroadcastCount                                                  | 0x0018 |
| * TxAckRequestedCount                                               | 0x0019 |
| * TxAckedCount                                                      | 0x001A |
| * TxNoAckRequestedCount                                             | 0x001B |
| * TxDataCount                                                       | 0x001C |
| * TxDataPollCount                                                   | 0x001D |
| * TxBeaconCount                                                     | 0x001E |
| * TxBeaconRequestCount                                              | 0x001F |
| * TxOtherCount                                                      | 0x0020 |
| * TxRetryCount                                                      | 0x0021 |
| * TxDirectMaxRetryExpiryCount                                       | 0x0022 |
| * TxIndirectMaxRetryExpiryCount                                     | 0x0023 |
| * TxErrCcaCount                                                     | 0x0024 |
| * TxErrAbortCount                                                   | 0x0025 |
| * TxErrBusyChannelCount                                             | 0x0026 |
| * RxTotalCount                                                      | 0x0027 |
| * RxUnicastCount                                                    | 0x0028 |
| * RxBroadcastCount                                                  | 0x0029 |
| * RxDataCount                                                       | 0x002A |
| * RxDataPollCount                                                   | 0x002B |
| * RxBeaconCount                                                     | 0x002C |
| * RxBeaconRequestCount                                              | 0x002D |
| * RxOtherCount                                                      | 0x002E |
| * RxAddressFilteredCount                                            | 0x002F |
| * RxDestAddrFilteredCount                                           | 0x0030 |
| * RxDuplicatedCount                                                 | 0x0031 |
| * RxErrNoFrameCount                                                 | 0x0032 |
| * RxErrUnknownNeighborCount                                         | 0x0033 |
| * RxErrInvalidSrcAddrCount                                          | 0x0034 |
| * RxErrSecCount                                                     | 0x0035 |
| * RxErrFcsCount                                                     | 0x0036 |
| * RxErrOtherCount                                                   | 0x0037 |
| * ActiveTimestamp                                                   | 0x0038 |
| * PendingTimestamp                                                  | 0x0039 |
| * Delay                                                             | 0x003A |
| * SecurityPolicy                                                    | 0x003B |
| * ChannelMask                                                       | 0x003C |
| * OperationalDatasetComponents                                      | 0x003D |
| * ActiveNetworkFaultsList                                           | 0x003E |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * ConnectionStatus                                                  | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class ThreadNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    ThreadNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute Channel
 */
class ReadThreadNetworkDiagnosticsChannel : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChannel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChannelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Channel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Channel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsChannel : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsChannel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeChannelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.Channel response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RoutingRole
 */
class ReadThreadNetworkDiagnosticsRoutingRole : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRoutingRole()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "routing-role");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRoutingRole() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRoutingRoleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RoutingRole response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RoutingRole Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRoutingRole : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRoutingRole()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "routing-role");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRoutingRole() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRoutingRoleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.RoutingRole response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NetworkName
 */
class ReadThreadNetworkDiagnosticsNetworkName : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsNetworkName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "network-name");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNetworkName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNetworkNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.NetworkName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics NetworkName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsNetworkName : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsNetworkName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "network-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsNetworkName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNetworkNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.NetworkName response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PanId
 */
class ReadThreadNetworkDiagnosticsPanId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPanId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePanIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PanId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PanId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsPanId : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsPanId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePanIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"ThreadNetworkDiagnostics.PanId response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ExtendedPanId
 */
class ReadThreadNetworkDiagnosticsExtendedPanId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsExtendedPanId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "extended-pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsExtendedPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeExtendedPanIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ExtendedPanId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ExtendedPanId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsExtendedPanId : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsExtendedPanId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "extended-pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsExtendedPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeExtendedPanIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.ExtendedPanId response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeshLocalPrefix
 */
class ReadThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsMeshLocalPrefix()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsMeshLocalPrefix() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeshLocalPrefixWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.MeshLocalPrefix response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics MeshLocalPrefix Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsMeshLocalPrefix()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsMeshLocalPrefix() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMeshLocalPrefixWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.MeshLocalPrefix response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadThreadNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.OverrunCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOverrunCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.OverrunCount response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NeighborTableList
 */
class ReadThreadNetworkDiagnosticsNeighborTableList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsNeighborTableList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "neighbor-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNeighborTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNeighborTableListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.NeighborTableList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics NeighborTableList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsNeighborTableList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsNeighborTableList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "neighbor-table-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsNeighborTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNeighborTableListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.NeighborTableList response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouteTableList
 */
class ReadThreadNetworkDiagnosticsRouteTableList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRouteTableList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "route-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouteTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRouteTableListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RouteTableList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RouteTableList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRouteTableList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRouteTableList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "route-table-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRouteTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRouteTableListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.RouteTableList response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionId
 */
class ReadThreadNetworkDiagnosticsPartitionId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPartitionId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartitionIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PartitionId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PartitionId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsPartitionId : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsPartitionId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "partition-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsPartitionId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartitionIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.PartitionId response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Weighting
 */
class ReadThreadNetworkDiagnosticsWeighting : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsWeighting()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "weighting");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsWeighting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWeightingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Weighting response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Weighting Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsWeighting : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsWeighting()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "weighting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsWeighting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWeightingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ThreadNetworkDiagnostics.Weighting response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DataVersion
 */
class ReadThreadNetworkDiagnosticsDataVersion : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDataVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDataVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.DataVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics DataVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsDataVersion : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsDataVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDataVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.DataVersion response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StableDataVersion
 */
class ReadThreadNetworkDiagnosticsStableDataVersion : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsStableDataVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "stable-data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsStableDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStableDataVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.StableDataVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics StableDataVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsStableDataVersion : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsStableDataVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "stable-data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsStableDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStableDataVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.StableDataVersion response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRouterId
 */
class ReadThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsLeaderRouterId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-router-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRouterId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLeaderRouterIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.LeaderRouterId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics LeaderRouterId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsLeaderRouterId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "leader-router-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsLeaderRouterId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLeaderRouterIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.LeaderRouterId response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DetachedRoleCount
 */
class ReadThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDetachedRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "detached-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDetachedRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDetachedRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.DetachedRoleCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics DetachedRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsDetachedRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "detached-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsDetachedRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDetachedRoleCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.DetachedRoleCount response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChildRoleCount
 */
class ReadThreadNetworkDiagnosticsChildRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChildRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "child-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChildRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChildRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ChildRoleCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ChildRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsChildRoleCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsChildRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "child-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsChildRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeChildRoleCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.ChildRoleCount response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouterRoleCount
 */
class ReadThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRouterRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "router-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouterRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRouterRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RouterRoleCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RouterRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRouterRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "router-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRouterRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRouterRoleCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.RouterRoleCount response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRoleCount
 */
class ReadThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsLeaderRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLeaderRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.LeaderRoleCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics LeaderRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsLeaderRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "leader-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsLeaderRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLeaderRoleCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.LeaderRoleCount response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsAttachAttemptCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttachAttemptCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.AttachAttemptCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics AttachAttemptCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsAttachAttemptCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttachAttemptCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"ThreadNetworkDiagnostics.AttachAttemptCount response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionIdChangeCount
 */
class ReadThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPartitionIdChangeCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionIdChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartitionIdChangeCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PartitionIdChangeCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PartitionIdChangeCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsPartitionIdChangeCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "partition-id-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsPartitionIdChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartitionIdChangeCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ThreadNetworkDiagnostics.PartitionIdChangeCount response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BetterPartitionAttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000014) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBetterPartitionAttachAttemptCountWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.BetterPartitionAttachAttemptCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics BetterPartitionAttachAttemptCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000014) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBetterPartitionAttachAttemptCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                             params:params
                                                            subscriptionEstablished:nullptr
                                                                      reportHandler:^(
                                                                          NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                          NSLog(@"ThreadNetworkDiagnostics."
                                                                                @"BetterPartitionAttachAttemptCount response %@",
                                                                              [value description]);
                                                                          if (error || !mWait) {
                                                                              SetCommandExitStatus(
                                                                                  [CHIPError errorToCHIPErrorCode:error]);
                                                                          }
                                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ParentChangeCount
 */
class ReadThreadNetworkDiagnosticsParentChangeCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsParentChangeCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "parent-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsParentChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000015) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeParentChangeCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ParentChangeCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ParentChangeCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsParentChangeCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsParentChangeCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "parent-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsParentChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000015) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeParentChangeCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.ParentChangeCount response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxTotalCount
 */
class ReadThreadNetworkDiagnosticsTxTotalCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxTotalCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000016) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxTotalCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxTotalCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxTotalCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxTotalCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxTotalCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000016) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxTotalCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.TxTotalCount response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxUnicastCount
 */
class ReadThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxUnicastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000017) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxUnicastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxUnicastCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxUnicastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxUnicastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxUnicastCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.TxUnicastCount response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBroadcastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000018) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxBroadcastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBroadcastCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBroadcastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxBroadcastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000018) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxBroadcastCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ThreadNetworkDiagnostics.TxBroadcastCount response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxAckRequestedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000019) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxAckRequestedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxAckRequestedCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxAckRequestedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxAckRequestedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000019) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxAckRequestedCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ThreadNetworkDiagnostics.TxAckRequestedCount response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckedCount
 */
class ReadThreadNetworkDiagnosticsTxAckedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxAckedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-acked-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxAckedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxAckedCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxAckedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxAckedCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxAckedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-acked-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxAckedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxAckedCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.TxAckedCount response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxNoAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxNoAckRequestedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxNoAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxNoAckRequestedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxNoAckRequestedCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxNoAckRequestedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxNoAckRequestedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxNoAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxNoAckRequestedCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ThreadNetworkDiagnostics.TxNoAckRequestedCount response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataCount
 */
class ReadThreadNetworkDiagnosticsTxDataCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDataCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxDataCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxDataCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDataCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxDataCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxDataCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxDataCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.TxDataCount response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataPollCount
 */
class ReadThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDataPollCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxDataPollCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxDataPollCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDataPollCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxDataPollCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxDataPollCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.TxDataPollCount response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBeaconCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxBeaconCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBeaconCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBeaconCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxBeaconCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxBeaconCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.TxBeaconCount response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBeaconRequestCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxBeaconRequestCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBeaconRequestCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBeaconRequestCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxBeaconRequestCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxBeaconRequestCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ThreadNetworkDiagnostics.TxBeaconRequestCount response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxOtherCount
 */
class ReadThreadNetworkDiagnosticsTxOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000020) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxOtherCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxOtherCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000020) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxOtherCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.TxOtherCount response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxRetryCount
 */
class ReadThreadNetworkDiagnosticsTxRetryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxRetryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-retry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxRetryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000021) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxRetryCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxRetryCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxRetryCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxRetryCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxRetryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-retry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxRetryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000021) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxRetryCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.TxRetryCount response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000022) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeTxDirectMaxRetryExpiryCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.TxDirectMaxRetryExpiryCount response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDirectMaxRetryExpiryCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000022) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxDirectMaxRetryExpiryCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ThreadNetworkDiagnostics.TxDirectMaxRetryExpiryCount "
                                                                     @"response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxIndirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000023) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxIndirectMaxRetryExpiryCountWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxIndirectMaxRetryExpiryCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxIndirectMaxRetryExpiryCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000023) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxIndirectMaxRetryExpiryCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"ThreadNetworkDiagnostics.TxIndirectMaxRetryExpiryCount "
                                                                       @"response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCcaCount
 */
class ReadThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrCcaCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrCcaCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000024) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxErrCcaCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrCcaCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrCcaCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxErrCcaCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxErrCcaCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000024) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxErrCcaCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.TxErrCcaCount response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrAbortCount
 */
class ReadThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrAbortCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrAbortCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000025) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxErrAbortCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrAbortCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrAbortCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxErrAbortCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxErrAbortCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000025) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxErrAbortCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.TxErrAbortCount response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrBusyChannelCount
 */
class ReadThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrBusyChannelCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrBusyChannelCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000026) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxErrBusyChannelCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrBusyChannelCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrBusyChannelCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxErrBusyChannelCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxErrBusyChannelCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000026) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxErrBusyChannelCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:nullptr
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ThreadNetworkDiagnostics.TxErrBusyChannelCount response %@",
                                                                  [value description]);
                                                              if (error || !mWait) {
                                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                              }
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxTotalCount
 */
class ReadThreadNetworkDiagnosticsRxTotalCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxTotalCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000027) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxTotalCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxTotalCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxTotalCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxTotalCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxTotalCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000027) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxTotalCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.RxTotalCount response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxUnicastCount
 */
class ReadThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxUnicastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000028) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxUnicastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxUnicastCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxUnicastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxUnicastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000028) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxUnicastCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.RxUnicastCount response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBroadcastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000029) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxBroadcastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBroadcastCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBroadcastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxBroadcastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000029) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxBroadcastCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ThreadNetworkDiagnostics.RxBroadcastCount response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataCount
 */
class ReadThreadNetworkDiagnosticsRxDataCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDataCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxDataCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDataCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDataCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxDataCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxDataCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxDataCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.RxDataCount response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataPollCount
 */
class ReadThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDataPollCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxDataPollCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDataPollCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDataPollCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxDataPollCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxDataPollCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.RxDataPollCount response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBeaconCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxBeaconCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBeaconCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBeaconCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxBeaconCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxBeaconCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.RxBeaconCount response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBeaconRequestCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxBeaconRequestCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBeaconRequestCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBeaconRequestCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxBeaconRequestCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxBeaconRequestCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ThreadNetworkDiagnostics.RxBeaconRequestCount response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxOtherCount
 */
class ReadThreadNetworkDiagnosticsRxOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxOtherCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxOtherCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxOtherCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:nullptr
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.RxOtherCount response %@", [value description]);
                                                if (error || !mWait) {
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxAddressFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxAddressFilteredCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxAddressFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxAddressFilteredCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxAddressFilteredCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxAddressFilteredCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxAddressFilteredCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxAddressFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxAddressFilteredCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ThreadNetworkDiagnostics.RxAddressFilteredCount response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDestAddrFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000030) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeRxDestAddrFilteredCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxDestAddrFilteredCount response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDestAddrFilteredCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxDestAddrFilteredCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxDestAddrFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000030) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxDestAddrFilteredCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"ThreadNetworkDiagnostics.RxDestAddrFilteredCount response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDuplicatedCount
 */
class ReadThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDuplicatedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDuplicatedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000031) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxDuplicatedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDuplicatedCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDuplicatedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxDuplicatedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxDuplicatedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000031) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxDuplicatedCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.RxDuplicatedCount response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrNoFrameCount
 */
class ReadThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrNoFrameCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrNoFrameCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000032) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxErrNoFrameCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrNoFrameCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrNoFrameCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrNoFrameCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrNoFrameCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000032) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxErrNoFrameCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:nullptr
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.RxErrNoFrameCount response %@",
                                                              [value description]);
                                                          if (error || !mWait) {
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrUnknownNeighborCount
 */
class ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000033) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeRxErrUnknownNeighborCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxErrUnknownNeighborCount response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrUnknownNeighborCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrUnknownNeighborCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrUnknownNeighborCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000033) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxErrUnknownNeighborCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(
                                                                 @"ThreadNetworkDiagnostics.RxErrUnknownNeighborCount response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrInvalidSrcAddrCount
 */
class ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000034) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeRxErrInvalidSrcAddrCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxErrInvalidSrcAddrCount response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrInvalidSrcAddrCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000034) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxErrInvalidSrcAddrCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ThreadNetworkDiagnostics.RxErrInvalidSrcAddrCount response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrSecCount
 */
class ReadThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrSecCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrSecCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000035) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxErrSecCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrSecCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrSecCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrSecCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrSecCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000035) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxErrSecCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.RxErrSecCount response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrFcsCount
 */
class ReadThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrFcsCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrFcsCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000036) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxErrFcsCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrFcsCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrFcsCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrFcsCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrFcsCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000036) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxErrFcsCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.RxErrFcsCount response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrOtherCount
 */
class ReadThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000037) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxErrOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrOtherCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000037) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxErrOtherCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.RxErrOtherCount response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveTimestamp
 */
class ReadThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsActiveTimestamp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000038) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveTimestampWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ActiveTimestamp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ActiveTimestamp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsActiveTimestamp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsActiveTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000038) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveTimestampWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.ActiveTimestamp response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PendingTimestamp
 */
class ReadThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPendingTimestamp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pending-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPendingTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000039) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePendingTimestampWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PendingTimestamp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PendingTimestamp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsPendingTimestamp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pending-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsPendingTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000039) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePendingTimestampWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:nullptr
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ThreadNetworkDiagnostics.PendingTimestamp response %@",
                                                             [value description]);
                                                         if (error || !mWait) {
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Delay
 */
class ReadThreadNetworkDiagnosticsDelay : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDelay()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "delay");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDelay() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDelayWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Delay response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Delay Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsDelay : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsDelay()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "delay");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsDelay() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDelayWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"ThreadNetworkDiagnostics.Delay response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityPolicy
 */
class ReadThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsSecurityPolicy()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "security-policy");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsSecurityPolicy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSecurityPolicyWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.SecurityPolicy response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics SecurityPolicy Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsSecurityPolicy()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "security-policy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsSecurityPolicy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSecurityPolicyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.SecurityPolicy response %@",
                                                           [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelMask
 */
class ReadThreadNetworkDiagnosticsChannelMask : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChannelMask()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-mask");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannelMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChannelMaskWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ChannelMask response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ChannelMask Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsChannelMask : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsChannelMask()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsChannelMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeChannelMaskWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.ChannelMask response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalDatasetComponents
 */
class ReadThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsOperationalDatasetComponents()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-dataset-components");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOperationalDatasetComponents() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeOperationalDatasetComponentsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.OperationalDatasetComponents response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics OperationalDatasetComponents Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsOperationalDatasetComponents()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operational-dataset-components");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsOperationalDatasetComponents() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOperationalDatasetComponentsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:nullptr
                                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"ThreadNetworkDiagnostics.OperationalDatasetComponents "
                                                                      @"response %@",
                                                                    [value description]);
                                                                if (error || !mWait) {
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveNetworkFaultsList
 */
class ReadThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsActiveNetworkFaultsList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveNetworkFaultsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveNetworkFaultsListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ActiveNetworkFaultsList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ActiveNetworkFaultsList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsActiveNetworkFaultsList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-network-faults-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsActiveNetworkFaultsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActiveNetworkFaultsListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"ThreadNetworkDiagnostics.ActiveNetworkFaultsList response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadThreadNetworkDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ThreadNetworkDiagnostics.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadThreadNetworkDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ThreadNetworkDiagnostics.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThreadNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadThreadNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ThreadNetworkDiagnostics.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThreadNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TimeFormatLocalization                                      | 0x002C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * HourFormat                                                        | 0x0000 |
| * ActiveCalendarType                                                | 0x0001 |
| * SupportedCalendarTypes                                            | 0x0002 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute HourFormat
 */
class ReadTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    ReadTimeFormatLocalizationHourFormat()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hour-format");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHourFormatWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.HourFormat response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization HourFormat Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    WriteTimeFormatLocalizationHourFormat()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "hour-format");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeHourFormatWithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogError(chipTool, "TimeFormatLocalization HourFormat Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationHourFormat()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hour-format");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeHourFormatWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"TimeFormatLocalization.HourFormat response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveCalendarType
 */
class ReadTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    ReadTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-calendar-type");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveCalendarTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.ActiveCalendarType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization ActiveCalendarType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    WriteTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "active-calendar-type");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) WriteAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeActiveCalendarTypeWithValue:value
                                         completionHandler:^(NSError * _Nullable error) {
                                             chipError = [CHIPError errorToCHIPErrorCode:error];
                                             ChipLogError(chipTool, "TimeFormatLocalization ActiveCalendarType Error: %s",
                                                 chip::ErrorStr(chipError));
                                             SetCommandExitStatus(chipError);
                                         }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-calendar-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveCalendarTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:nullptr
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"TimeFormatLocalization.ActiveCalendarType response %@",
                                                               [value description]);
                                                           if (error || !mWait) {
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedCalendarTypes
 */
class ReadTimeFormatLocalizationSupportedCalendarTypes : public ModelCommand {
public:
    ReadTimeFormatLocalizationSupportedCalendarTypes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-calendar-types");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationSupportedCalendarTypes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportedCalendarTypesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.SupportedCalendarTypes response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization SupportedCalendarTypes Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTimeFormatLocalizationSupportedCalendarTypes : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationSupportedCalendarTypes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-calendar-types");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationSupportedCalendarTypes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedCalendarTypesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"TimeFormatLocalization.SupportedCalendarTypes response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadTimeFormatLocalizationGeneratedCommandList : public ModelCommand {
public:
    ReadTimeFormatLocalizationGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTimeFormatLocalizationGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"TimeFormatLocalization.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadTimeFormatLocalizationAcceptedCommandList : public ModelCommand {
public:
    ReadTimeFormatLocalizationAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTimeFormatLocalizationAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"TimeFormatLocalization.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTimeFormatLocalizationClusterRevision : public ModelCommand {
public:
    ReadTimeFormatLocalizationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTimeFormatLocalizationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TimeFormatLocalization.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster UnitLocalization                                            | 0x002D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TemperatureUnit                                                   | 0x0000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute TemperatureUnit
 */
class ReadUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    ReadUnitLocalizationTemperatureUnit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "temperature-unit");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTemperatureUnitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.TemperatureUnit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization TemperatureUnit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    WriteUnitLocalizationTemperatureUnit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "temperature-unit");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeTemperatureUnitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          chipError = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(
                                              chipTool, "UnitLocalization TemperatureUnit Error: %s", chip::ErrorStr(chipError));
                                          SetCommandExitStatus(chipError);
                                      }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    SubscribeAttributeUnitLocalizationTemperatureUnit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "temperature-unit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTemperatureUnitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"UnitLocalization.TemperatureUnit response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadUnitLocalizationAttributeList : public ModelCommand {
public:
    ReadUnitLocalizationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUnitLocalizationAttributeList : public ModelCommand {
public:
    SubscribeAttributeUnitLocalizationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUnitLocalizationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"UnitLocalization.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadUnitLocalizationFeatureMap : public ModelCommand {
public:
    ReadUnitLocalizationFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUnitLocalizationFeatureMap : public ModelCommand {
public:
    SubscribeAttributeUnitLocalizationFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUnitLocalizationFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"UnitLocalization.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadUnitLocalizationClusterRevision : public ModelCommand {
public:
    ReadUnitLocalizationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUnitLocalizationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeUnitLocalizationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUnitLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"UnitLocalization.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster UserLabel                                                   | 0x0041 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute LabelList
 */
class ReadUserLabelLabelList : public ModelCommand {
public:
    ReadUserLabelLabelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLabelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UserLabel.LabelList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UserLabel LabelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteUserLabelLabelList : public ModelCommand {
public:
    WriteUserLabelLabelList()
        : ModelCommand("write")
        , mComplex(&mValue)
    {
        AddArgument("attr-name", "label-list");
        AddArgument("attr-value", &mComplex);
        ModelCommand::AddArguments();
    }

    ~WriteUserLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) WriteAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            for (auto & entry_0 : mValue) {
                CHIPUserLabelClusterLabelStruct * newElement_0;
                newElement_0 = [CHIPUserLabelClusterLabelStruct new];
                newElement_0.label = [[NSString alloc] initWithBytes:entry_0.label.data()
                                                              length:entry_0.label.size()
                                                            encoding:NSUTF8StringEncoding];
                newElement_0.value = [[NSString alloc] initWithBytes:entry_0.value.data()
                                                              length:entry_0.value.size()
                                                            encoding:NSUTF8StringEncoding];
                [array_0 addObject:newElement_0];
            }
            value = array_0;
        }

        [cluster writeAttributeLabelListWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    chipError = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogError(chipTool, "UserLabel LabelList Error: %s", chip::ErrorStr(chipError));
                                    SetCommandExitStatus(chipError);
                                }];
        return chipError;
    }

private:
    chip::app::DataModel::List<const chip::app::Clusters::UserLabel::Structs::LabelStruct::Type> mValue;
    TypedComplexArgument<chip::app::DataModel::List<const chip::app::Clusters::UserLabel::Structs::LabelStruct::Type>> mComplex;
};

class SubscribeAttributeUserLabelLabelList : public ModelCommand {
public:
    SubscribeAttributeUserLabelLabelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "label-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUserLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLabelListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"UserLabel.LabelList response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadUserLabelGeneratedCommandList : public ModelCommand {
public:
    ReadUserLabelGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UserLabel.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UserLabel GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUserLabelGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeUserLabelGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUserLabelGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"UserLabel.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadUserLabelAcceptedCommandList : public ModelCommand {
public:
    ReadUserLabelAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UserLabel.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UserLabel AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUserLabelAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeUserLabelAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUserLabelAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"UserLabel.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadUserLabelClusterRevision : public ModelCommand {
public:
    ReadUserLabelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UserLabel.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UserLabel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUserLabelClusterRevision : public ModelCommand {
public:
    SubscribeAttributeUserLabelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUserLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"UserLabel.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WakeOnLan                                                   | 0x0503 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MACAddress                                                        | 0x0000 |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MACAddress
 */
class ReadWakeOnLanMACAddress : public ModelCommand {
public:
    ReadWakeOnLanMACAddress()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "macaddress");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanMACAddress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMACAddressWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.MACAddress response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan MACAddress Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanMACAddress : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanMACAddress()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "macaddress");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanMACAddress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMACAddressWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"WakeOnLan.MACAddress response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadWakeOnLanGeneratedCommandList : public ModelCommand {
public:
    ReadWakeOnLanGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WakeOnLan.GeneratedCommandList response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadWakeOnLanAcceptedCommandList : public ModelCommand {
public:
    ReadWakeOnLanAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"WakeOnLan.AcceptedCommandList response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWakeOnLanAttributeList : public ModelCommand {
public:
    ReadWakeOnLanAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanAttributeList : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"WakeOnLan.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWakeOnLanClusterRevision : public ModelCommand {
public:
    ReadWakeOnLanClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanClusterRevision : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WakeOnLan.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WiFiNetworkDiagnostics                                      | 0x0036 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Bssid                                                             | 0x0000 |
| * SecurityType                                                      | 0x0001 |
| * WiFiVersion                                                       | 0x0002 |
| * ChannelNumber                                                     | 0x0003 |
| * Rssi                                                              | 0x0004 |
| * BeaconLostCount                                                   | 0x0005 |
| * BeaconRxCount                                                     | 0x0006 |
| * PacketMulticastRxCount                                            | 0x0007 |
| * PacketMulticastTxCount                                            | 0x0008 |
| * PacketUnicastRxCount                                              | 0x0009 |
| * PacketUnicastTxCount                                              | 0x000A |
| * CurrentMaxRate                                                    | 0x000B |
| * OverrunCount                                                      | 0x000C |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * Disconnection                                                     | 0x0000 |
| * AssociationFailure                                                | 0x0001 |
| * ConnectionStatus                                                  | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class WiFiNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    WiFiNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute Bssid
 */
class ReadWiFiNetworkDiagnosticsBssid : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBssid()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bssid");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBssid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBssidWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.Bssid response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics Bssid Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsBssid : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsBssid()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bssid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsBssid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBssidWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:nullptr
                                          reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"WiFiNetworkDiagnostics.Bssid response %@", [value description]);
                                              if (error || !mWait) {
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityType
 */
class ReadWiFiNetworkDiagnosticsSecurityType : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsSecurityType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "security-type");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsSecurityType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSecurityTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.SecurityType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics SecurityType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsSecurityType : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsSecurityType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "security-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsSecurityType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000001) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSecurityTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WiFiNetworkDiagnostics.SecurityType response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WiFiVersion
 */
class ReadWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsWiFiVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wi-fi-version");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsWiFiVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWiFiVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.WiFiVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics WiFiVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsWiFiVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wi-fi-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsWiFiVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000002) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWiFiVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:nullptr
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"WiFiNetworkDiagnostics.WiFiVersion response %@", [value description]);
                                                    if (error || !mWait) {
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelNumber
 */
class ReadWiFiNetworkDiagnosticsChannelNumber : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsChannelNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-number");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsChannelNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChannelNumberWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.ChannelNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics ChannelNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsChannelNumber : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsChannelNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsChannelNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeChannelNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"WiFiNetworkDiagnostics.ChannelNumber response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Rssi
 */
class ReadWiFiNetworkDiagnosticsRssi : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsRssi()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rssi");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsRssi() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRssiWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.Rssi response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics Rssi Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsRssi : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsRssi()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rssi");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsRssi() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRssiWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                params:params
                               subscriptionEstablished:nullptr
                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                             NSLog(@"WiFiNetworkDiagnostics.Rssi response %@", [value description]);
                                             if (error || !mWait) {
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }
                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconLostCount
 */
class ReadWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBeaconLostCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-lost-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconLostCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBeaconLostCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.BeaconLostCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics BeaconLostCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsBeaconLostCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "beacon-lost-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsBeaconLostCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000005) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBeaconLostCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WiFiNetworkDiagnostics.BeaconLostCount response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconRxCount
 */
class ReadWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBeaconRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000006) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBeaconRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.BeaconRxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics BeaconRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsBeaconRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "beacon-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsBeaconRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000006) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBeaconRxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"WiFiNetworkDiagnostics.BeaconRxCount response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketMulticastRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketMulticastRxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketMulticastRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketMulticastRxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"WiFiNetworkDiagnostics.PacketMulticastRxCount response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketMulticastTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketMulticastTxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketMulticastTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketMulticastTxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"WiFiNetworkDiagnostics.PacketMulticastTxCount response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketUnicastRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketUnicastRxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketUnicastRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketUnicastRxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"WiFiNetworkDiagnostics.PacketUnicastRxCount response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketUnicastTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketUnicastTxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketUnicastTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketUnicastTxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"WiFiNetworkDiagnostics.PacketUnicastTxCount response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMaxRate
 */
class ReadWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsCurrentMaxRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-max-rate");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsCurrentMaxRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentMaxRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.CurrentMaxRate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics CurrentMaxRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsCurrentMaxRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-max-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsCurrentMaxRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentMaxRateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:nullptr
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"WiFiNetworkDiagnostics.CurrentMaxRate response %@", [value description]);
                                                  if (error || !mWait) {
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadWiFiNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.OverrunCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOverrunCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WiFiNetworkDiagnostics.OverrunCount response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadWiFiNetworkDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"WiFiNetworkDiagnostics.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadWiFiNetworkDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WiFiNetworkDiagnostics.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWiFiNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:nullptr
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"WiFiNetworkDiagnostics.AttributeList response %@", [value description]);
                                                 if (error || !mWait) {
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadWiFiNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"WiFiNetworkDiagnostics.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWiFiNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WiFiNetworkDiagnostics.ClusterRevision response %@",
                                                            [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WindowCovering                                              | 0x0102 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * UpOrOpen                                                          |   0x00 |
| * DownOrClose                                                       |   0x01 |
| * StopMotion                                                        |   0x02 |
| * GoToLiftValue                                                     |   0x04 |
| * GoToLiftPercentage                                                |   0x05 |
| * GoToTiltValue                                                     |   0x07 |
| * GoToTiltPercentage                                                |   0x08 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Type                                                              | 0x0000 |
| * PhysicalClosedLimitLift                                           | 0x0001 |
| * PhysicalClosedLimitTilt                                           | 0x0002 |
| * CurrentPositionLift                                               | 0x0003 |
| * CurrentPositionTilt                                               | 0x0004 |
| * NumberOfActuationsLift                                            | 0x0005 |
| * NumberOfActuationsTilt                                            | 0x0006 |
| * ConfigStatus                                                      | 0x0007 |
| * CurrentPositionLiftPercentage                                     | 0x0008 |
| * CurrentPositionTiltPercentage                                     | 0x0009 |
| * OperationalStatus                                                 | 0x000A |
| * TargetPositionLiftPercent100ths                                   | 0x000B |
| * TargetPositionTiltPercent100ths                                   | 0x000C |
| * EndProductType                                                    | 0x000D |
| * CurrentPositionLiftPercent100ths                                  | 0x000E |
| * CurrentPositionTiltPercent100ths                                  | 0x000F |
| * InstalledOpenLimitLift                                            | 0x0010 |
| * InstalledClosedLimitLift                                          | 0x0011 |
| * InstalledOpenLimitTilt                                            | 0x0012 |
| * InstalledClosedLimitTilt                                          | 0x0013 |
| * Mode                                                              | 0x0017 |
| * SafetyStatus                                                      | 0x001A |
| * GeneratedCommandList                                              | 0xFFF8 |
| * AcceptedCommandList                                               | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command DownOrClose
 */
class WindowCoveringDownOrClose : public ModelCommand {
public:
    WindowCoveringDownOrClose()
        : ModelCommand("down-or-close")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000001) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster downOrCloseWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command GoToLiftPercentage
 */
class WindowCoveringGoToLiftPercentage : public ModelCommand {
public:
    WindowCoveringGoToLiftPercentage()
        : ModelCommand("go-to-lift-percentage")
    {
        AddArgument("LiftPercentageValue", 0, UINT8_MAX, &mLiftPercentageValue);
        AddArgument("LiftPercent100thsValue", 0, UINT16_MAX, &mLiftPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000005) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftPercentageParams alloc] init];

        params.liftPercentageValue = [NSNumber numberWithUnsignedChar:mLiftPercentageValue];

        params.liftPercent100thsValue = [NSNumber numberWithUnsignedShort:mLiftPercent100thsValue];
        [cluster goToLiftPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    chip::Percent mLiftPercentageValue;
    chip::Percent100ths mLiftPercent100thsValue;
};

/*
 * Command GoToLiftValue
 */
class WindowCoveringGoToLiftValue : public ModelCommand {
public:
    WindowCoveringGoToLiftValue()
        : ModelCommand("go-to-lift-value")
    {
        AddArgument("LiftValue", 0, UINT16_MAX, &mLiftValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftValueParams alloc] init];

        params.liftValue = [NSNumber numberWithUnsignedShort:mLiftValue];
        [cluster goToLiftValueWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint16_t mLiftValue;
};

/*
 * Command GoToTiltPercentage
 */
class WindowCoveringGoToTiltPercentage : public ModelCommand {
public:
    WindowCoveringGoToTiltPercentage()
        : ModelCommand("go-to-tilt-percentage")
    {
        AddArgument("TiltPercentageValue", 0, UINT8_MAX, &mTiltPercentageValue);
        AddArgument("TiltPercent100thsValue", 0, UINT16_MAX, &mTiltPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltPercentageParams alloc] init];

        params.tiltPercentageValue = [NSNumber numberWithUnsignedChar:mTiltPercentageValue];

        params.tiltPercent100thsValue = [NSNumber numberWithUnsignedShort:mTiltPercent100thsValue];
        [cluster goToTiltPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                chipError = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                                SetCommandExitStatus(chipError);
                            }];
        return chipError;
    }

private:
    chip::Percent mTiltPercentageValue;
    chip::Percent100ths mTiltPercent100thsValue;
};

/*
 * Command GoToTiltValue
 */
class WindowCoveringGoToTiltValue : public ModelCommand {
public:
    WindowCoveringGoToTiltValue()
        : ModelCommand("go-to-tilt-value")
    {
        AddArgument("TiltValue", 0, UINT16_MAX, &mTiltValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltValueParams alloc] init];

        params.tiltValue = [NSNumber numberWithUnsignedShort:mTiltValue];
        [cluster goToTiltValueWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           chipError = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
                           SetCommandExitStatus(chipError);
                       }];
        return chipError;
    }

private:
    uint16_t mTiltValue;
};

/*
 * Command StopMotion
 */
class WindowCoveringStopMotion : public ModelCommand {
public:
    WindowCoveringStopMotion()
        : ModelCommand("stop-motion")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000002) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster stopMotionWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Command UpOrOpen
 */
class WindowCoveringUpOrOpen : public ModelCommand {
public:
    WindowCoveringUpOrOpen()
        : ModelCommand("up-or-open")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;
        [cluster upOrOpenWithCompletionHandler:^(NSError * _Nullable error) {
            chipError = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(chipError));
            SetCommandExitStatus(chipError);
        }];
        return chipError;
    }

private:
};

/*
 * Attribute Type
 */
class ReadWindowCoveringType : public ModelCommand {
public:
    ReadWindowCoveringType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000000) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.Type response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering Type Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringType : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000000) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                params:params
                               subscriptionEstablished:nullptr
                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                             NSLog(@"WindowCovering.Type response %@", [value description]);
                                             if (error || !mWait) {
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }
                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLift
 */
class ReadWindowCoveringCurrentPositionLift : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000003) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLift response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLift Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionLift : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000003) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentPositionLiftWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.CurrentPositionLift response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTilt
 */
class ReadWindowCoveringCurrentPositionTilt : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000004) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTilt response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTilt Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionTilt : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000004) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentPositionTiltWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.CurrentPositionTilt response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ConfigStatus
 */
class ReadWindowCoveringConfigStatus : public ModelCommand {
public:
    ReadWindowCoveringConfigStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "config-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringConfigStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000007) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeConfigStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.ConfigStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering ConfigStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringConfigStatus : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringConfigStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "config-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringConfigStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000007) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeConfigStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WindowCovering.ConfigStatus response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercentage
 */
class ReadWindowCoveringCurrentPositionLiftPercentage : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLiftPercentage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000008) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionLiftPercentageWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLiftPercentage response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLiftPercentage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionLiftPercentage : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionLiftPercentage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionLiftPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000008) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentPositionLiftPercentageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"WindowCovering.CurrentPositionLiftPercentage response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercentage
 */
class ReadWindowCoveringCurrentPositionTiltPercentage : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTiltPercentage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000009) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionTiltPercentageWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTiltPercentage response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTiltPercentage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionTiltPercentage : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionTiltPercentage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionTiltPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000009) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentPositionTiltPercentageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:nullptr
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"WindowCovering.CurrentPositionTiltPercentage response %@",
                                                                     [value description]);
                                                                 if (error || !mWait) {
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalStatus
 */
class ReadWindowCoveringOperationalStatus : public ModelCommand {
public:
    ReadWindowCoveringOperationalStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringOperationalStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOperationalStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.OperationalStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering OperationalStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringOperationalStatus : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringOperationalStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operational-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringOperationalStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOperationalStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WindowCovering.OperationalStatus response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionLiftPercent100ths
 */
class ReadWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringTargetPositionLiftPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000B) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTargetPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.TargetPositionLiftPercent100ths response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering TargetPositionLiftPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringTargetPositionLiftPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringTargetPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000B) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTargetPositionLiftPercent100thsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                      params:params
                                                     subscriptionEstablished:nullptr
                                                               reportHandler:^(
                                                                   NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                   NSLog(@"WindowCovering.TargetPositionLiftPercent100ths response "
                                                                         @"%@",
                                                                       [value description]);
                                                                   if (error || !mWait) {
                                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                   }
                                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionTiltPercent100ths
 */
class ReadWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringTargetPositionTiltPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000C) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTargetPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.TargetPositionTiltPercent100ths response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering TargetPositionTiltPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringTargetPositionTiltPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringTargetPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000C) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTargetPositionTiltPercent100thsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                      params:params
                                                     subscriptionEstablished:nullptr
                                                               reportHandler:^(
                                                                   NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                   NSLog(@"WindowCovering.TargetPositionTiltPercent100ths response "
                                                                         @"%@",
                                                                       [value description]);
                                                                   if (error || !mWait) {
                                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                   }
                                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndProductType
 */
class ReadWindowCoveringEndProductType : public ModelCommand {
public:
    ReadWindowCoveringEndProductType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "end-product-type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringEndProductType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000D) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEndProductTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.EndProductType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering EndProductType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringEndProductType : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringEndProductType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "end-product-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringEndProductType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000D) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEndProductTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:nullptr
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"WindowCovering.EndProductType response %@", [value description]);
                                                       if (error || !mWait) {
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercent100ths
 */
class ReadWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLiftPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000E) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLiftPercent100ths response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLiftPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionLiftPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000E) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentPositionLiftPercent100thsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                            params:params
                                                           subscriptionEstablished:nullptr
                                                                     reportHandler:^(
                                                                         NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                         NSLog(@"WindowCovering.CurrentPositionLiftPercent100ths "
                                                                               @"response %@",
                                                                             [value description]);
                                                                         if (error || !mWait) {
                                                                             SetCommandExitStatus(
                                                                                 [CHIPError errorToCHIPErrorCode:error]);
                                                                         }
                                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercent100ths
 */
class ReadWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTiltPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000F) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTiltPercent100ths response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTiltPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionTiltPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000F) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentPositionTiltPercent100thsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                            params:params
                                                           subscriptionEstablished:nullptr
                                                                     reportHandler:^(
                                                                         NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                         NSLog(@"WindowCovering.CurrentPositionTiltPercent100ths "
                                                                               @"response %@",
                                                                             [value description]);
                                                                         if (error || !mWait) {
                                                                             SetCommandExitStatus(
                                                                                 [CHIPError errorToCHIPErrorCode:error]);
                                                                         }
                                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitLift
 */
class ReadWindowCoveringInstalledOpenLimitLift : public ModelCommand {
public:
    ReadWindowCoveringInstalledOpenLimitLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000010) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInstalledOpenLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.InstalledOpenLimitLift response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering InstalledOpenLimitLift Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringInstalledOpenLimitLift : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringInstalledOpenLimitLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringInstalledOpenLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000010) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInstalledOpenLimitLiftWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"WindowCovering.InstalledOpenLimitLift response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitLift
 */
class ReadWindowCoveringInstalledClosedLimitLift : public ModelCommand {
public:
    ReadWindowCoveringInstalledClosedLimitLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000011) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeInstalledClosedLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.InstalledClosedLimitLift response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering InstalledClosedLimitLift Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringInstalledClosedLimitLift : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringInstalledClosedLimitLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringInstalledClosedLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000011) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeInstalledClosedLimitLiftWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.InstalledClosedLimitLift response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitTilt
 */
class ReadWindowCoveringInstalledOpenLimitTilt : public ModelCommand {
public:
    ReadWindowCoveringInstalledOpenLimitTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000012) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInstalledOpenLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.InstalledOpenLimitTilt response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering InstalledOpenLimitTilt Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringInstalledOpenLimitTilt : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringInstalledOpenLimitTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringInstalledOpenLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000012) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInstalledOpenLimitTiltWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:nullptr
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"WindowCovering.InstalledOpenLimitTilt response %@",
                                                                   [value description]);
                                                               if (error || !mWait) {
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitTilt
 */
class ReadWindowCoveringInstalledClosedLimitTilt : public ModelCommand {
public:
    ReadWindowCoveringInstalledClosedLimitTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000013) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeInstalledClosedLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.InstalledClosedLimitTilt response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering InstalledClosedLimitTilt Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringInstalledClosedLimitTilt : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringInstalledClosedLimitTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringInstalledClosedLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000013) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeInstalledClosedLimitTiltWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.InstalledClosedLimitTilt response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Mode
 */
class ReadWindowCoveringMode : public ModelCommand {
public:
    ReadWindowCoveringMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "mode");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000017) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.Mode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering Mode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteWindowCoveringMode : public ModelCommand {
public:
    WriteWindowCoveringMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) WriteAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block chipError = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeModeWithValue:value
                           completionHandler:^(NSError * _Nullable error) {
                               chipError = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogError(chipTool, "WindowCovering Mode Error: %s", chip::ErrorStr(chipError));
                               SetCommandExitStatus(chipError);
                           }];
        return chipError;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeWindowCoveringMode : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000017) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                params:params
                               subscriptionEstablished:nullptr
                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                             NSLog(@"WindowCovering.Mode response %@", [value description]);
                                             if (error || !mWait) {
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }
                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SafetyStatus
 */
class ReadWindowCoveringSafetyStatus : public ModelCommand {
public:
    ReadWindowCoveringSafetyStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000001A) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSafetyStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.SafetyStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering SafetyStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringSafetyStatus : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringSafetyStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000001A) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSafetyStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:nullptr
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WindowCovering.SafetyStatus response %@", [value description]);
                                                     if (error || !mWait) {
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneratedCommandList
 */
class ReadWindowCoveringGeneratedCommandList : public ModelCommand {
public:
    ReadWindowCoveringGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFF8) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.GeneratedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering GeneratedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFF8) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:nullptr
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"WindowCovering.GeneratedCommandList response %@",
                                                                 [value description]);
                                                             if (error || !mWait) {
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AcceptedCommandList
 */
class ReadWindowCoveringAcceptedCommandList : public ModelCommand {
public:
    ReadWindowCoveringAcceptedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accepted-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFF9) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.AcceptedCommandList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering AcceptedCommandList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringAcceptedCommandList : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringAcceptedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accepted-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringAcceptedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFF9) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:nullptr
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.AcceptedCommandList response %@",
                                                                [value description]);
                                                            if (error || !mWait) {
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWindowCoveringAttributeList : public ModelCommand {
public:
    ReadWindowCoveringAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFB) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringAttributeList : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFB) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:nullptr
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"WindowCovering.AttributeList response %@", [value description]);
                                                      if (error || !mWait) {
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadWindowCoveringFeatureMap : public ModelCommand {
public:
    ReadWindowCoveringFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFC) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringFeatureMap : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFC) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:nullptr
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"WindowCovering.FeatureMap response %@", [value description]);
                                                   if (error || !mWait) {
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWindowCoveringClusterRevision : public ModelCommand {
public:
    ReadWindowCoveringClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFD) on endpoint %u", endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringClusterRevision : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFD) on endpoint %u", endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:nullptr
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WindowCovering.ClusterRevision response %@", [value description]);
                                                        if (error || !mWait) {
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Register all Clusters commands                                               |
\*----------------------------------------------------------------------------*/
void registerClusterAccessControl(Commands & commands)
{
    const char * clusterName = "AccessControl";

    commands_list clusterCommands = {
        make_unique<ReadAccessControlAcl>(), //
        make_unique<WriteAccessControlAcl>(), //
        make_unique<SubscribeAttributeAccessControlAcl>(), //
        make_unique<ReadAccessControlExtension>(), //
        make_unique<WriteAccessControlExtension>(), //
        make_unique<SubscribeAttributeAccessControlExtension>(), //
        make_unique<ReadAccessControlSubjectsPerAccessControlEntry>(), //
        make_unique<SubscribeAttributeAccessControlSubjectsPerAccessControlEntry>(), //
        make_unique<ReadAccessControlTargetsPerAccessControlEntry>(), //
        make_unique<SubscribeAttributeAccessControlTargetsPerAccessControlEntry>(), //
        make_unique<ReadAccessControlAccessControlEntriesPerFabric>(), //
        make_unique<SubscribeAttributeAccessControlAccessControlEntriesPerFabric>(), //
        make_unique<ReadAccessControlGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAccessControlGeneratedCommandList>(), //
        make_unique<ReadAccessControlAcceptedCommandList>(), //
        make_unique<SubscribeAttributeAccessControlAcceptedCommandList>(), //
        make_unique<ReadAccessControlAttributeList>(), //
        make_unique<SubscribeAttributeAccessControlAttributeList>(), //
        make_unique<ReadAccessControlClusterRevision>(), //
        make_unique<SubscribeAttributeAccessControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAccountLogin(Commands & commands)
{
    const char * clusterName = "AccountLogin";

    commands_list clusterCommands = {
        make_unique<AccountLoginGetSetupPIN>(), //
        make_unique<AccountLoginLogin>(), //
        make_unique<AccountLoginLogout>(), //
        make_unique<ReadAccountLoginGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAccountLoginGeneratedCommandList>(), //
        make_unique<ReadAccountLoginAcceptedCommandList>(), //
        make_unique<SubscribeAttributeAccountLoginAcceptedCommandList>(), //
        make_unique<ReadAccountLoginAttributeList>(), //
        make_unique<SubscribeAttributeAccountLoginAttributeList>(), //
        make_unique<ReadAccountLoginClusterRevision>(), //
        make_unique<SubscribeAttributeAccountLoginClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAdministratorCommissioning(Commands & commands)
{
    const char * clusterName = "AdministratorCommissioning";

    commands_list clusterCommands = {
        make_unique<AdministratorCommissioningOpenBasicCommissioningWindow>(), //
        make_unique<AdministratorCommissioningOpenCommissioningWindow>(), //
        make_unique<AdministratorCommissioningRevokeCommissioning>(), //
        make_unique<ReadAdministratorCommissioningWindowStatus>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningWindowStatus>(), //
        make_unique<ReadAdministratorCommissioningAdminFabricIndex>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningAdminFabricIndex>(), //
        make_unique<ReadAdministratorCommissioningAdminVendorId>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningAdminVendorId>(), //
        make_unique<ReadAdministratorCommissioningGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningGeneratedCommandList>(), //
        make_unique<ReadAdministratorCommissioningAcceptedCommandList>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningAcceptedCommandList>(), //
        make_unique<ReadAdministratorCommissioningAttributeList>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningAttributeList>(), //
        make_unique<ReadAdministratorCommissioningClusterRevision>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationBasic(Commands & commands)
{
    const char * clusterName = "ApplicationBasic";

    commands_list clusterCommands = {
        make_unique<ReadApplicationBasicVendorName>(), //
        make_unique<SubscribeAttributeApplicationBasicVendorName>(), //
        make_unique<ReadApplicationBasicVendorID>(), //
        make_unique<SubscribeAttributeApplicationBasicVendorID>(), //
        make_unique<ReadApplicationBasicApplicationName>(), //
        make_unique<SubscribeAttributeApplicationBasicApplicationName>(), //
        make_unique<ReadApplicationBasicProductID>(), //
        make_unique<SubscribeAttributeApplicationBasicProductID>(), //
        make_unique<ReadApplicationBasicApplication>(), //
        make_unique<SubscribeAttributeApplicationBasicApplication>(), //
        make_unique<ReadApplicationBasicStatus>(), //
        make_unique<SubscribeAttributeApplicationBasicStatus>(), //
        make_unique<ReadApplicationBasicApplicationVersion>(), //
        make_unique<SubscribeAttributeApplicationBasicApplicationVersion>(), //
        make_unique<ReadApplicationBasicAllowedVendorList>(), //
        make_unique<SubscribeAttributeApplicationBasicAllowedVendorList>(), //
        make_unique<ReadApplicationBasicGeneratedCommandList>(), //
        make_unique<SubscribeAttributeApplicationBasicGeneratedCommandList>(), //
        make_unique<ReadApplicationBasicAcceptedCommandList>(), //
        make_unique<SubscribeAttributeApplicationBasicAcceptedCommandList>(), //
        make_unique<ReadApplicationBasicAttributeList>(), //
        make_unique<SubscribeAttributeApplicationBasicAttributeList>(), //
        make_unique<ReadApplicationBasicClusterRevision>(), //
        make_unique<SubscribeAttributeApplicationBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationLauncher(Commands & commands)
{
    const char * clusterName = "ApplicationLauncher";

    commands_list clusterCommands = {
        make_unique<ApplicationLauncherHideApp>(), //
        make_unique<ApplicationLauncherLaunchApp>(), //
        make_unique<ApplicationLauncherStopApp>(), //
        make_unique<ReadApplicationLauncherCatalogList>(), //
        make_unique<SubscribeAttributeApplicationLauncherCatalogList>(), //
        make_unique<ReadApplicationLauncherCurrentApp>(), //
        make_unique<WriteApplicationLauncherCurrentApp>(), //
        make_unique<SubscribeAttributeApplicationLauncherCurrentApp>(), //
        make_unique<ReadApplicationLauncherGeneratedCommandList>(), //
        make_unique<SubscribeAttributeApplicationLauncherGeneratedCommandList>(), //
        make_unique<ReadApplicationLauncherAcceptedCommandList>(), //
        make_unique<SubscribeAttributeApplicationLauncherAcceptedCommandList>(), //
        make_unique<ReadApplicationLauncherAttributeList>(), //
        make_unique<SubscribeAttributeApplicationLauncherAttributeList>(), //
        make_unique<ReadApplicationLauncherClusterRevision>(), //
        make_unique<SubscribeAttributeApplicationLauncherClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAudioOutput(Commands & commands)
{
    const char * clusterName = "AudioOutput";

    commands_list clusterCommands = {
        make_unique<AudioOutputRenameOutput>(), //
        make_unique<AudioOutputSelectOutput>(), //
        make_unique<ReadAudioOutputOutputList>(), //
        make_unique<SubscribeAttributeAudioOutputOutputList>(), //
        make_unique<ReadAudioOutputCurrentOutput>(), //
        make_unique<SubscribeAttributeAudioOutputCurrentOutput>(), //
        make_unique<ReadAudioOutputGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAudioOutputGeneratedCommandList>(), //
        make_unique<ReadAudioOutputAcceptedCommandList>(), //
        make_unique<SubscribeAttributeAudioOutputAcceptedCommandList>(), //
        make_unique<ReadAudioOutputAttributeList>(), //
        make_unique<SubscribeAttributeAudioOutputAttributeList>(), //
        make_unique<ReadAudioOutputClusterRevision>(), //
        make_unique<SubscribeAttributeAudioOutputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBarrierControl(Commands & commands)
{
    const char * clusterName = "BarrierControl";

    commands_list clusterCommands = {
        make_unique<BarrierControlBarrierControlGoToPercent>(), //
        make_unique<BarrierControlBarrierControlStop>(), //
        make_unique<ReadBarrierControlBarrierMovingState>(), //
        make_unique<SubscribeAttributeBarrierControlBarrierMovingState>(), //
        make_unique<ReadBarrierControlBarrierSafetyStatus>(), //
        make_unique<SubscribeAttributeBarrierControlBarrierSafetyStatus>(), //
        make_unique<ReadBarrierControlBarrierCapabilities>(), //
        make_unique<SubscribeAttributeBarrierControlBarrierCapabilities>(), //
        make_unique<ReadBarrierControlBarrierPosition>(), //
        make_unique<SubscribeAttributeBarrierControlBarrierPosition>(), //
        make_unique<ReadBarrierControlGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBarrierControlGeneratedCommandList>(), //
        make_unique<ReadBarrierControlAcceptedCommandList>(), //
        make_unique<SubscribeAttributeBarrierControlAcceptedCommandList>(), //
        make_unique<ReadBarrierControlAttributeList>(), //
        make_unique<SubscribeAttributeBarrierControlAttributeList>(), //
        make_unique<ReadBarrierControlClusterRevision>(), //
        make_unique<SubscribeAttributeBarrierControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBasic(Commands & commands)
{
    const char * clusterName = "Basic";

    commands_list clusterCommands = {
        make_unique<ReadBasicDataModelRevision>(), //
        make_unique<SubscribeAttributeBasicDataModelRevision>(), //
        make_unique<ReadBasicVendorName>(), //
        make_unique<SubscribeAttributeBasicVendorName>(), //
        make_unique<ReadBasicVendorID>(), //
        make_unique<SubscribeAttributeBasicVendorID>(), //
        make_unique<ReadBasicProductName>(), //
        make_unique<SubscribeAttributeBasicProductName>(), //
        make_unique<ReadBasicProductID>(), //
        make_unique<SubscribeAttributeBasicProductID>(), //
        make_unique<ReadBasicNodeLabel>(), //
        make_unique<WriteBasicNodeLabel>(), //
        make_unique<SubscribeAttributeBasicNodeLabel>(), //
        make_unique<ReadBasicLocation>(), //
        make_unique<WriteBasicLocation>(), //
        make_unique<SubscribeAttributeBasicLocation>(), //
        make_unique<ReadBasicHardwareVersion>(), //
        make_unique<SubscribeAttributeBasicHardwareVersion>(), //
        make_unique<ReadBasicHardwareVersionString>(), //
        make_unique<SubscribeAttributeBasicHardwareVersionString>(), //
        make_unique<ReadBasicSoftwareVersion>(), //
        make_unique<SubscribeAttributeBasicSoftwareVersion>(), //
        make_unique<ReadBasicSoftwareVersionString>(), //
        make_unique<SubscribeAttributeBasicSoftwareVersionString>(), //
        make_unique<ReadBasicManufacturingDate>(), //
        make_unique<SubscribeAttributeBasicManufacturingDate>(), //
        make_unique<ReadBasicPartNumber>(), //
        make_unique<SubscribeAttributeBasicPartNumber>(), //
        make_unique<ReadBasicProductURL>(), //
        make_unique<SubscribeAttributeBasicProductURL>(), //
        make_unique<ReadBasicProductLabel>(), //
        make_unique<SubscribeAttributeBasicProductLabel>(), //
        make_unique<ReadBasicSerialNumber>(), //
        make_unique<SubscribeAttributeBasicSerialNumber>(), //
        make_unique<ReadBasicLocalConfigDisabled>(), //
        make_unique<WriteBasicLocalConfigDisabled>(), //
        make_unique<SubscribeAttributeBasicLocalConfigDisabled>(), //
        make_unique<ReadBasicReachable>(), //
        make_unique<SubscribeAttributeBasicReachable>(), //
        make_unique<ReadBasicUniqueID>(), //
        make_unique<SubscribeAttributeBasicUniqueID>(), //
        make_unique<ReadBasicCapabilityMinima>(), //
        make_unique<SubscribeAttributeBasicCapabilityMinima>(), //
        make_unique<ReadBasicGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBasicGeneratedCommandList>(), //
        make_unique<ReadBasicAcceptedCommandList>(), //
        make_unique<SubscribeAttributeBasicAcceptedCommandList>(), //
        make_unique<ReadBasicAttributeList>(), //
        make_unique<SubscribeAttributeBasicAttributeList>(), //
        make_unique<ReadBasicClusterRevision>(), //
        make_unique<SubscribeAttributeBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinaryInputBasic(Commands & commands)
{
    const char * clusterName = "BinaryInputBasic";

    commands_list clusterCommands = {
        make_unique<ReadBinaryInputBasicOutOfService>(), //
        make_unique<WriteBinaryInputBasicOutOfService>(), //
        make_unique<SubscribeAttributeBinaryInputBasicOutOfService>(), //
        make_unique<ReadBinaryInputBasicPresentValue>(), //
        make_unique<WriteBinaryInputBasicPresentValue>(), //
        make_unique<SubscribeAttributeBinaryInputBasicPresentValue>(), //
        make_unique<ReadBinaryInputBasicStatusFlags>(), //
        make_unique<SubscribeAttributeBinaryInputBasicStatusFlags>(), //
        make_unique<ReadBinaryInputBasicGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBinaryInputBasicGeneratedCommandList>(), //
        make_unique<ReadBinaryInputBasicAcceptedCommandList>(), //
        make_unique<SubscribeAttributeBinaryInputBasicAcceptedCommandList>(), //
        make_unique<ReadBinaryInputBasicAttributeList>(), //
        make_unique<SubscribeAttributeBinaryInputBasicAttributeList>(), //
        make_unique<ReadBinaryInputBasicClusterRevision>(), //
        make_unique<SubscribeAttributeBinaryInputBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinding(Commands & commands)
{
    const char * clusterName = "Binding";

    commands_list clusterCommands = {
        make_unique<ReadBindingBinding>(), //
        make_unique<WriteBindingBinding>(), //
        make_unique<SubscribeAttributeBindingBinding>(), //
        make_unique<ReadBindingGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBindingGeneratedCommandList>(), //
        make_unique<ReadBindingAcceptedCommandList>(), //
        make_unique<SubscribeAttributeBindingAcceptedCommandList>(), //
        make_unique<ReadBindingAttributeList>(), //
        make_unique<SubscribeAttributeBindingAttributeList>(), //
        make_unique<ReadBindingClusterRevision>(), //
        make_unique<SubscribeAttributeBindingClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBooleanState(Commands & commands)
{
    const char * clusterName = "BooleanState";

    commands_list clusterCommands = {
        make_unique<ReadBooleanStateStateValue>(), //
        make_unique<SubscribeAttributeBooleanStateStateValue>(), //
        make_unique<ReadBooleanStateGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBooleanStateGeneratedCommandList>(), //
        make_unique<ReadBooleanStateAcceptedCommandList>(), //
        make_unique<SubscribeAttributeBooleanStateAcceptedCommandList>(), //
        make_unique<ReadBooleanStateAttributeList>(), //
        make_unique<SubscribeAttributeBooleanStateAttributeList>(), //
        make_unique<ReadBooleanStateClusterRevision>(), //
        make_unique<SubscribeAttributeBooleanStateClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedActions(Commands & commands)
{
    const char * clusterName = "BridgedActions";

    commands_list clusterCommands = {
        make_unique<BridgedActionsDisableAction>(), //
        make_unique<BridgedActionsDisableActionWithDuration>(), //
        make_unique<BridgedActionsEnableAction>(), //
        make_unique<BridgedActionsEnableActionWithDuration>(), //
        make_unique<BridgedActionsInstantAction>(), //
        make_unique<BridgedActionsInstantActionWithTransition>(), //
        make_unique<BridgedActionsPauseAction>(), //
        make_unique<BridgedActionsPauseActionWithDuration>(), //
        make_unique<BridgedActionsResumeAction>(), //
        make_unique<BridgedActionsStartAction>(), //
        make_unique<BridgedActionsStartActionWithDuration>(), //
        make_unique<BridgedActionsStopAction>(), //
        make_unique<ReadBridgedActionsActionList>(), //
        make_unique<SubscribeAttributeBridgedActionsActionList>(), //
        make_unique<ReadBridgedActionsEndpointList>(), //
        make_unique<SubscribeAttributeBridgedActionsEndpointList>(), //
        make_unique<ReadBridgedActionsSetupUrl>(), //
        make_unique<SubscribeAttributeBridgedActionsSetupUrl>(), //
        make_unique<ReadBridgedActionsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBridgedActionsGeneratedCommandList>(), //
        make_unique<ReadBridgedActionsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeBridgedActionsAcceptedCommandList>(), //
        make_unique<ReadBridgedActionsAttributeList>(), //
        make_unique<SubscribeAttributeBridgedActionsAttributeList>(), //
        make_unique<ReadBridgedActionsClusterRevision>(), //
        make_unique<SubscribeAttributeBridgedActionsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedDeviceBasic(Commands & commands)
{
    const char * clusterName = "BridgedDeviceBasic";

    commands_list clusterCommands = {
        make_unique<ReadBridgedDeviceBasicVendorName>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicVendorName>(), //
        make_unique<ReadBridgedDeviceBasicVendorID>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicVendorID>(), //
        make_unique<ReadBridgedDeviceBasicProductName>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicProductName>(), //
        make_unique<ReadBridgedDeviceBasicNodeLabel>(), //
        make_unique<WriteBridgedDeviceBasicNodeLabel>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicNodeLabel>(), //
        make_unique<ReadBridgedDeviceBasicHardwareVersion>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicHardwareVersion>(), //
        make_unique<ReadBridgedDeviceBasicHardwareVersionString>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicHardwareVersionString>(), //
        make_unique<ReadBridgedDeviceBasicSoftwareVersion>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicSoftwareVersion>(), //
        make_unique<ReadBridgedDeviceBasicSoftwareVersionString>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicSoftwareVersionString>(), //
        make_unique<ReadBridgedDeviceBasicManufacturingDate>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicManufacturingDate>(), //
        make_unique<ReadBridgedDeviceBasicPartNumber>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicPartNumber>(), //
        make_unique<ReadBridgedDeviceBasicProductURL>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicProductURL>(), //
        make_unique<ReadBridgedDeviceBasicProductLabel>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicProductLabel>(), //
        make_unique<ReadBridgedDeviceBasicSerialNumber>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicSerialNumber>(), //
        make_unique<ReadBridgedDeviceBasicReachable>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicReachable>(), //
        make_unique<ReadBridgedDeviceBasicUniqueID>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicUniqueID>(), //
        make_unique<ReadBridgedDeviceBasicGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicGeneratedCommandList>(), //
        make_unique<ReadBridgedDeviceBasicAcceptedCommandList>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicAcceptedCommandList>(), //
        make_unique<ReadBridgedDeviceBasicAttributeList>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicAttributeList>(), //
        make_unique<ReadBridgedDeviceBasicClusterRevision>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterChannel(Commands & commands)
{
    const char * clusterName = "Channel";

    commands_list clusterCommands = {
        make_unique<ChannelChangeChannel>(), //
        make_unique<ChannelChangeChannelByNumber>(), //
        make_unique<ChannelSkipChannel>(), //
        make_unique<ReadChannelChannelList>(), //
        make_unique<SubscribeAttributeChannelChannelList>(), //
        make_unique<ReadChannelLineup>(), //
        make_unique<SubscribeAttributeChannelLineup>(), //
        make_unique<ReadChannelCurrentChannel>(), //
        make_unique<SubscribeAttributeChannelCurrentChannel>(), //
        make_unique<ReadChannelGeneratedCommandList>(), //
        make_unique<SubscribeAttributeChannelGeneratedCommandList>(), //
        make_unique<ReadChannelAcceptedCommandList>(), //
        make_unique<SubscribeAttributeChannelAcceptedCommandList>(), //
        make_unique<ReadChannelAttributeList>(), //
        make_unique<SubscribeAttributeChannelAttributeList>(), //
        make_unique<ReadChannelClusterRevision>(), //
        make_unique<SubscribeAttributeChannelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterColorControl(Commands & commands)
{
    const char * clusterName = "ColorControl";

    commands_list clusterCommands = {
        make_unique<ColorControlColorLoopSet>(), //
        make_unique<ColorControlEnhancedMoveHue>(), //
        make_unique<ColorControlEnhancedMoveToHue>(), //
        make_unique<ColorControlEnhancedMoveToHueAndSaturation>(), //
        make_unique<ColorControlEnhancedStepHue>(), //
        make_unique<ColorControlMoveColor>(), //
        make_unique<ColorControlMoveColorTemperature>(), //
        make_unique<ColorControlMoveHue>(), //
        make_unique<ColorControlMoveSaturation>(), //
        make_unique<ColorControlMoveToColor>(), //
        make_unique<ColorControlMoveToColorTemperature>(), //
        make_unique<ColorControlMoveToHue>(), //
        make_unique<ColorControlMoveToHueAndSaturation>(), //
        make_unique<ColorControlMoveToSaturation>(), //
        make_unique<ColorControlStepColor>(), //
        make_unique<ColorControlStepColorTemperature>(), //
        make_unique<ColorControlStepHue>(), //
        make_unique<ColorControlStepSaturation>(), //
        make_unique<ColorControlStopMoveStep>(), //
        make_unique<ReadColorControlCurrentHue>(), //
        make_unique<SubscribeAttributeColorControlCurrentHue>(), //
        make_unique<ReadColorControlCurrentSaturation>(), //
        make_unique<SubscribeAttributeColorControlCurrentSaturation>(), //
        make_unique<ReadColorControlRemainingTime>(), //
        make_unique<SubscribeAttributeColorControlRemainingTime>(), //
        make_unique<ReadColorControlCurrentX>(), //
        make_unique<SubscribeAttributeColorControlCurrentX>(), //
        make_unique<ReadColorControlCurrentY>(), //
        make_unique<SubscribeAttributeColorControlCurrentY>(), //
        make_unique<ReadColorControlDriftCompensation>(), //
        make_unique<SubscribeAttributeColorControlDriftCompensation>(), //
        make_unique<ReadColorControlCompensationText>(), //
        make_unique<SubscribeAttributeColorControlCompensationText>(), //
        make_unique<ReadColorControlColorTemperature>(), //
        make_unique<SubscribeAttributeColorControlColorTemperature>(), //
        make_unique<ReadColorControlColorMode>(), //
        make_unique<SubscribeAttributeColorControlColorMode>(), //
        make_unique<ReadColorControlColorControlOptions>(), //
        make_unique<WriteColorControlColorControlOptions>(), //
        make_unique<SubscribeAttributeColorControlColorControlOptions>(), //
        make_unique<ReadColorControlNumberOfPrimaries>(), //
        make_unique<SubscribeAttributeColorControlNumberOfPrimaries>(), //
        make_unique<ReadColorControlPrimary1X>(), //
        make_unique<SubscribeAttributeColorControlPrimary1X>(), //
        make_unique<ReadColorControlPrimary1Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary1Y>(), //
        make_unique<ReadColorControlPrimary1Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary1Intensity>(), //
        make_unique<ReadColorControlPrimary2X>(), //
        make_unique<SubscribeAttributeColorControlPrimary2X>(), //
        make_unique<ReadColorControlPrimary2Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary2Y>(), //
        make_unique<ReadColorControlPrimary2Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary2Intensity>(), //
        make_unique<ReadColorControlPrimary3X>(), //
        make_unique<SubscribeAttributeColorControlPrimary3X>(), //
        make_unique<ReadColorControlPrimary3Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary3Y>(), //
        make_unique<ReadColorControlPrimary3Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary3Intensity>(), //
        make_unique<ReadColorControlPrimary4X>(), //
        make_unique<SubscribeAttributeColorControlPrimary4X>(), //
        make_unique<ReadColorControlPrimary4Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary4Y>(), //
        make_unique<ReadColorControlPrimary4Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary4Intensity>(), //
        make_unique<ReadColorControlPrimary5X>(), //
        make_unique<SubscribeAttributeColorControlPrimary5X>(), //
        make_unique<ReadColorControlPrimary5Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary5Y>(), //
        make_unique<ReadColorControlPrimary5Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary5Intensity>(), //
        make_unique<ReadColorControlPrimary6X>(), //
        make_unique<SubscribeAttributeColorControlPrimary6X>(), //
        make_unique<ReadColorControlPrimary6Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary6Y>(), //
        make_unique<ReadColorControlPrimary6Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary6Intensity>(), //
        make_unique<ReadColorControlWhitePointX>(), //
        make_unique<WriteColorControlWhitePointX>(), //
        make_unique<SubscribeAttributeColorControlWhitePointX>(), //
        make_unique<ReadColorControlWhitePointY>(), //
        make_unique<WriteColorControlWhitePointY>(), //
        make_unique<SubscribeAttributeColorControlWhitePointY>(), //
        make_unique<ReadColorControlColorPointRX>(), //
        make_unique<WriteColorControlColorPointRX>(), //
        make_unique<SubscribeAttributeColorControlColorPointRX>(), //
        make_unique<ReadColorControlColorPointRY>(), //
        make_unique<WriteColorControlColorPointRY>(), //
        make_unique<SubscribeAttributeColorControlColorPointRY>(), //
        make_unique<ReadColorControlColorPointRIntensity>(), //
        make_unique<WriteColorControlColorPointRIntensity>(), //
        make_unique<SubscribeAttributeColorControlColorPointRIntensity>(), //
        make_unique<ReadColorControlColorPointGX>(), //
        make_unique<WriteColorControlColorPointGX>(), //
        make_unique<SubscribeAttributeColorControlColorPointGX>(), //
        make_unique<ReadColorControlColorPointGY>(), //
        make_unique<WriteColorControlColorPointGY>(), //
        make_unique<SubscribeAttributeColorControlColorPointGY>(), //
        make_unique<ReadColorControlColorPointGIntensity>(), //
        make_unique<WriteColorControlColorPointGIntensity>(), //
        make_unique<SubscribeAttributeColorControlColorPointGIntensity>(), //
        make_unique<ReadColorControlColorPointBX>(), //
        make_unique<WriteColorControlColorPointBX>(), //
        make_unique<SubscribeAttributeColorControlColorPointBX>(), //
        make_unique<ReadColorControlColorPointBY>(), //
        make_unique<WriteColorControlColorPointBY>(), //
        make_unique<SubscribeAttributeColorControlColorPointBY>(), //
        make_unique<ReadColorControlColorPointBIntensity>(), //
        make_unique<WriteColorControlColorPointBIntensity>(), //
        make_unique<SubscribeAttributeColorControlColorPointBIntensity>(), //
        make_unique<ReadColorControlEnhancedCurrentHue>(), //
        make_unique<SubscribeAttributeColorControlEnhancedCurrentHue>(), //
        make_unique<ReadColorControlEnhancedColorMode>(), //
        make_unique<SubscribeAttributeColorControlEnhancedColorMode>(), //
        make_unique<ReadColorControlColorLoopActive>(), //
        make_unique<SubscribeAttributeColorControlColorLoopActive>(), //
        make_unique<ReadColorControlColorLoopDirection>(), //
        make_unique<SubscribeAttributeColorControlColorLoopDirection>(), //
        make_unique<ReadColorControlColorLoopTime>(), //
        make_unique<SubscribeAttributeColorControlColorLoopTime>(), //
        make_unique<ReadColorControlColorLoopStartEnhancedHue>(), //
        make_unique<SubscribeAttributeColorControlColorLoopStartEnhancedHue>(), //
        make_unique<ReadColorControlColorLoopStoredEnhancedHue>(), //
        make_unique<SubscribeAttributeColorControlColorLoopStoredEnhancedHue>(), //
        make_unique<ReadColorControlColorCapabilities>(), //
        make_unique<SubscribeAttributeColorControlColorCapabilities>(), //
        make_unique<ReadColorControlColorTempPhysicalMin>(), //
        make_unique<SubscribeAttributeColorControlColorTempPhysicalMin>(), //
        make_unique<ReadColorControlColorTempPhysicalMax>(), //
        make_unique<SubscribeAttributeColorControlColorTempPhysicalMax>(), //
        make_unique<ReadColorControlCoupleColorTempToLevelMinMireds>(), //
        make_unique<SubscribeAttributeColorControlCoupleColorTempToLevelMinMireds>(), //
        make_unique<ReadColorControlStartUpColorTemperatureMireds>(), //
        make_unique<WriteColorControlStartUpColorTemperatureMireds>(), //
        make_unique<SubscribeAttributeColorControlStartUpColorTemperatureMireds>(), //
        make_unique<ReadColorControlGeneratedCommandList>(), //
        make_unique<SubscribeAttributeColorControlGeneratedCommandList>(), //
        make_unique<ReadColorControlAcceptedCommandList>(), //
        make_unique<SubscribeAttributeColorControlAcceptedCommandList>(), //
        make_unique<ReadColorControlAttributeList>(), //
        make_unique<SubscribeAttributeColorControlAttributeList>(), //
        make_unique<ReadColorControlClusterRevision>(), //
        make_unique<SubscribeAttributeColorControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterContentLauncher(Commands & commands)
{
    const char * clusterName = "ContentLauncher";

    commands_list clusterCommands = {
        make_unique<ContentLauncherLaunchContent>(), //
        make_unique<ContentLauncherLaunchURL>(), //
        make_unique<ReadContentLauncherAcceptHeader>(), //
        make_unique<SubscribeAttributeContentLauncherAcceptHeader>(), //
        make_unique<ReadContentLauncherSupportedStreamingProtocols>(), //
        make_unique<WriteContentLauncherSupportedStreamingProtocols>(), //
        make_unique<SubscribeAttributeContentLauncherSupportedStreamingProtocols>(), //
        make_unique<ReadContentLauncherGeneratedCommandList>(), //
        make_unique<SubscribeAttributeContentLauncherGeneratedCommandList>(), //
        make_unique<ReadContentLauncherAcceptedCommandList>(), //
        make_unique<SubscribeAttributeContentLauncherAcceptedCommandList>(), //
        make_unique<ReadContentLauncherAttributeList>(), //
        make_unique<SubscribeAttributeContentLauncherAttributeList>(), //
        make_unique<ReadContentLauncherClusterRevision>(), //
        make_unique<SubscribeAttributeContentLauncherClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDescriptor(Commands & commands)
{
    const char * clusterName = "Descriptor";

    commands_list clusterCommands = {
        make_unique<ReadDescriptorDeviceList>(), //
        make_unique<SubscribeAttributeDescriptorDeviceList>(), //
        make_unique<ReadDescriptorServerList>(), //
        make_unique<SubscribeAttributeDescriptorServerList>(), //
        make_unique<ReadDescriptorClientList>(), //
        make_unique<SubscribeAttributeDescriptorClientList>(), //
        make_unique<ReadDescriptorPartsList>(), //
        make_unique<SubscribeAttributeDescriptorPartsList>(), //
        make_unique<ReadDescriptorGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDescriptorGeneratedCommandList>(), //
        make_unique<ReadDescriptorAcceptedCommandList>(), //
        make_unique<SubscribeAttributeDescriptorAcceptedCommandList>(), //
        make_unique<ReadDescriptorAttributeList>(), //
        make_unique<SubscribeAttributeDescriptorAttributeList>(), //
        make_unique<ReadDescriptorClusterRevision>(), //
        make_unique<SubscribeAttributeDescriptorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDiagnosticLogs(Commands & commands)
{
    const char * clusterName = "DiagnosticLogs";

    commands_list clusterCommands = {
        make_unique<DiagnosticLogsRetrieveLogsRequest>(), //
        make_unique<ReadDiagnosticLogsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDiagnosticLogsGeneratedCommandList>(), //
        make_unique<ReadDiagnosticLogsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeDiagnosticLogsAcceptedCommandList>(), //
        make_unique<ReadDiagnosticLogsAttributeList>(), //
        make_unique<SubscribeAttributeDiagnosticLogsAttributeList>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDoorLock(Commands & commands)
{
    const char * clusterName = "DoorLock";

    commands_list clusterCommands = {
        make_unique<DoorLockClearCredential>(), //
        make_unique<DoorLockClearHolidaySchedule>(), //
        make_unique<DoorLockClearUser>(), //
        make_unique<DoorLockClearWeekDaySchedule>(), //
        make_unique<DoorLockClearYearDaySchedule>(), //
        make_unique<DoorLockGetCredentialStatus>(), //
        make_unique<DoorLockGetHolidaySchedule>(), //
        make_unique<DoorLockGetUser>(), //
        make_unique<DoorLockGetWeekDaySchedule>(), //
        make_unique<DoorLockGetYearDaySchedule>(), //
        make_unique<DoorLockLockDoor>(), //
        make_unique<DoorLockSetCredential>(), //
        make_unique<DoorLockSetHolidaySchedule>(), //
        make_unique<DoorLockSetUser>(), //
        make_unique<DoorLockSetWeekDaySchedule>(), //
        make_unique<DoorLockSetYearDaySchedule>(), //
        make_unique<DoorLockUnlockDoor>(), //
        make_unique<DoorLockUnlockWithTimeout>(), //
        make_unique<ReadDoorLockLockState>(), //
        make_unique<SubscribeAttributeDoorLockLockState>(), //
        make_unique<ReadDoorLockLockType>(), //
        make_unique<SubscribeAttributeDoorLockLockType>(), //
        make_unique<ReadDoorLockActuatorEnabled>(), //
        make_unique<SubscribeAttributeDoorLockActuatorEnabled>(), //
        make_unique<ReadDoorLockDoorState>(), //
        make_unique<SubscribeAttributeDoorLockDoorState>(), //
        make_unique<ReadDoorLockNumberOfTotalUsersSupported>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfTotalUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfPINUsersSupported>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfPINUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfRFIDUsersSupported>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfRFIDUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfWeekDaySchedulesSupportedPerUser>(), //
        make_unique<ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfYearDaySchedulesSupportedPerUser>(), //
        make_unique<ReadDoorLockNumberOfHolidaySchedulesSupported>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfHolidaySchedulesSupported>(), //
        make_unique<ReadDoorLockMaxPINCodeLength>(), //
        make_unique<SubscribeAttributeDoorLockMaxPINCodeLength>(), //
        make_unique<ReadDoorLockMinPINCodeLength>(), //
        make_unique<SubscribeAttributeDoorLockMinPINCodeLength>(), //
        make_unique<ReadDoorLockMaxRFIDCodeLength>(), //
        make_unique<SubscribeAttributeDoorLockMaxRFIDCodeLength>(), //
        make_unique<ReadDoorLockMinRFIDCodeLength>(), //
        make_unique<SubscribeAttributeDoorLockMinRFIDCodeLength>(), //
        make_unique<ReadDoorLockLanguage>(), //
        make_unique<WriteDoorLockLanguage>(), //
        make_unique<SubscribeAttributeDoorLockLanguage>(), //
        make_unique<ReadDoorLockAutoRelockTime>(), //
        make_unique<WriteDoorLockAutoRelockTime>(), //
        make_unique<SubscribeAttributeDoorLockAutoRelockTime>(), //
        make_unique<ReadDoorLockSoundVolume>(), //
        make_unique<WriteDoorLockSoundVolume>(), //
        make_unique<SubscribeAttributeDoorLockSoundVolume>(), //
        make_unique<ReadDoorLockOperatingMode>(), //
        make_unique<WriteDoorLockOperatingMode>(), //
        make_unique<SubscribeAttributeDoorLockOperatingMode>(), //
        make_unique<ReadDoorLockSupportedOperatingModes>(), //
        make_unique<SubscribeAttributeDoorLockSupportedOperatingModes>(), //
        make_unique<ReadDoorLockEnableOneTouchLocking>(), //
        make_unique<WriteDoorLockEnableOneTouchLocking>(), //
        make_unique<SubscribeAttributeDoorLockEnableOneTouchLocking>(), //
        make_unique<ReadDoorLockEnablePrivacyModeButton>(), //
        make_unique<WriteDoorLockEnablePrivacyModeButton>(), //
        make_unique<SubscribeAttributeDoorLockEnablePrivacyModeButton>(), //
        make_unique<ReadDoorLockWrongCodeEntryLimit>(), //
        make_unique<WriteDoorLockWrongCodeEntryLimit>(), //
        make_unique<SubscribeAttributeDoorLockWrongCodeEntryLimit>(), //
        make_unique<ReadDoorLockUserCodeTemporaryDisableTime>(), //
        make_unique<WriteDoorLockUserCodeTemporaryDisableTime>(), //
        make_unique<SubscribeAttributeDoorLockUserCodeTemporaryDisableTime>(), //
        make_unique<ReadDoorLockRequirePINforRemoteOperation>(), //
        make_unique<WriteDoorLockRequirePINforRemoteOperation>(), //
        make_unique<ReadDoorLockGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDoorLockGeneratedCommandList>(), //
        make_unique<ReadDoorLockAcceptedCommandList>(), //
        make_unique<SubscribeAttributeDoorLockAcceptedCommandList>(), //
        make_unique<ReadDoorLockAttributeList>(), //
        make_unique<SubscribeAttributeDoorLockAttributeList>(), //
        make_unique<ReadDoorLockClusterRevision>(), //
        make_unique<SubscribeAttributeDoorLockClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterElectricalMeasurement(Commands & commands)
{
    const char * clusterName = "ElectricalMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadElectricalMeasurementMeasurementType>(), //
        make_unique<SubscribeAttributeElectricalMeasurementMeasurementType>(), //
        make_unique<ReadElectricalMeasurementTotalActivePower>(), //
        make_unique<SubscribeAttributeElectricalMeasurementTotalActivePower>(), //
        make_unique<ReadElectricalMeasurementRmsVoltage>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsVoltage>(), //
        make_unique<ReadElectricalMeasurementRmsVoltageMin>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsVoltageMin>(), //
        make_unique<ReadElectricalMeasurementRmsVoltageMax>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsVoltageMax>(), //
        make_unique<ReadElectricalMeasurementRmsCurrent>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsCurrent>(), //
        make_unique<ReadElectricalMeasurementRmsCurrentMin>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsCurrentMin>(), //
        make_unique<ReadElectricalMeasurementRmsCurrentMax>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsCurrentMax>(), //
        make_unique<ReadElectricalMeasurementActivePower>(), //
        make_unique<SubscribeAttributeElectricalMeasurementActivePower>(), //
        make_unique<ReadElectricalMeasurementActivePowerMin>(), //
        make_unique<SubscribeAttributeElectricalMeasurementActivePowerMin>(), //
        make_unique<ReadElectricalMeasurementActivePowerMax>(), //
        make_unique<SubscribeAttributeElectricalMeasurementActivePowerMax>(), //
        make_unique<ReadElectricalMeasurementGeneratedCommandList>(), //
        make_unique<SubscribeAttributeElectricalMeasurementGeneratedCommandList>(), //
        make_unique<ReadElectricalMeasurementAcceptedCommandList>(), //
        make_unique<SubscribeAttributeElectricalMeasurementAcceptedCommandList>(), //
        make_unique<ReadElectricalMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeElectricalMeasurementAttributeList>(), //
        make_unique<ReadElectricalMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeElectricalMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterEthernetNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "EthernetNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<EthernetNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPHYRate>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsPHYRate>(), //
        make_unique<ReadEthernetNetworkDiagnosticsFullDuplex>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsFullDuplex>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPacketRxCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsPacketRxCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPacketTxCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsPacketTxCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsTxErrCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsTxErrCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsCollisionCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsCollisionCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsOverrunCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsCarrierDetect>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsCarrierDetect>(), //
        make_unique<ReadEthernetNetworkDiagnosticsTimeSinceReset>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsTimeSinceReset>(), //
        make_unique<ReadEthernetNetworkDiagnosticsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsGeneratedCommandList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsAcceptedCommandList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsFeatureMap>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadEthernetNetworkDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFanControl(Commands & commands)
{
    const char * clusterName = "FanControl";

    commands_list clusterCommands = {
        make_unique<ReadFanControlFanMode>(), //
        make_unique<WriteFanControlFanMode>(), //
        make_unique<SubscribeAttributeFanControlFanMode>(), //
        make_unique<ReadFanControlFanModeSequence>(), //
        make_unique<WriteFanControlFanModeSequence>(), //
        make_unique<SubscribeAttributeFanControlFanModeSequence>(), //
        make_unique<ReadFanControlPercentSetting>(), //
        make_unique<WriteFanControlPercentSetting>(), //
        make_unique<SubscribeAttributeFanControlPercentSetting>(), //
        make_unique<ReadFanControlPercentCurrent>(), //
        make_unique<SubscribeAttributeFanControlPercentCurrent>(), //
        make_unique<ReadFanControlSpeedMax>(), //
        make_unique<SubscribeAttributeFanControlSpeedMax>(), //
        make_unique<ReadFanControlSpeedSetting>(), //
        make_unique<WriteFanControlSpeedSetting>(), //
        make_unique<SubscribeAttributeFanControlSpeedSetting>(), //
        make_unique<ReadFanControlSpeedCurrent>(), //
        make_unique<SubscribeAttributeFanControlSpeedCurrent>(), //
        make_unique<ReadFanControlRockSupport>(), //
        make_unique<SubscribeAttributeFanControlRockSupport>(), //
        make_unique<ReadFanControlRockSetting>(), //
        make_unique<WriteFanControlRockSetting>(), //
        make_unique<SubscribeAttributeFanControlRockSetting>(), //
        make_unique<ReadFanControlWindSupport>(), //
        make_unique<SubscribeAttributeFanControlWindSupport>(), //
        make_unique<ReadFanControlWindSetting>(), //
        make_unique<WriteFanControlWindSetting>(), //
        make_unique<SubscribeAttributeFanControlWindSetting>(), //
        make_unique<ReadFanControlGeneratedCommandList>(), //
        make_unique<SubscribeAttributeFanControlGeneratedCommandList>(), //
        make_unique<ReadFanControlAcceptedCommandList>(), //
        make_unique<SubscribeAttributeFanControlAcceptedCommandList>(), //
        make_unique<ReadFanControlAttributeList>(), //
        make_unique<SubscribeAttributeFanControlAttributeList>(), //
        make_unique<ReadFanControlFeatureMap>(), //
        make_unique<SubscribeAttributeFanControlFeatureMap>(), //
        make_unique<ReadFanControlClusterRevision>(), //
        make_unique<SubscribeAttributeFanControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFixedLabel(Commands & commands)
{
    const char * clusterName = "FixedLabel";

    commands_list clusterCommands = {
        make_unique<ReadFixedLabelLabelList>(), //
        make_unique<SubscribeAttributeFixedLabelLabelList>(), //
        make_unique<ReadFixedLabelGeneratedCommandList>(), //
        make_unique<SubscribeAttributeFixedLabelGeneratedCommandList>(), //
        make_unique<ReadFixedLabelAcceptedCommandList>(), //
        make_unique<SubscribeAttributeFixedLabelAcceptedCommandList>(), //
        make_unique<ReadFixedLabelAttributeList>(), //
        make_unique<SubscribeAttributeFixedLabelAttributeList>(), //
        make_unique<ReadFixedLabelClusterRevision>(), //
        make_unique<SubscribeAttributeFixedLabelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFlowMeasurement(Commands & commands)
{
    const char * clusterName = "FlowMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadFlowMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributeFlowMeasurementMeasuredValue>(), //
        make_unique<ReadFlowMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributeFlowMeasurementMinMeasuredValue>(), //
        make_unique<ReadFlowMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributeFlowMeasurementMaxMeasuredValue>(), //
        make_unique<ReadFlowMeasurementTolerance>(), //
        make_unique<SubscribeAttributeFlowMeasurementTolerance>(), //
        make_unique<ReadFlowMeasurementGeneratedCommandList>(), //
        make_unique<SubscribeAttributeFlowMeasurementGeneratedCommandList>(), //
        make_unique<ReadFlowMeasurementAcceptedCommandList>(), //
        make_unique<SubscribeAttributeFlowMeasurementAcceptedCommandList>(), //
        make_unique<ReadFlowMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeFlowMeasurementAttributeList>(), //
        make_unique<ReadFlowMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeFlowMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralCommissioning(Commands & commands)
{
    const char * clusterName = "GeneralCommissioning";

    commands_list clusterCommands = {
        make_unique<GeneralCommissioningArmFailSafe>(), //
        make_unique<GeneralCommissioningCommissioningComplete>(), //
        make_unique<GeneralCommissioningSetRegulatoryConfig>(), //
        make_unique<ReadGeneralCommissioningBreadcrumb>(), //
        make_unique<WriteGeneralCommissioningBreadcrumb>(), //
        make_unique<SubscribeAttributeGeneralCommissioningBreadcrumb>(), //
        make_unique<ReadGeneralCommissioningBasicCommissioningInfo>(), //
        make_unique<SubscribeAttributeGeneralCommissioningBasicCommissioningInfo>(), //
        make_unique<ReadGeneralCommissioningRegulatoryConfig>(), //
        make_unique<SubscribeAttributeGeneralCommissioningRegulatoryConfig>(), //
        make_unique<ReadGeneralCommissioningLocationCapability>(), //
        make_unique<SubscribeAttributeGeneralCommissioningLocationCapability>(), //
        make_unique<ReadGeneralCommissioningSupportsConcurrentConnection>(), //
        make_unique<SubscribeAttributeGeneralCommissioningSupportsConcurrentConnection>(), //
        make_unique<ReadGeneralCommissioningGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGeneralCommissioningGeneratedCommandList>(), //
        make_unique<ReadGeneralCommissioningAcceptedCommandList>(), //
        make_unique<SubscribeAttributeGeneralCommissioningAcceptedCommandList>(), //
        make_unique<ReadGeneralCommissioningAttributeList>(), //
        make_unique<SubscribeAttributeGeneralCommissioningAttributeList>(), //
        make_unique<ReadGeneralCommissioningClusterRevision>(), //
        make_unique<SubscribeAttributeGeneralCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralDiagnostics(Commands & commands)
{
    const char * clusterName = "GeneralDiagnostics";

    commands_list clusterCommands = {
        make_unique<ReadGeneralDiagnosticsNetworkInterfaces>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsNetworkInterfaces>(), //
        make_unique<ReadGeneralDiagnosticsRebootCount>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsRebootCount>(), //
        make_unique<ReadGeneralDiagnosticsUpTime>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsUpTime>(), //
        make_unique<ReadGeneralDiagnosticsTotalOperationalHours>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsTotalOperationalHours>(), //
        make_unique<ReadGeneralDiagnosticsBootReasons>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsBootReasons>(), //
        make_unique<ReadGeneralDiagnosticsActiveHardwareFaults>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsActiveHardwareFaults>(), //
        make_unique<ReadGeneralDiagnosticsActiveRadioFaults>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsActiveRadioFaults>(), //
        make_unique<ReadGeneralDiagnosticsActiveNetworkFaults>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsActiveNetworkFaults>(), //
        make_unique<ReadGeneralDiagnosticsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsGeneratedCommandList>(), //
        make_unique<ReadGeneralDiagnosticsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsAcceptedCommandList>(), //
        make_unique<ReadGeneralDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsAttributeList>(), //
        make_unique<ReadGeneralDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroupKeyManagement(Commands & commands)
{
    const char * clusterName = "GroupKeyManagement";

    commands_list clusterCommands = {
        make_unique<GroupKeyManagementKeySetRead>(), //
        make_unique<GroupKeyManagementKeySetReadAllIndices>(), //
        make_unique<GroupKeyManagementKeySetRemove>(), //
        make_unique<GroupKeyManagementKeySetWrite>(), //
        make_unique<ReadGroupKeyManagementGroupKeyMap>(), //
        make_unique<WriteGroupKeyManagementGroupKeyMap>(), //
        make_unique<SubscribeAttributeGroupKeyManagementGroupKeyMap>(), //
        make_unique<ReadGroupKeyManagementGroupTable>(), //
        make_unique<SubscribeAttributeGroupKeyManagementGroupTable>(), //
        make_unique<ReadGroupKeyManagementMaxGroupsPerFabric>(), //
        make_unique<SubscribeAttributeGroupKeyManagementMaxGroupsPerFabric>(), //
        make_unique<ReadGroupKeyManagementMaxGroupKeysPerFabric>(), //
        make_unique<SubscribeAttributeGroupKeyManagementMaxGroupKeysPerFabric>(), //
        make_unique<ReadGroupKeyManagementGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGroupKeyManagementGeneratedCommandList>(), //
        make_unique<ReadGroupKeyManagementAcceptedCommandList>(), //
        make_unique<SubscribeAttributeGroupKeyManagementAcceptedCommandList>(), //
        make_unique<ReadGroupKeyManagementAttributeList>(), //
        make_unique<SubscribeAttributeGroupKeyManagementAttributeList>(), //
        make_unique<ReadGroupKeyManagementClusterRevision>(), //
        make_unique<SubscribeAttributeGroupKeyManagementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroups(Commands & commands)
{
    const char * clusterName = "Groups";

    commands_list clusterCommands = {
        make_unique<GroupsAddGroup>(), //
        make_unique<GroupsAddGroupIfIdentifying>(), //
        make_unique<GroupsGetGroupMembership>(), //
        make_unique<GroupsRemoveAllGroups>(), //
        make_unique<GroupsRemoveGroup>(), //
        make_unique<GroupsViewGroup>(), //
        make_unique<ReadGroupsNameSupport>(), //
        make_unique<SubscribeAttributeGroupsNameSupport>(), //
        make_unique<ReadGroupsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGroupsGeneratedCommandList>(), //
        make_unique<ReadGroupsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeGroupsAcceptedCommandList>(), //
        make_unique<ReadGroupsAttributeList>(), //
        make_unique<SubscribeAttributeGroupsAttributeList>(), //
        make_unique<ReadGroupsClusterRevision>(), //
        make_unique<SubscribeAttributeGroupsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIdentify(Commands & commands)
{
    const char * clusterName = "Identify";

    commands_list clusterCommands = {
        make_unique<IdentifyIdentify>(), //
        make_unique<IdentifyIdentifyQuery>(), //
        make_unique<IdentifyTriggerEffect>(), //
        make_unique<ReadIdentifyIdentifyTime>(), //
        make_unique<WriteIdentifyIdentifyTime>(), //
        make_unique<SubscribeAttributeIdentifyIdentifyTime>(), //
        make_unique<ReadIdentifyIdentifyType>(), //
        make_unique<SubscribeAttributeIdentifyIdentifyType>(), //
        make_unique<ReadIdentifyGeneratedCommandList>(), //
        make_unique<SubscribeAttributeIdentifyGeneratedCommandList>(), //
        make_unique<ReadIdentifyAcceptedCommandList>(), //
        make_unique<SubscribeAttributeIdentifyAcceptedCommandList>(), //
        make_unique<ReadIdentifyAttributeList>(), //
        make_unique<SubscribeAttributeIdentifyAttributeList>(), //
        make_unique<ReadIdentifyClusterRevision>(), //
        make_unique<SubscribeAttributeIdentifyClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIlluminanceMeasurement(Commands & commands)
{
    const char * clusterName = "IlluminanceMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadIlluminanceMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementMinMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementMaxMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementTolerance>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementTolerance>(), //
        make_unique<ReadIlluminanceMeasurementLightSensorType>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementLightSensorType>(), //
        make_unique<ReadIlluminanceMeasurementGeneratedCommandList>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementGeneratedCommandList>(), //
        make_unique<ReadIlluminanceMeasurementAcceptedCommandList>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementAcceptedCommandList>(), //
        make_unique<ReadIlluminanceMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementAttributeList>(), //
        make_unique<ReadIlluminanceMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterKeypadInput(Commands & commands)
{
    const char * clusterName = "KeypadInput";

    commands_list clusterCommands = {
        make_unique<KeypadInputSendKey>(), //
        make_unique<ReadKeypadInputGeneratedCommandList>(), //
        make_unique<SubscribeAttributeKeypadInputGeneratedCommandList>(), //
        make_unique<ReadKeypadInputAcceptedCommandList>(), //
        make_unique<SubscribeAttributeKeypadInputAcceptedCommandList>(), //
        make_unique<ReadKeypadInputAttributeList>(), //
        make_unique<SubscribeAttributeKeypadInputAttributeList>(), //
        make_unique<ReadKeypadInputClusterRevision>(), //
        make_unique<SubscribeAttributeKeypadInputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLevelControl(Commands & commands)
{
    const char * clusterName = "LevelControl";

    commands_list clusterCommands = {
        make_unique<LevelControlMove>(), //
        make_unique<LevelControlMoveToLevel>(), //
        make_unique<LevelControlMoveToLevelWithOnOff>(), //
        make_unique<LevelControlMoveWithOnOff>(), //
        make_unique<LevelControlStep>(), //
        make_unique<LevelControlStepWithOnOff>(), //
        make_unique<LevelControlStop>(), //
        make_unique<LevelControlStopWithOnOff>(), //
        make_unique<ReadLevelControlCurrentLevel>(), //
        make_unique<SubscribeAttributeLevelControlCurrentLevel>(), //
        make_unique<ReadLevelControlRemainingTime>(), //
        make_unique<SubscribeAttributeLevelControlRemainingTime>(), //
        make_unique<ReadLevelControlMinLevel>(), //
        make_unique<SubscribeAttributeLevelControlMinLevel>(), //
        make_unique<ReadLevelControlMaxLevel>(), //
        make_unique<SubscribeAttributeLevelControlMaxLevel>(), //
        make_unique<ReadLevelControlCurrentFrequency>(), //
        make_unique<SubscribeAttributeLevelControlCurrentFrequency>(), //
        make_unique<ReadLevelControlMinFrequency>(), //
        make_unique<SubscribeAttributeLevelControlMinFrequency>(), //
        make_unique<ReadLevelControlMaxFrequency>(), //
        make_unique<SubscribeAttributeLevelControlMaxFrequency>(), //
        make_unique<ReadLevelControlOptions>(), //
        make_unique<WriteLevelControlOptions>(), //
        make_unique<SubscribeAttributeLevelControlOptions>(), //
        make_unique<ReadLevelControlOnOffTransitionTime>(), //
        make_unique<WriteLevelControlOnOffTransitionTime>(), //
        make_unique<SubscribeAttributeLevelControlOnOffTransitionTime>(), //
        make_unique<ReadLevelControlOnLevel>(), //
        make_unique<WriteLevelControlOnLevel>(), //
        make_unique<SubscribeAttributeLevelControlOnLevel>(), //
        make_unique<ReadLevelControlOnTransitionTime>(), //
        make_unique<WriteLevelControlOnTransitionTime>(), //
        make_unique<SubscribeAttributeLevelControlOnTransitionTime>(), //
        make_unique<ReadLevelControlOffTransitionTime>(), //
        make_unique<WriteLevelControlOffTransitionTime>(), //
        make_unique<SubscribeAttributeLevelControlOffTransitionTime>(), //
        make_unique<ReadLevelControlDefaultMoveRate>(), //
        make_unique<WriteLevelControlDefaultMoveRate>(), //
        make_unique<SubscribeAttributeLevelControlDefaultMoveRate>(), //
        make_unique<ReadLevelControlStartUpCurrentLevel>(), //
        make_unique<WriteLevelControlStartUpCurrentLevel>(), //
        make_unique<SubscribeAttributeLevelControlStartUpCurrentLevel>(), //
        make_unique<ReadLevelControlGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLevelControlGeneratedCommandList>(), //
        make_unique<ReadLevelControlAcceptedCommandList>(), //
        make_unique<SubscribeAttributeLevelControlAcceptedCommandList>(), //
        make_unique<ReadLevelControlAttributeList>(), //
        make_unique<SubscribeAttributeLevelControlAttributeList>(), //
        make_unique<ReadLevelControlFeatureMap>(), //
        make_unique<SubscribeAttributeLevelControlFeatureMap>(), //
        make_unique<ReadLevelControlClusterRevision>(), //
        make_unique<SubscribeAttributeLevelControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLocalizationConfiguration(Commands & commands)
{
    const char * clusterName = "LocalizationConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadLocalizationConfigurationActiveLocale>(), //
        make_unique<WriteLocalizationConfigurationActiveLocale>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationActiveLocale>(), //
        make_unique<ReadLocalizationConfigurationSupportedLocales>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationSupportedLocales>(), //
        make_unique<ReadLocalizationConfigurationGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationGeneratedCommandList>(), //
        make_unique<ReadLocalizationConfigurationAcceptedCommandList>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationAcceptedCommandList>(), //
        make_unique<ReadLocalizationConfigurationClusterRevision>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLowPower(Commands & commands)
{
    const char * clusterName = "LowPower";

    commands_list clusterCommands = {
        make_unique<LowPowerSleep>(), //
        make_unique<ReadLowPowerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLowPowerGeneratedCommandList>(), //
        make_unique<ReadLowPowerAcceptedCommandList>(), //
        make_unique<SubscribeAttributeLowPowerAcceptedCommandList>(), //
        make_unique<ReadLowPowerAttributeList>(), //
        make_unique<SubscribeAttributeLowPowerAttributeList>(), //
        make_unique<ReadLowPowerClusterRevision>(), //
        make_unique<SubscribeAttributeLowPowerClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaInput(Commands & commands)
{
    const char * clusterName = "MediaInput";

    commands_list clusterCommands = {
        make_unique<MediaInputHideInputStatus>(), //
        make_unique<MediaInputRenameInput>(), //
        make_unique<MediaInputSelectInput>(), //
        make_unique<MediaInputShowInputStatus>(), //
        make_unique<ReadMediaInputInputList>(), //
        make_unique<SubscribeAttributeMediaInputInputList>(), //
        make_unique<ReadMediaInputCurrentInput>(), //
        make_unique<SubscribeAttributeMediaInputCurrentInput>(), //
        make_unique<ReadMediaInputGeneratedCommandList>(), //
        make_unique<SubscribeAttributeMediaInputGeneratedCommandList>(), //
        make_unique<ReadMediaInputAcceptedCommandList>(), //
        make_unique<SubscribeAttributeMediaInputAcceptedCommandList>(), //
        make_unique<ReadMediaInputAttributeList>(), //
        make_unique<SubscribeAttributeMediaInputAttributeList>(), //
        make_unique<ReadMediaInputClusterRevision>(), //
        make_unique<SubscribeAttributeMediaInputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaPlayback(Commands & commands)
{
    const char * clusterName = "MediaPlayback";

    commands_list clusterCommands = {
        make_unique<MediaPlaybackFastForward>(), //
        make_unique<MediaPlaybackNext>(), //
        make_unique<MediaPlaybackPause>(), //
        make_unique<MediaPlaybackPlay>(), //
        make_unique<MediaPlaybackPrevious>(), //
        make_unique<MediaPlaybackRewind>(), //
        make_unique<MediaPlaybackSeek>(), //
        make_unique<MediaPlaybackSkipBackward>(), //
        make_unique<MediaPlaybackSkipForward>(), //
        make_unique<MediaPlaybackStartOver>(), //
        make_unique<MediaPlaybackStopPlayback>(), //
        make_unique<ReadMediaPlaybackCurrentState>(), //
        make_unique<SubscribeAttributeMediaPlaybackCurrentState>(), //
        make_unique<ReadMediaPlaybackStartTime>(), //
        make_unique<SubscribeAttributeMediaPlaybackStartTime>(), //
        make_unique<ReadMediaPlaybackDuration>(), //
        make_unique<SubscribeAttributeMediaPlaybackDuration>(), //
        make_unique<ReadMediaPlaybackSampledPosition>(), //
        make_unique<SubscribeAttributeMediaPlaybackSampledPosition>(), //
        make_unique<ReadMediaPlaybackPlaybackSpeed>(), //
        make_unique<SubscribeAttributeMediaPlaybackPlaybackSpeed>(), //
        make_unique<ReadMediaPlaybackSeekRangeEnd>(), //
        make_unique<SubscribeAttributeMediaPlaybackSeekRangeEnd>(), //
        make_unique<ReadMediaPlaybackSeekRangeStart>(), //
        make_unique<SubscribeAttributeMediaPlaybackSeekRangeStart>(), //
        make_unique<ReadMediaPlaybackGeneratedCommandList>(), //
        make_unique<SubscribeAttributeMediaPlaybackGeneratedCommandList>(), //
        make_unique<ReadMediaPlaybackAcceptedCommandList>(), //
        make_unique<SubscribeAttributeMediaPlaybackAcceptedCommandList>(), //
        make_unique<ReadMediaPlaybackAttributeList>(), //
        make_unique<SubscribeAttributeMediaPlaybackAttributeList>(), //
        make_unique<ReadMediaPlaybackClusterRevision>(), //
        make_unique<SubscribeAttributeMediaPlaybackClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterModeSelect(Commands & commands)
{
    const char * clusterName = "ModeSelect";

    commands_list clusterCommands = {
        make_unique<ModeSelectChangeToMode>(), //
        make_unique<ReadModeSelectDescription>(), //
        make_unique<SubscribeAttributeModeSelectDescription>(), //
        make_unique<ReadModeSelectStandardNamespace>(), //
        make_unique<SubscribeAttributeModeSelectStandardNamespace>(), //
        make_unique<ReadModeSelectSupportedModes>(), //
        make_unique<SubscribeAttributeModeSelectSupportedModes>(), //
        make_unique<ReadModeSelectCurrentMode>(), //
        make_unique<SubscribeAttributeModeSelectCurrentMode>(), //
        make_unique<ReadModeSelectStartUpMode>(), //
        make_unique<WriteModeSelectStartUpMode>(), //
        make_unique<SubscribeAttributeModeSelectStartUpMode>(), //
        make_unique<ReadModeSelectOnMode>(), //
        make_unique<WriteModeSelectOnMode>(), //
        make_unique<SubscribeAttributeModeSelectOnMode>(), //
        make_unique<ReadModeSelectGeneratedCommandList>(), //
        make_unique<SubscribeAttributeModeSelectGeneratedCommandList>(), //
        make_unique<ReadModeSelectAcceptedCommandList>(), //
        make_unique<SubscribeAttributeModeSelectAcceptedCommandList>(), //
        make_unique<ReadModeSelectAttributeList>(), //
        make_unique<SubscribeAttributeModeSelectAttributeList>(), //
        make_unique<ReadModeSelectFeatureMap>(), //
        make_unique<SubscribeAttributeModeSelectFeatureMap>(), //
        make_unique<ReadModeSelectClusterRevision>(), //
        make_unique<SubscribeAttributeModeSelectClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterNetworkCommissioning(Commands & commands)
{
    const char * clusterName = "NetworkCommissioning";

    commands_list clusterCommands = {
        make_unique<NetworkCommissioningAddOrUpdateThreadNetwork>(), //
        make_unique<NetworkCommissioningAddOrUpdateWiFiNetwork>(), //
        make_unique<NetworkCommissioningConnectNetwork>(), //
        make_unique<NetworkCommissioningRemoveNetwork>(), //
        make_unique<NetworkCommissioningReorderNetwork>(), //
        make_unique<NetworkCommissioningScanNetworks>(), //
        make_unique<ReadNetworkCommissioningMaxNetworks>(), //
        make_unique<SubscribeAttributeNetworkCommissioningMaxNetworks>(), //
        make_unique<ReadNetworkCommissioningNetworks>(), //
        make_unique<SubscribeAttributeNetworkCommissioningNetworks>(), //
        make_unique<ReadNetworkCommissioningScanMaxTimeSeconds>(), //
        make_unique<SubscribeAttributeNetworkCommissioningScanMaxTimeSeconds>(), //
        make_unique<ReadNetworkCommissioningConnectMaxTimeSeconds>(), //
        make_unique<SubscribeAttributeNetworkCommissioningConnectMaxTimeSeconds>(), //
        make_unique<ReadNetworkCommissioningInterfaceEnabled>(), //
        make_unique<WriteNetworkCommissioningInterfaceEnabled>(), //
        make_unique<SubscribeAttributeNetworkCommissioningInterfaceEnabled>(), //
        make_unique<ReadNetworkCommissioningLastNetworkingStatus>(), //
        make_unique<SubscribeAttributeNetworkCommissioningLastNetworkingStatus>(), //
        make_unique<ReadNetworkCommissioningLastNetworkID>(), //
        make_unique<SubscribeAttributeNetworkCommissioningLastNetworkID>(), //
        make_unique<ReadNetworkCommissioningLastConnectErrorValue>(), //
        make_unique<SubscribeAttributeNetworkCommissioningLastConnectErrorValue>(), //
        make_unique<ReadNetworkCommissioningGeneratedCommandList>(), //
        make_unique<SubscribeAttributeNetworkCommissioningGeneratedCommandList>(), //
        make_unique<ReadNetworkCommissioningAcceptedCommandList>(), //
        make_unique<SubscribeAttributeNetworkCommissioningAcceptedCommandList>(), //
        make_unique<ReadNetworkCommissioningFeatureMap>(), //
        make_unique<SubscribeAttributeNetworkCommissioningFeatureMap>(), //
        make_unique<ReadNetworkCommissioningClusterRevision>(), //
        make_unique<SubscribeAttributeNetworkCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateProvider(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateProvider";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateProviderApplyUpdateRequest>(), //
        make_unique<OtaSoftwareUpdateProviderNotifyUpdateApplied>(), //
        make_unique<OtaSoftwareUpdateProviderQueryImage>(), //
        make_unique<ReadOtaSoftwareUpdateProviderAttributeList>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateProviderAttributeList>(), //
        make_unique<ReadOtaSoftwareUpdateProviderClusterRevision>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateProviderClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateRequestor(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateRequestor";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateRequestorAnnounceOtaProvider>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorDefaultOtaProviders>(), //
        make_unique<WriteOtaSoftwareUpdateRequestorDefaultOtaProviders>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorDefaultOtaProviders>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdatePossible>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorUpdatePossible>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdateState>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorUpdateState>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdateStateProgress>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorUpdateStateProgress>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorAttributeList>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorAttributeList>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorClusterRevision>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOccupancySensing(Commands & commands)
{
    const char * clusterName = "OccupancySensing";

    commands_list clusterCommands = {
        make_unique<ReadOccupancySensingOccupancy>(), //
        make_unique<SubscribeAttributeOccupancySensingOccupancy>(), //
        make_unique<ReadOccupancySensingOccupancySensorType>(), //
        make_unique<SubscribeAttributeOccupancySensingOccupancySensorType>(), //
        make_unique<ReadOccupancySensingOccupancySensorTypeBitmap>(), //
        make_unique<SubscribeAttributeOccupancySensingOccupancySensorTypeBitmap>(), //
        make_unique<ReadOccupancySensingGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOccupancySensingGeneratedCommandList>(), //
        make_unique<ReadOccupancySensingAcceptedCommandList>(), //
        make_unique<SubscribeAttributeOccupancySensingAcceptedCommandList>(), //
        make_unique<ReadOccupancySensingAttributeList>(), //
        make_unique<SubscribeAttributeOccupancySensingAttributeList>(), //
        make_unique<ReadOccupancySensingClusterRevision>(), //
        make_unique<SubscribeAttributeOccupancySensingClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOff(Commands & commands)
{
    const char * clusterName = "OnOff";

    commands_list clusterCommands = {
        make_unique<OnOffOff>(), //
        make_unique<OnOffOffWithEffect>(), //
        make_unique<OnOffOn>(), //
        make_unique<OnOffOnWithRecallGlobalScene>(), //
        make_unique<OnOffOnWithTimedOff>(), //
        make_unique<OnOffToggle>(), //
        make_unique<ReadOnOffOnOff>(), //
        make_unique<SubscribeAttributeOnOffOnOff>(), //
        make_unique<ReadOnOffGlobalSceneControl>(), //
        make_unique<SubscribeAttributeOnOffGlobalSceneControl>(), //
        make_unique<ReadOnOffOnTime>(), //
        make_unique<WriteOnOffOnTime>(), //
        make_unique<SubscribeAttributeOnOffOnTime>(), //
        make_unique<ReadOnOffOffWaitTime>(), //
        make_unique<WriteOnOffOffWaitTime>(), //
        make_unique<SubscribeAttributeOnOffOffWaitTime>(), //
        make_unique<ReadOnOffStartUpOnOff>(), //
        make_unique<WriteOnOffStartUpOnOff>(), //
        make_unique<SubscribeAttributeOnOffStartUpOnOff>(), //
        make_unique<ReadOnOffGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOnOffGeneratedCommandList>(), //
        make_unique<ReadOnOffAcceptedCommandList>(), //
        make_unique<SubscribeAttributeOnOffAcceptedCommandList>(), //
        make_unique<ReadOnOffAttributeList>(), //
        make_unique<SubscribeAttributeOnOffAttributeList>(), //
        make_unique<ReadOnOffFeatureMap>(), //
        make_unique<SubscribeAttributeOnOffFeatureMap>(), //
        make_unique<ReadOnOffClusterRevision>(), //
        make_unique<SubscribeAttributeOnOffClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOffSwitchConfiguration(Commands & commands)
{
    const char * clusterName = "OnOffSwitchConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadOnOffSwitchConfigurationSwitchType>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationSwitchType>(), //
        make_unique<ReadOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<WriteOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<ReadOnOffSwitchConfigurationGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationGeneratedCommandList>(), //
        make_unique<ReadOnOffSwitchConfigurationAcceptedCommandList>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationAcceptedCommandList>(), //
        make_unique<ReadOnOffSwitchConfigurationAttributeList>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationAttributeList>(), //
        make_unique<ReadOnOffSwitchConfigurationClusterRevision>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOperationalCredentials(Commands & commands)
{
    const char * clusterName = "OperationalCredentials";

    commands_list clusterCommands = {
        make_unique<OperationalCredentialsAddNOC>(), //
        make_unique<OperationalCredentialsAddTrustedRootCertificate>(), //
        make_unique<OperationalCredentialsAttestationRequest>(), //
        make_unique<OperationalCredentialsCSRRequest>(), //
        make_unique<OperationalCredentialsCertificateChainRequest>(), //
        make_unique<OperationalCredentialsRemoveFabric>(), //
        make_unique<OperationalCredentialsRemoveTrustedRootCertificate>(), //
        make_unique<OperationalCredentialsUpdateFabricLabel>(), //
        make_unique<OperationalCredentialsUpdateNOC>(), //
        make_unique<ReadOperationalCredentialsNOCs>(), //
        make_unique<SubscribeAttributeOperationalCredentialsNOCs>(), //
        make_unique<ReadOperationalCredentialsFabrics>(), //
        make_unique<SubscribeAttributeOperationalCredentialsFabrics>(), //
        make_unique<ReadOperationalCredentialsSupportedFabrics>(), //
        make_unique<SubscribeAttributeOperationalCredentialsSupportedFabrics>(), //
        make_unique<ReadOperationalCredentialsCommissionedFabrics>(), //
        make_unique<SubscribeAttributeOperationalCredentialsCommissionedFabrics>(), //
        make_unique<ReadOperationalCredentialsTrustedRootCertificates>(), //
        make_unique<SubscribeAttributeOperationalCredentialsTrustedRootCertificates>(), //
        make_unique<ReadOperationalCredentialsCurrentFabricIndex>(), //
        make_unique<SubscribeAttributeOperationalCredentialsCurrentFabricIndex>(), //
        make_unique<ReadOperationalCredentialsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOperationalCredentialsGeneratedCommandList>(), //
        make_unique<ReadOperationalCredentialsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeOperationalCredentialsAcceptedCommandList>(), //
        make_unique<ReadOperationalCredentialsAttributeList>(), //
        make_unique<SubscribeAttributeOperationalCredentialsAttributeList>(), //
        make_unique<ReadOperationalCredentialsClusterRevision>(), //
        make_unique<SubscribeAttributeOperationalCredentialsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSource(Commands & commands)
{
    const char * clusterName = "PowerSource";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceStatus>(), //
        make_unique<SubscribeAttributePowerSourceStatus>(), //
        make_unique<ReadPowerSourceOrder>(), //
        make_unique<SubscribeAttributePowerSourceOrder>(), //
        make_unique<ReadPowerSourceDescription>(), //
        make_unique<SubscribeAttributePowerSourceDescription>(), //
        make_unique<ReadPowerSourceBatteryVoltage>(), //
        make_unique<SubscribeAttributePowerSourceBatteryVoltage>(), //
        make_unique<ReadPowerSourceBatteryPercentRemaining>(), //
        make_unique<SubscribeAttributePowerSourceBatteryPercentRemaining>(), //
        make_unique<ReadPowerSourceBatteryTimeRemaining>(), //
        make_unique<SubscribeAttributePowerSourceBatteryTimeRemaining>(), //
        make_unique<ReadPowerSourceBatteryChargeLevel>(), //
        make_unique<SubscribeAttributePowerSourceBatteryChargeLevel>(), //
        make_unique<ReadPowerSourceActiveBatteryFaults>(), //
        make_unique<SubscribeAttributePowerSourceActiveBatteryFaults>(), //
        make_unique<ReadPowerSourceBatteryChargeState>(), //
        make_unique<SubscribeAttributePowerSourceBatteryChargeState>(), //
        make_unique<ReadPowerSourceGeneratedCommandList>(), //
        make_unique<SubscribeAttributePowerSourceGeneratedCommandList>(), //
        make_unique<ReadPowerSourceAcceptedCommandList>(), //
        make_unique<SubscribeAttributePowerSourceAcceptedCommandList>(), //
        make_unique<ReadPowerSourceAttributeList>(), //
        make_unique<SubscribeAttributePowerSourceAttributeList>(), //
        make_unique<ReadPowerSourceFeatureMap>(), //
        make_unique<SubscribeAttributePowerSourceFeatureMap>(), //
        make_unique<ReadPowerSourceClusterRevision>(), //
        make_unique<SubscribeAttributePowerSourceClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSourceConfiguration(Commands & commands)
{
    const char * clusterName = "PowerSourceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceConfigurationSources>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationSources>(), //
        make_unique<ReadPowerSourceConfigurationGeneratedCommandList>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationGeneratedCommandList>(), //
        make_unique<ReadPowerSourceConfigurationAcceptedCommandList>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationAcceptedCommandList>(), //
        make_unique<ReadPowerSourceConfigurationAttributeList>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationAttributeList>(), //
        make_unique<ReadPowerSourceConfigurationClusterRevision>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPressureMeasurement(Commands & commands)
{
    const char * clusterName = "PressureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadPressureMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributePressureMeasurementMeasuredValue>(), //
        make_unique<ReadPressureMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributePressureMeasurementMinMeasuredValue>(), //
        make_unique<ReadPressureMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributePressureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadPressureMeasurementAttributeList>(), //
        make_unique<SubscribeAttributePressureMeasurementAttributeList>(), //
        make_unique<ReadPressureMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributePressureMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPumpConfigurationAndControl(Commands & commands)
{
    const char * clusterName = "PumpConfigurationAndControl";

    commands_list clusterCommands = {
        make_unique<ReadPumpConfigurationAndControlMaxPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxSpeed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMaxFlow>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinConstPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxConstPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMinCompPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinCompPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxCompPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxCompPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstSpeed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinConstSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstSpeed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxConstSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstFlow>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinConstFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstFlow>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxConstFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstTemp>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinConstTemp>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstTemp>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxConstTemp>(), //
        make_unique<ReadPumpConfigurationAndControlPumpStatus>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlPumpStatus>(), //
        make_unique<ReadPumpConfigurationAndControlEffectiveOperationMode>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlEffectiveOperationMode>(), //
        make_unique<ReadPumpConfigurationAndControlEffectiveControlMode>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlEffectiveControlMode>(), //
        make_unique<ReadPumpConfigurationAndControlCapacity>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlCapacity>(), //
        make_unique<ReadPumpConfigurationAndControlSpeed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<WritePumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<ReadPumpConfigurationAndControlPower>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlPower>(), //
        make_unique<ReadPumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<WritePumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<ReadPumpConfigurationAndControlOperationMode>(), //
        make_unique<WritePumpConfigurationAndControlOperationMode>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlOperationMode>(), //
        make_unique<ReadPumpConfigurationAndControlControlMode>(), //
        make_unique<WritePumpConfigurationAndControlControlMode>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlControlMode>(), //
        make_unique<ReadPumpConfigurationAndControlAlarmMask>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlAlarmMask>(), //
        make_unique<ReadPumpConfigurationAndControlGeneratedCommandList>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlGeneratedCommandList>(), //
        make_unique<ReadPumpConfigurationAndControlAcceptedCommandList>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlAcceptedCommandList>(), //
        make_unique<ReadPumpConfigurationAndControlAttributeList>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlAttributeList>(), //
        make_unique<ReadPumpConfigurationAndControlFeatureMap>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlFeatureMap>(), //
        make_unique<ReadPumpConfigurationAndControlClusterRevision>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterRelativeHumidityMeasurement(Commands & commands)
{
    const char * clusterName = "RelativeHumidityMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadRelativeHumidityMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementMinMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementMaxMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementTolerance>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementTolerance>(), //
        make_unique<ReadRelativeHumidityMeasurementGeneratedCommandList>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementGeneratedCommandList>(), //
        make_unique<ReadRelativeHumidityMeasurementAcceptedCommandList>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementAcceptedCommandList>(), //
        make_unique<ReadRelativeHumidityMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementAttributeList>(), //
        make_unique<ReadRelativeHumidityMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterScenes(Commands & commands)
{
    const char * clusterName = "Scenes";

    commands_list clusterCommands = {
        make_unique<ScenesAddScene>(), //
        make_unique<ScenesGetSceneMembership>(), //
        make_unique<ScenesRecallScene>(), //
        make_unique<ScenesRemoveAllScenes>(), //
        make_unique<ScenesRemoveScene>(), //
        make_unique<ScenesStoreScene>(), //
        make_unique<ScenesViewScene>(), //
        make_unique<ReadScenesSceneCount>(), //
        make_unique<SubscribeAttributeScenesSceneCount>(), //
        make_unique<ReadScenesCurrentScene>(), //
        make_unique<SubscribeAttributeScenesCurrentScene>(), //
        make_unique<ReadScenesCurrentGroup>(), //
        make_unique<SubscribeAttributeScenesCurrentGroup>(), //
        make_unique<ReadScenesSceneValid>(), //
        make_unique<SubscribeAttributeScenesSceneValid>(), //
        make_unique<ReadScenesNameSupport>(), //
        make_unique<SubscribeAttributeScenesNameSupport>(), //
        make_unique<ReadScenesGeneratedCommandList>(), //
        make_unique<SubscribeAttributeScenesGeneratedCommandList>(), //
        make_unique<ReadScenesAcceptedCommandList>(), //
        make_unique<SubscribeAttributeScenesAcceptedCommandList>(), //
        make_unique<ReadScenesAttributeList>(), //
        make_unique<SubscribeAttributeScenesAttributeList>(), //
        make_unique<ReadScenesClusterRevision>(), //
        make_unique<SubscribeAttributeScenesClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSoftwareDiagnostics(Commands & commands)
{
    const char * clusterName = "SoftwareDiagnostics";

    commands_list clusterCommands = {
        make_unique<SoftwareDiagnosticsResetWatermarks>(), //
        make_unique<ReadSoftwareDiagnosticsThreadMetrics>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsThreadMetrics>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapFree>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsCurrentHeapFree>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapUsed>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsCurrentHeapUsed>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapHighWatermark>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsCurrentHeapHighWatermark>(), //
        make_unique<ReadSoftwareDiagnosticsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsGeneratedCommandList>(), //
        make_unique<ReadSoftwareDiagnosticsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsAcceptedCommandList>(), //
        make_unique<ReadSoftwareDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsAttributeList>(), //
        make_unique<ReadSoftwareDiagnosticsFeatureMap>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsFeatureMap>(), //
        make_unique<ReadSoftwareDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSwitch(Commands & commands)
{
    const char * clusterName = "Switch";

    commands_list clusterCommands = {
        make_unique<ReadSwitchNumberOfPositions>(), //
        make_unique<SubscribeAttributeSwitchNumberOfPositions>(), //
        make_unique<ReadSwitchCurrentPosition>(), //
        make_unique<SubscribeAttributeSwitchCurrentPosition>(), //
        make_unique<ReadSwitchMultiPressMax>(), //
        make_unique<SubscribeAttributeSwitchMultiPressMax>(), //
        make_unique<ReadSwitchGeneratedCommandList>(), //
        make_unique<SubscribeAttributeSwitchGeneratedCommandList>(), //
        make_unique<ReadSwitchAcceptedCommandList>(), //
        make_unique<SubscribeAttributeSwitchAcceptedCommandList>(), //
        make_unique<ReadSwitchAttributeList>(), //
        make_unique<SubscribeAttributeSwitchAttributeList>(), //
        make_unique<ReadSwitchFeatureMap>(), //
        make_unique<SubscribeAttributeSwitchFeatureMap>(), //
        make_unique<ReadSwitchClusterRevision>(), //
        make_unique<SubscribeAttributeSwitchClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTargetNavigator(Commands & commands)
{
    const char * clusterName = "TargetNavigator";

    commands_list clusterCommands = {
        make_unique<TargetNavigatorNavigateTarget>(), //
        make_unique<ReadTargetNavigatorTargetList>(), //
        make_unique<SubscribeAttributeTargetNavigatorTargetList>(), //
        make_unique<ReadTargetNavigatorCurrentTarget>(), //
        make_unique<SubscribeAttributeTargetNavigatorCurrentTarget>(), //
        make_unique<ReadTargetNavigatorGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTargetNavigatorGeneratedCommandList>(), //
        make_unique<ReadTargetNavigatorAcceptedCommandList>(), //
        make_unique<SubscribeAttributeTargetNavigatorAcceptedCommandList>(), //
        make_unique<ReadTargetNavigatorAttributeList>(), //
        make_unique<SubscribeAttributeTargetNavigatorAttributeList>(), //
        make_unique<ReadTargetNavigatorClusterRevision>(), //
        make_unique<SubscribeAttributeTargetNavigatorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTemperatureMeasurement(Commands & commands)
{
    const char * clusterName = "TemperatureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadTemperatureMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementMinMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementTolerance>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementTolerance>(), //
        make_unique<ReadTemperatureMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementAttributeList>(), //
        make_unique<ReadTemperatureMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTestCluster(Commands & commands)
{
    const char * clusterName = "TestCluster";

    commands_list clusterCommands = {
        make_unique<TestClusterSimpleStructEchoRequest>(), //
        make_unique<TestClusterTest>(), //
        make_unique<TestClusterTestAddArguments>(), //
        make_unique<TestClusterTestEmitTestEventRequest>(), //
        make_unique<TestClusterTestEnumsRequest>(), //
        make_unique<TestClusterTestListInt8UArgumentRequest>(), //
        make_unique<TestClusterTestListInt8UReverseRequest>(), //
        make_unique<TestClusterTestListNestedStructListArgumentRequest>(), //
        make_unique<TestClusterTestListStructArgumentRequest>(), //
        make_unique<TestClusterTestNestedStructArgumentRequest>(), //
        make_unique<TestClusterTestNestedStructListArgumentRequest>(), //
        make_unique<TestClusterTestNotHandled>(), //
        make_unique<TestClusterTestNullableOptionalRequest>(), //
        make_unique<TestClusterTestSimpleOptionalArgumentRequest>(), //
        make_unique<TestClusterTestSpecific>(), //
        make_unique<TestClusterTestStructArgumentRequest>(), //
        make_unique<TestClusterTestUnknownCommand>(), //
        make_unique<TestClusterTimedInvokeRequest>(), //
        make_unique<ReadTestClusterBoolean>(), //
        make_unique<WriteTestClusterBoolean>(), //
        make_unique<SubscribeAttributeTestClusterBoolean>(), //
        make_unique<ReadTestClusterBitmap8>(), //
        make_unique<WriteTestClusterBitmap8>(), //
        make_unique<SubscribeAttributeTestClusterBitmap8>(), //
        make_unique<ReadTestClusterBitmap16>(), //
        make_unique<WriteTestClusterBitmap16>(), //
        make_unique<SubscribeAttributeTestClusterBitmap16>(), //
        make_unique<ReadTestClusterBitmap32>(), //
        make_unique<WriteTestClusterBitmap32>(), //
        make_unique<SubscribeAttributeTestClusterBitmap32>(), //
        make_unique<ReadTestClusterBitmap64>(), //
        make_unique<WriteTestClusterBitmap64>(), //
        make_unique<SubscribeAttributeTestClusterBitmap64>(), //
        make_unique<ReadTestClusterInt8u>(), //
        make_unique<WriteTestClusterInt8u>(), //
        make_unique<SubscribeAttributeTestClusterInt8u>(), //
        make_unique<ReadTestClusterInt16u>(), //
        make_unique<WriteTestClusterInt16u>(), //
        make_unique<SubscribeAttributeTestClusterInt16u>(), //
        make_unique<ReadTestClusterInt24u>(), //
        make_unique<WriteTestClusterInt24u>(), //
        make_unique<SubscribeAttributeTestClusterInt24u>(), //
        make_unique<ReadTestClusterInt32u>(), //
        make_unique<WriteTestClusterInt32u>(), //
        make_unique<SubscribeAttributeTestClusterInt32u>(), //
        make_unique<ReadTestClusterInt40u>(), //
        make_unique<WriteTestClusterInt40u>(), //
        make_unique<SubscribeAttributeTestClusterInt40u>(), //
        make_unique<ReadTestClusterInt48u>(), //
        make_unique<WriteTestClusterInt48u>(), //
        make_unique<SubscribeAttributeTestClusterInt48u>(), //
        make_unique<ReadTestClusterInt56u>(), //
        make_unique<WriteTestClusterInt56u>(), //
        make_unique<SubscribeAttributeTestClusterInt56u>(), //
        make_unique<ReadTestClusterInt64u>(), //
        make_unique<WriteTestClusterInt64u>(), //
        make_unique<SubscribeAttributeTestClusterInt64u>(), //
        make_unique<ReadTestClusterInt8s>(), //
        make_unique<WriteTestClusterInt8s>(), //
        make_unique<SubscribeAttributeTestClusterInt8s>(), //
        make_unique<ReadTestClusterInt16s>(), //
        make_unique<WriteTestClusterInt16s>(), //
        make_unique<SubscribeAttributeTestClusterInt16s>(), //
        make_unique<ReadTestClusterInt24s>(), //
        make_unique<WriteTestClusterInt24s>(), //
        make_unique<SubscribeAttributeTestClusterInt24s>(), //
        make_unique<ReadTestClusterInt32s>(), //
        make_unique<WriteTestClusterInt32s>(), //
        make_unique<SubscribeAttributeTestClusterInt32s>(), //
        make_unique<ReadTestClusterInt40s>(), //
        make_unique<WriteTestClusterInt40s>(), //
        make_unique<SubscribeAttributeTestClusterInt40s>(), //
        make_unique<ReadTestClusterInt48s>(), //
        make_unique<WriteTestClusterInt48s>(), //
        make_unique<SubscribeAttributeTestClusterInt48s>(), //
        make_unique<ReadTestClusterInt56s>(), //
        make_unique<WriteTestClusterInt56s>(), //
        make_unique<SubscribeAttributeTestClusterInt56s>(), //
        make_unique<ReadTestClusterInt64s>(), //
        make_unique<WriteTestClusterInt64s>(), //
        make_unique<SubscribeAttributeTestClusterInt64s>(), //
        make_unique<ReadTestClusterEnum8>(), //
        make_unique<WriteTestClusterEnum8>(), //
        make_unique<SubscribeAttributeTestClusterEnum8>(), //
        make_unique<ReadTestClusterEnum16>(), //
        make_unique<WriteTestClusterEnum16>(), //
        make_unique<SubscribeAttributeTestClusterEnum16>(), //
        make_unique<ReadTestClusterFloatSingle>(), //
        make_unique<WriteTestClusterFloatSingle>(), //
        make_unique<SubscribeAttributeTestClusterFloatSingle>(), //
        make_unique<ReadTestClusterFloatDouble>(), //
        make_unique<WriteTestClusterFloatDouble>(), //
        make_unique<SubscribeAttributeTestClusterFloatDouble>(), //
        make_unique<ReadTestClusterOctetString>(), //
        make_unique<WriteTestClusterOctetString>(), //
        make_unique<SubscribeAttributeTestClusterOctetString>(), //
        make_unique<ReadTestClusterListInt8u>(), //
        make_unique<WriteTestClusterListInt8u>(), //
        make_unique<SubscribeAttributeTestClusterListInt8u>(), //
        make_unique<ReadTestClusterListOctetString>(), //
        make_unique<WriteTestClusterListOctetString>(), //
        make_unique<SubscribeAttributeTestClusterListOctetString>(), //
        make_unique<ReadTestClusterListStructOctetString>(), //
        make_unique<WriteTestClusterListStructOctetString>(), //
        make_unique<SubscribeAttributeTestClusterListStructOctetString>(), //
        make_unique<ReadTestClusterLongOctetString>(), //
        make_unique<WriteTestClusterLongOctetString>(), //
        make_unique<SubscribeAttributeTestClusterLongOctetString>(), //
        make_unique<ReadTestClusterCharString>(), //
        make_unique<WriteTestClusterCharString>(), //
        make_unique<SubscribeAttributeTestClusterCharString>(), //
        make_unique<ReadTestClusterLongCharString>(), //
        make_unique<WriteTestClusterLongCharString>(), //
        make_unique<SubscribeAttributeTestClusterLongCharString>(), //
        make_unique<ReadTestClusterEpochUs>(), //
        make_unique<WriteTestClusterEpochUs>(), //
        make_unique<SubscribeAttributeTestClusterEpochUs>(), //
        make_unique<ReadTestClusterEpochS>(), //
        make_unique<WriteTestClusterEpochS>(), //
        make_unique<SubscribeAttributeTestClusterEpochS>(), //
        make_unique<ReadTestClusterVendorId>(), //
        make_unique<WriteTestClusterVendorId>(), //
        make_unique<SubscribeAttributeTestClusterVendorId>(), //
        make_unique<ReadTestClusterListNullablesAndOptionalsStruct>(), //
        make_unique<WriteTestClusterListNullablesAndOptionalsStruct>(), //
        make_unique<SubscribeAttributeTestClusterListNullablesAndOptionalsStruct>(), //
        make_unique<ReadTestClusterEnumAttr>(), //
        make_unique<WriteTestClusterEnumAttr>(), //
        make_unique<SubscribeAttributeTestClusterEnumAttr>(), //
        make_unique<ReadTestClusterStructAttr>(), //
        make_unique<WriteTestClusterStructAttr>(), //
        make_unique<SubscribeAttributeTestClusterStructAttr>(), //
        make_unique<ReadTestClusterRangeRestrictedInt8u>(), //
        make_unique<WriteTestClusterRangeRestrictedInt8u>(), //
        make_unique<SubscribeAttributeTestClusterRangeRestrictedInt8u>(), //
        make_unique<ReadTestClusterRangeRestrictedInt8s>(), //
        make_unique<WriteTestClusterRangeRestrictedInt8s>(), //
        make_unique<SubscribeAttributeTestClusterRangeRestrictedInt8s>(), //
        make_unique<ReadTestClusterRangeRestrictedInt16u>(), //
        make_unique<WriteTestClusterRangeRestrictedInt16u>(), //
        make_unique<SubscribeAttributeTestClusterRangeRestrictedInt16u>(), //
        make_unique<ReadTestClusterRangeRestrictedInt16s>(), //
        make_unique<WriteTestClusterRangeRestrictedInt16s>(), //
        make_unique<SubscribeAttributeTestClusterRangeRestrictedInt16s>(), //
        make_unique<ReadTestClusterListLongOctetString>(), //
        make_unique<WriteTestClusterListLongOctetString>(), //
        make_unique<SubscribeAttributeTestClusterListLongOctetString>(), //
        make_unique<ReadTestClusterListFabricScoped>(), //
        make_unique<WriteTestClusterListFabricScoped>(), //
        make_unique<SubscribeAttributeTestClusterListFabricScoped>(), //
        make_unique<ReadTestClusterTimedWriteBoolean>(), //
        make_unique<WriteTestClusterTimedWriteBoolean>(), //
        make_unique<SubscribeAttributeTestClusterTimedWriteBoolean>(), //
        make_unique<ReadTestClusterGeneralErrorBoolean>(), //
        make_unique<WriteTestClusterGeneralErrorBoolean>(), //
        make_unique<SubscribeAttributeTestClusterGeneralErrorBoolean>(), //
        make_unique<ReadTestClusterClusterErrorBoolean>(), //
        make_unique<WriteTestClusterClusterErrorBoolean>(), //
        make_unique<SubscribeAttributeTestClusterClusterErrorBoolean>(), //
        make_unique<ReadTestClusterUnsupported>(), //
        make_unique<WriteTestClusterUnsupported>(), //
        make_unique<SubscribeAttributeTestClusterUnsupported>(), //
        make_unique<ReadTestClusterNullableBoolean>(), //
        make_unique<WriteTestClusterNullableBoolean>(), //
        make_unique<SubscribeAttributeTestClusterNullableBoolean>(), //
        make_unique<ReadTestClusterNullableBitmap8>(), //
        make_unique<WriteTestClusterNullableBitmap8>(), //
        make_unique<SubscribeAttributeTestClusterNullableBitmap8>(), //
        make_unique<ReadTestClusterNullableBitmap16>(), //
        make_unique<WriteTestClusterNullableBitmap16>(), //
        make_unique<SubscribeAttributeTestClusterNullableBitmap16>(), //
        make_unique<ReadTestClusterNullableBitmap32>(), //
        make_unique<WriteTestClusterNullableBitmap32>(), //
        make_unique<SubscribeAttributeTestClusterNullableBitmap32>(), //
        make_unique<ReadTestClusterNullableBitmap64>(), //
        make_unique<WriteTestClusterNullableBitmap64>(), //
        make_unique<SubscribeAttributeTestClusterNullableBitmap64>(), //
        make_unique<ReadTestClusterNullableInt8u>(), //
        make_unique<WriteTestClusterNullableInt8u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt8u>(), //
        make_unique<ReadTestClusterNullableInt16u>(), //
        make_unique<WriteTestClusterNullableInt16u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt16u>(), //
        make_unique<ReadTestClusterNullableInt24u>(), //
        make_unique<WriteTestClusterNullableInt24u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt24u>(), //
        make_unique<ReadTestClusterNullableInt32u>(), //
        make_unique<WriteTestClusterNullableInt32u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt32u>(), //
        make_unique<ReadTestClusterNullableInt40u>(), //
        make_unique<WriteTestClusterNullableInt40u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt40u>(), //
        make_unique<ReadTestClusterNullableInt48u>(), //
        make_unique<WriteTestClusterNullableInt48u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt48u>(), //
        make_unique<ReadTestClusterNullableInt56u>(), //
        make_unique<WriteTestClusterNullableInt56u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt56u>(), //
        make_unique<ReadTestClusterNullableInt64u>(), //
        make_unique<WriteTestClusterNullableInt64u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt64u>(), //
        make_unique<ReadTestClusterNullableInt8s>(), //
        make_unique<WriteTestClusterNullableInt8s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt8s>(), //
        make_unique<ReadTestClusterNullableInt16s>(), //
        make_unique<WriteTestClusterNullableInt16s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt16s>(), //
        make_unique<ReadTestClusterNullableInt24s>(), //
        make_unique<WriteTestClusterNullableInt24s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt24s>(), //
        make_unique<ReadTestClusterNullableInt32s>(), //
        make_unique<WriteTestClusterNullableInt32s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt32s>(), //
        make_unique<ReadTestClusterNullableInt40s>(), //
        make_unique<WriteTestClusterNullableInt40s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt40s>(), //
        make_unique<ReadTestClusterNullableInt48s>(), //
        make_unique<WriteTestClusterNullableInt48s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt48s>(), //
        make_unique<ReadTestClusterNullableInt56s>(), //
        make_unique<WriteTestClusterNullableInt56s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt56s>(), //
        make_unique<ReadTestClusterNullableInt64s>(), //
        make_unique<WriteTestClusterNullableInt64s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt64s>(), //
        make_unique<ReadTestClusterNullableEnum8>(), //
        make_unique<WriteTestClusterNullableEnum8>(), //
        make_unique<SubscribeAttributeTestClusterNullableEnum8>(), //
        make_unique<ReadTestClusterNullableEnum16>(), //
        make_unique<WriteTestClusterNullableEnum16>(), //
        make_unique<SubscribeAttributeTestClusterNullableEnum16>(), //
        make_unique<ReadTestClusterNullableFloatSingle>(), //
        make_unique<WriteTestClusterNullableFloatSingle>(), //
        make_unique<SubscribeAttributeTestClusterNullableFloatSingle>(), //
        make_unique<ReadTestClusterNullableFloatDouble>(), //
        make_unique<WriteTestClusterNullableFloatDouble>(), //
        make_unique<SubscribeAttributeTestClusterNullableFloatDouble>(), //
        make_unique<ReadTestClusterNullableOctetString>(), //
        make_unique<WriteTestClusterNullableOctetString>(), //
        make_unique<SubscribeAttributeTestClusterNullableOctetString>(), //
        make_unique<ReadTestClusterNullableCharString>(), //
        make_unique<WriteTestClusterNullableCharString>(), //
        make_unique<SubscribeAttributeTestClusterNullableCharString>(), //
        make_unique<ReadTestClusterNullableEnumAttr>(), //
        make_unique<WriteTestClusterNullableEnumAttr>(), //
        make_unique<SubscribeAttributeTestClusterNullableEnumAttr>(), //
        make_unique<ReadTestClusterNullableStruct>(), //
        make_unique<WriteTestClusterNullableStruct>(), //
        make_unique<SubscribeAttributeTestClusterNullableStruct>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<SubscribeAttributeTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<SubscribeAttributeTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<SubscribeAttributeTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<SubscribeAttributeTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<ReadTestClusterGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTestClusterGeneratedCommandList>(), //
        make_unique<ReadTestClusterAcceptedCommandList>(), //
        make_unique<SubscribeAttributeTestClusterAcceptedCommandList>(), //
        make_unique<ReadTestClusterAttributeList>(), //
        make_unique<SubscribeAttributeTestClusterAttributeList>(), //
        make_unique<ReadTestClusterClusterRevision>(), //
        make_unique<SubscribeAttributeTestClusterClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostat(Commands & commands)
{
    const char * clusterName = "Thermostat";

    commands_list clusterCommands = {
        make_unique<ThermostatClearWeeklySchedule>(), //
        make_unique<ThermostatGetRelayStatusLog>(), //
        make_unique<ThermostatGetWeeklySchedule>(), //
        make_unique<ThermostatSetWeeklySchedule>(), //
        make_unique<ThermostatSetpointRaiseLower>(), //
        make_unique<ReadThermostatLocalTemperature>(), //
        make_unique<SubscribeAttributeThermostatLocalTemperature>(), //
        make_unique<ReadThermostatAbsMinHeatSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatAbsMinHeatSetpointLimit>(), //
        make_unique<ReadThermostatAbsMaxHeatSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatAbsMaxHeatSetpointLimit>(), //
        make_unique<ReadThermostatAbsMinCoolSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatAbsMinCoolSetpointLimit>(), //
        make_unique<ReadThermostatAbsMaxCoolSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatAbsMaxCoolSetpointLimit>(), //
        make_unique<ReadThermostatOccupiedCoolingSetpoint>(), //
        make_unique<WriteThermostatOccupiedCoolingSetpoint>(), //
        make_unique<SubscribeAttributeThermostatOccupiedCoolingSetpoint>(), //
        make_unique<ReadThermostatOccupiedHeatingSetpoint>(), //
        make_unique<WriteThermostatOccupiedHeatingSetpoint>(), //
        make_unique<SubscribeAttributeThermostatOccupiedHeatingSetpoint>(), //
        make_unique<ReadThermostatMinHeatSetpointLimit>(), //
        make_unique<WriteThermostatMinHeatSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatMinHeatSetpointLimit>(), //
        make_unique<ReadThermostatMaxHeatSetpointLimit>(), //
        make_unique<WriteThermostatMaxHeatSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatMaxHeatSetpointLimit>(), //
        make_unique<ReadThermostatMinCoolSetpointLimit>(), //
        make_unique<WriteThermostatMinCoolSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatMinCoolSetpointLimit>(), //
        make_unique<ReadThermostatMaxCoolSetpointLimit>(), //
        make_unique<WriteThermostatMaxCoolSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatMaxCoolSetpointLimit>(), //
        make_unique<ReadThermostatMinSetpointDeadBand>(), //
        make_unique<WriteThermostatMinSetpointDeadBand>(), //
        make_unique<SubscribeAttributeThermostatMinSetpointDeadBand>(), //
        make_unique<ReadThermostatControlSequenceOfOperation>(), //
        make_unique<WriteThermostatControlSequenceOfOperation>(), //
        make_unique<SubscribeAttributeThermostatControlSequenceOfOperation>(), //
        make_unique<ReadThermostatSystemMode>(), //
        make_unique<WriteThermostatSystemMode>(), //
        make_unique<SubscribeAttributeThermostatSystemMode>(), //
        make_unique<ReadThermostatStartOfWeek>(), //
        make_unique<SubscribeAttributeThermostatStartOfWeek>(), //
        make_unique<ReadThermostatNumberOfWeeklyTransitions>(), //
        make_unique<SubscribeAttributeThermostatNumberOfWeeklyTransitions>(), //
        make_unique<ReadThermostatNumberOfDailyTransitions>(), //
        make_unique<SubscribeAttributeThermostatNumberOfDailyTransitions>(), //
        make_unique<ReadThermostatAttributeList>(), //
        make_unique<SubscribeAttributeThermostatAttributeList>(), //
        make_unique<ReadThermostatFeatureMap>(), //
        make_unique<SubscribeAttributeThermostatFeatureMap>(), //
        make_unique<ReadThermostatClusterRevision>(), //
        make_unique<SubscribeAttributeThermostatClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostatUserInterfaceConfiguration(Commands & commands)
{
    const char * clusterName = "ThermostatUserInterfaceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationGeneratedCommandList>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationGeneratedCommandList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationAcceptedCommandList>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationAcceptedCommandList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationAttributeList>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationAttributeList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationClusterRevision>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThreadNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "ThreadNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<ThreadNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadThreadNetworkDiagnosticsChannel>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsChannel>(), //
        make_unique<ReadThreadNetworkDiagnosticsRoutingRole>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRoutingRole>(), //
        make_unique<ReadThreadNetworkDiagnosticsNetworkName>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsNetworkName>(), //
        make_unique<ReadThreadNetworkDiagnosticsPanId>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsPanId>(), //
        make_unique<ReadThreadNetworkDiagnosticsExtendedPanId>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsExtendedPanId>(), //
        make_unique<ReadThreadNetworkDiagnosticsMeshLocalPrefix>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsMeshLocalPrefix>(), //
        make_unique<ReadThreadNetworkDiagnosticsOverrunCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsNeighborTableList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsNeighborTableList>(), //
        make_unique<ReadThreadNetworkDiagnosticsRouteTableList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRouteTableList>(), //
        make_unique<ReadThreadNetworkDiagnosticsPartitionId>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsPartitionId>(), //
        make_unique<ReadThreadNetworkDiagnosticsWeighting>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsWeighting>(), //
        make_unique<ReadThreadNetworkDiagnosticsDataVersion>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsDataVersion>(), //
        make_unique<ReadThreadNetworkDiagnosticsStableDataVersion>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsStableDataVersion>(), //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRouterId>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsLeaderRouterId>(), //
        make_unique<ReadThreadNetworkDiagnosticsDetachedRoleCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsDetachedRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsChildRoleCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsChildRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRouterRoleCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRouterRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRoleCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsLeaderRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsAttachAttemptCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsAttachAttemptCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsPartitionIdChangeCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsPartitionIdChangeCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsParentChangeCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsParentChangeCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxTotalCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxTotalCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxUnicastCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxUnicastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBroadcastCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxBroadcastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxAckRequestedCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxAckRequestedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxAckedCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxAckedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxNoAckRequestedCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxNoAckRequestedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDataCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxDataCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDataPollCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxDataPollCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxBeaconCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconRequestCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxBeaconRequestCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxOtherCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxRetryCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxRetryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrCcaCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxErrCcaCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrAbortCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxErrAbortCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrBusyChannelCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxErrBusyChannelCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxTotalCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxTotalCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxUnicastCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxUnicastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBroadcastCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxBroadcastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDataCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxDataCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDataPollCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxDataPollCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxBeaconCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconRequestCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxBeaconRequestCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxOtherCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxAddressFilteredCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxAddressFilteredCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxDestAddrFilteredCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDuplicatedCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxDuplicatedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrNoFrameCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrNoFrameCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrSecCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrSecCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrFcsCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrFcsCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrOtherCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsActiveTimestamp>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsActiveTimestamp>(), //
        make_unique<ReadThreadNetworkDiagnosticsPendingTimestamp>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsPendingTimestamp>(), //
        make_unique<ReadThreadNetworkDiagnosticsDelay>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsDelay>(), //
        make_unique<ReadThreadNetworkDiagnosticsSecurityPolicy>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsSecurityPolicy>(), //
        make_unique<ReadThreadNetworkDiagnosticsChannelMask>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsChannelMask>(), //
        make_unique<ReadThreadNetworkDiagnosticsOperationalDatasetComponents>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsOperationalDatasetComponents>(), //
        make_unique<ReadThreadNetworkDiagnosticsActiveNetworkFaultsList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsActiveNetworkFaultsList>(), //
        make_unique<ReadThreadNetworkDiagnosticsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsGeneratedCommandList>(), //
        make_unique<ReadThreadNetworkDiagnosticsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsAcceptedCommandList>(), //
        make_unique<ReadThreadNetworkDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadThreadNetworkDiagnosticsFeatureMap>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadThreadNetworkDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTimeFormatLocalization(Commands & commands)
{
    const char * clusterName = "TimeFormatLocalization";

    commands_list clusterCommands = {
        make_unique<ReadTimeFormatLocalizationHourFormat>(), //
        make_unique<WriteTimeFormatLocalizationHourFormat>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationHourFormat>(), //
        make_unique<ReadTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<WriteTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<ReadTimeFormatLocalizationSupportedCalendarTypes>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationSupportedCalendarTypes>(), //
        make_unique<ReadTimeFormatLocalizationGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationGeneratedCommandList>(), //
        make_unique<ReadTimeFormatLocalizationAcceptedCommandList>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationAcceptedCommandList>(), //
        make_unique<ReadTimeFormatLocalizationClusterRevision>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterUnitLocalization(Commands & commands)
{
    const char * clusterName = "UnitLocalization";

    commands_list clusterCommands = {
        make_unique<ReadUnitLocalizationTemperatureUnit>(), //
        make_unique<WriteUnitLocalizationTemperatureUnit>(), //
        make_unique<SubscribeAttributeUnitLocalizationTemperatureUnit>(), //
        make_unique<ReadUnitLocalizationAttributeList>(), //
        make_unique<SubscribeAttributeUnitLocalizationAttributeList>(), //
        make_unique<ReadUnitLocalizationFeatureMap>(), //
        make_unique<SubscribeAttributeUnitLocalizationFeatureMap>(), //
        make_unique<ReadUnitLocalizationClusterRevision>(), //
        make_unique<SubscribeAttributeUnitLocalizationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterUserLabel(Commands & commands)
{
    const char * clusterName = "UserLabel";

    commands_list clusterCommands = {
        make_unique<ReadUserLabelLabelList>(), //
        make_unique<WriteUserLabelLabelList>(), //
        make_unique<SubscribeAttributeUserLabelLabelList>(), //
        make_unique<ReadUserLabelGeneratedCommandList>(), //
        make_unique<SubscribeAttributeUserLabelGeneratedCommandList>(), //
        make_unique<ReadUserLabelAcceptedCommandList>(), //
        make_unique<SubscribeAttributeUserLabelAcceptedCommandList>(), //
        make_unique<ReadUserLabelClusterRevision>(), //
        make_unique<SubscribeAttributeUserLabelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWakeOnLan(Commands & commands)
{
    const char * clusterName = "WakeOnLan";

    commands_list clusterCommands = {
        make_unique<ReadWakeOnLanMACAddress>(), //
        make_unique<SubscribeAttributeWakeOnLanMACAddress>(), //
        make_unique<ReadWakeOnLanGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWakeOnLanGeneratedCommandList>(), //
        make_unique<ReadWakeOnLanAcceptedCommandList>(), //
        make_unique<SubscribeAttributeWakeOnLanAcceptedCommandList>(), //
        make_unique<ReadWakeOnLanAttributeList>(), //
        make_unique<SubscribeAttributeWakeOnLanAttributeList>(), //
        make_unique<ReadWakeOnLanClusterRevision>(), //
        make_unique<SubscribeAttributeWakeOnLanClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWiFiNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "WiFiNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<WiFiNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBssid>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsBssid>(), //
        make_unique<ReadWiFiNetworkDiagnosticsSecurityType>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsSecurityType>(), //
        make_unique<ReadWiFiNetworkDiagnosticsWiFiVersion>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsWiFiVersion>(), //
        make_unique<ReadWiFiNetworkDiagnosticsChannelNumber>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsChannelNumber>(), //
        make_unique<ReadWiFiNetworkDiagnosticsRssi>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsRssi>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconLostCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsBeaconLostCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconRxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsBeaconRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastRxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastTxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastTxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastRxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastTxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastTxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsCurrentMaxRate>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsCurrentMaxRate>(), //
        make_unique<ReadWiFiNetworkDiagnosticsOverrunCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsGeneratedCommandList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsAcceptedCommandList>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsAcceptedCommandList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsFeatureMap>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadWiFiNetworkDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWindowCovering(Commands & commands)
{
    const char * clusterName = "WindowCovering";

    commands_list clusterCommands = {
        make_unique<WindowCoveringDownOrClose>(), //
        make_unique<WindowCoveringGoToLiftPercentage>(), //
        make_unique<WindowCoveringGoToLiftValue>(), //
        make_unique<WindowCoveringGoToTiltPercentage>(), //
        make_unique<WindowCoveringGoToTiltValue>(), //
        make_unique<WindowCoveringStopMotion>(), //
        make_unique<WindowCoveringUpOrOpen>(), //
        make_unique<ReadWindowCoveringType>(), //
        make_unique<SubscribeAttributeWindowCoveringType>(), //
        make_unique<ReadWindowCoveringCurrentPositionLift>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionLift>(), //
        make_unique<ReadWindowCoveringCurrentPositionTilt>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionTilt>(), //
        make_unique<ReadWindowCoveringConfigStatus>(), //
        make_unique<SubscribeAttributeWindowCoveringConfigStatus>(), //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercentage>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionLiftPercentage>(), //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercentage>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionTiltPercentage>(), //
        make_unique<ReadWindowCoveringOperationalStatus>(), //
        make_unique<SubscribeAttributeWindowCoveringOperationalStatus>(), //
        make_unique<ReadWindowCoveringTargetPositionLiftPercent100ths>(), //
        make_unique<SubscribeAttributeWindowCoveringTargetPositionLiftPercent100ths>(), //
        make_unique<ReadWindowCoveringTargetPositionTiltPercent100ths>(), //
        make_unique<SubscribeAttributeWindowCoveringTargetPositionTiltPercent100ths>(), //
        make_unique<ReadWindowCoveringEndProductType>(), //
        make_unique<SubscribeAttributeWindowCoveringEndProductType>(), //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercent100ths>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionLiftPercent100ths>(), //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercent100ths>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionTiltPercent100ths>(), //
        make_unique<ReadWindowCoveringInstalledOpenLimitLift>(), //
        make_unique<SubscribeAttributeWindowCoveringInstalledOpenLimitLift>(), //
        make_unique<ReadWindowCoveringInstalledClosedLimitLift>(), //
        make_unique<SubscribeAttributeWindowCoveringInstalledClosedLimitLift>(), //
        make_unique<ReadWindowCoveringInstalledOpenLimitTilt>(), //
        make_unique<SubscribeAttributeWindowCoveringInstalledOpenLimitTilt>(), //
        make_unique<ReadWindowCoveringInstalledClosedLimitTilt>(), //
        make_unique<SubscribeAttributeWindowCoveringInstalledClosedLimitTilt>(), //
        make_unique<ReadWindowCoveringMode>(), //
        make_unique<WriteWindowCoveringMode>(), //
        make_unique<SubscribeAttributeWindowCoveringMode>(), //
        make_unique<ReadWindowCoveringSafetyStatus>(), //
        make_unique<SubscribeAttributeWindowCoveringSafetyStatus>(), //
        make_unique<ReadWindowCoveringGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWindowCoveringGeneratedCommandList>(), //
        make_unique<ReadWindowCoveringAcceptedCommandList>(), //
        make_unique<SubscribeAttributeWindowCoveringAcceptedCommandList>(), //
        make_unique<ReadWindowCoveringAttributeList>(), //
        make_unique<SubscribeAttributeWindowCoveringAttributeList>(), //
        make_unique<ReadWindowCoveringFeatureMap>(), //
        make_unique<SubscribeAttributeWindowCoveringFeatureMap>(), //
        make_unique<ReadWindowCoveringClusterRevision>(), //
        make_unique<SubscribeAttributeWindowCoveringClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusters(Commands & commands)
{
    registerClusterAccessControl(commands);
    registerClusterAccountLogin(commands);
    registerClusterAdministratorCommissioning(commands);
    registerClusterApplicationBasic(commands);
    registerClusterApplicationLauncher(commands);
    registerClusterAudioOutput(commands);
    registerClusterBarrierControl(commands);
    registerClusterBasic(commands);
    registerClusterBinaryInputBasic(commands);
    registerClusterBinding(commands);
    registerClusterBooleanState(commands);
    registerClusterBridgedActions(commands);
    registerClusterBridgedDeviceBasic(commands);
    registerClusterChannel(commands);
    registerClusterColorControl(commands);
    registerClusterContentLauncher(commands);
    registerClusterDescriptor(commands);
    registerClusterDiagnosticLogs(commands);
    registerClusterDoorLock(commands);
    registerClusterElectricalMeasurement(commands);
    registerClusterEthernetNetworkDiagnostics(commands);
    registerClusterFanControl(commands);
    registerClusterFixedLabel(commands);
    registerClusterFlowMeasurement(commands);
    registerClusterGeneralCommissioning(commands);
    registerClusterGeneralDiagnostics(commands);
    registerClusterGroupKeyManagement(commands);
    registerClusterGroups(commands);
    registerClusterIdentify(commands);
    registerClusterIlluminanceMeasurement(commands);
    registerClusterKeypadInput(commands);
    registerClusterLevelControl(commands);
    registerClusterLocalizationConfiguration(commands);
    registerClusterLowPower(commands);
    registerClusterMediaInput(commands);
    registerClusterMediaPlayback(commands);
    registerClusterModeSelect(commands);
    registerClusterNetworkCommissioning(commands);
    registerClusterOtaSoftwareUpdateProvider(commands);
    registerClusterOtaSoftwareUpdateRequestor(commands);
    registerClusterOccupancySensing(commands);
    registerClusterOnOff(commands);
    registerClusterOnOffSwitchConfiguration(commands);
    registerClusterOperationalCredentials(commands);
    registerClusterPowerSource(commands);
    registerClusterPowerSourceConfiguration(commands);
    registerClusterPressureMeasurement(commands);
    registerClusterPumpConfigurationAndControl(commands);
    registerClusterRelativeHumidityMeasurement(commands);
    registerClusterScenes(commands);
    registerClusterSoftwareDiagnostics(commands);
    registerClusterSwitch(commands);
    registerClusterTargetNavigator(commands);
    registerClusterTemperatureMeasurement(commands);
    registerClusterTestCluster(commands);
    registerClusterThermostat(commands);
    registerClusterThermostatUserInterfaceConfiguration(commands);
    registerClusterThreadNetworkDiagnostics(commands);
    registerClusterTimeFormatLocalization(commands);
    registerClusterUnitLocalization(commands);
    registerClusterUserLabel(commands);
    registerClusterWakeOnLan(commands);
    registerClusterWiFiNetworkDiagnostics(commands);
    registerClusterWindowCovering(commands);
}
