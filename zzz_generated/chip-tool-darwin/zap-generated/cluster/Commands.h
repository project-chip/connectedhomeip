/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#import <CHIP/CHIPDevice.h>
#import <CHIP/CHIPError_Internal.h>

#include <cstdint>
#include <string>
#include <type_traits>

#include <app/data-model/DecodableList.h>
#include <commands/clusters/ModelCommandBridge.h>

/*----------------------------------------------------------------------------*\
| Cluster Name                                                        |   ID   |
|---------------------------------------------------------------------+--------|
| PowerConfiguration                                                  | 0x0001 |
| DeviceTemperatureConfiguration                                      | 0x0002 |
| Identify                                                            | 0x0003 |
| Groups                                                              | 0x0004 |
| Scenes                                                              | 0x0005 |
| OnOff                                                               | 0x0006 |
| OnOffSwitchConfiguration                                            | 0x0007 |
| LevelControl                                                        | 0x0008 |
| Alarms                                                              | 0x0009 |
| Time                                                                | 0x000A |
| BinaryInputBasic                                                    | 0x000F |
| PowerProfile                                                        | 0x001A |
| ApplianceControl                                                    | 0x001B |
| PulseWidthModulation                                                | 0x001C |
| Descriptor                                                          | 0x001D |
| Binding                                                             | 0x001E |
| AccessControl                                                       | 0x001F |
| PollControl                                                         | 0x0020 |
| BridgedActions                                                      | 0x0025 |
| Basic                                                               | 0x0028 |
| OtaSoftwareUpdateProvider                                           | 0x0029 |
| OtaSoftwareUpdateRequestor                                          | 0x002A |
| LocalizationConfiguration                                           | 0x002B |
| TimeFormatLocalization                                              | 0x002C |
| UnitLocalization                                                    | 0x002D |
| PowerSourceConfiguration                                            | 0x002E |
| PowerSource                                                         | 0x002F |
| GeneralCommissioning                                                | 0x0030 |
| NetworkCommissioning                                                | 0x0031 |
| DiagnosticLogs                                                      | 0x0032 |
| GeneralDiagnostics                                                  | 0x0033 |
| SoftwareDiagnostics                                                 | 0x0034 |
| ThreadNetworkDiagnostics                                            | 0x0035 |
| WiFiNetworkDiagnostics                                              | 0x0036 |
| EthernetNetworkDiagnostics                                          | 0x0037 |
| TimeSynchronization                                                 | 0x0038 |
| BridgedDeviceBasic                                                  | 0x0039 |
| Switch                                                              | 0x003B |
| AdministratorCommissioning                                          | 0x003C |
| OperationalCredentials                                              | 0x003E |
| GroupKeyManagement                                                  | 0x003F |
| FixedLabel                                                          | 0x0040 |
| UserLabel                                                           | 0x0041 |
| ProxyConfiguration                                                  | 0x0042 |
| ProxyDiscovery                                                      | 0x0043 |
| ProxyValid                                                          | 0x0044 |
| BooleanState                                                        | 0x0045 |
| ModeSelect                                                          | 0x0050 |
| ShadeConfiguration                                                  | 0x0100 |
| DoorLock                                                            | 0x0101 |
| WindowCovering                                                      | 0x0102 |
| BarrierControl                                                      | 0x0103 |
| PumpConfigurationAndControl                                         | 0x0200 |
| Thermostat                                                          | 0x0201 |
| FanControl                                                          | 0x0202 |
| DehumidificationControl                                             | 0x0203 |
| ThermostatUserInterfaceConfiguration                                | 0x0204 |
| ColorControl                                                        | 0x0300 |
| BallastConfiguration                                                | 0x0301 |
| IlluminanceMeasurement                                              | 0x0400 |
| TemperatureMeasurement                                              | 0x0402 |
| PressureMeasurement                                                 | 0x0403 |
| FlowMeasurement                                                     | 0x0404 |
| RelativeHumidityMeasurement                                         | 0x0405 |
| OccupancySensing                                                    | 0x0406 |
| CarbonMonoxideConcentrationMeasurement                              | 0x040C |
| CarbonDioxideConcentrationMeasurement                               | 0x040D |
| EthyleneConcentrationMeasurement                                    | 0x040E |
| EthyleneOxideConcentrationMeasurement                               | 0x040F |
| HydrogenConcentrationMeasurement                                    | 0x0410 |
| HydrogenSulphideConcentrationMeasurement                            | 0x0411 |
| NitricOxideConcentrationMeasurement                                 | 0x0412 |
| NitrogenDioxideConcentrationMeasurement                             | 0x0413 |
| OxygenConcentrationMeasurement                                      | 0x0414 |
| OzoneConcentrationMeasurement                                       | 0x0415 |
| SulfurDioxideConcentrationMeasurement                               | 0x0416 |
| DissolvedOxygenConcentrationMeasurement                             | 0x0417 |
| BromateConcentrationMeasurement                                     | 0x0418 |
| ChloraminesConcentrationMeasurement                                 | 0x0419 |
| ChlorineConcentrationMeasurement                                    | 0x041A |
| FecalColiformAndEColiConcentrationMeasurement                       | 0x041B |
| FluorideConcentrationMeasurement                                    | 0x041C |
| HaloaceticAcidsConcentrationMeasurement                             | 0x041D |
| TotalTrihalomethanesConcentrationMeasurement                        | 0x041E |
| TotalColiformBacteriaConcentrationMeasurement                       | 0x041F |
| TurbidityConcentrationMeasurement                                   | 0x0420 |
| CopperConcentrationMeasurement                                      | 0x0421 |
| LeadConcentrationMeasurement                                        | 0x0422 |
| ManganeseConcentrationMeasurement                                   | 0x0423 |
| SulfateConcentrationMeasurement                                     | 0x0424 |
| BromodichloromethaneConcentrationMeasurement                        | 0x0425 |
| BromoformConcentrationMeasurement                                   | 0x0426 |
| ChlorodibromomethaneConcentrationMeasurement                        | 0x0427 |
| ChloroformConcentrationMeasurement                                  | 0x0428 |
| SodiumConcentrationMeasurement                                      | 0x0429 |
| IasZone                                                             | 0x0500 |
| IasAce                                                              | 0x0501 |
| IasWd                                                               | 0x0502 |
| WakeOnLan                                                           | 0x0503 |
| Channel                                                             | 0x0504 |
| TargetNavigator                                                     | 0x0505 |
| MediaPlayback                                                       | 0x0506 |
| MediaInput                                                          | 0x0507 |
| LowPower                                                            | 0x0508 |
| KeypadInput                                                         | 0x0509 |
| ContentLauncher                                                     | 0x050A |
| AudioOutput                                                         | 0x050B |
| ApplicationLauncher                                                 | 0x050C |
| ApplicationBasic                                                    | 0x050D |
| AccountLogin                                                        | 0x050E |
| TestCluster                                                         | 0x050F |
| Messaging                                                           | 0x0703 |
| ApplianceIdentification                                             | 0x0B00 |
| MeterIdentification                                                 | 0x0B01 |
| ApplianceEventsAndAlert                                             | 0x0B02 |
| ApplianceStatistics                                                 | 0x0B03 |
| ElectricalMeasurement                                               | 0x0B04 |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
| Cluster AccessControl                                               | 0x001F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Acl                                                               | 0x0000 |
| * Extension                                                         | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * AccessControlEntryChanged                                         | 0x0000 |
| * AccessControlExtensionChanged                                     | 0x0001 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Acl
 */
class ReadAccessControlAcl : public ModelCommand {
public:
    ReadAccessControlAcl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "acl");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAcl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeAclWithParams:params
                          completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                              NSLog(@"AccessControl.Acl response %@", [value description]);
                              err = [CHIPError errorToCHIPErrorCode:error];

                              ChipLogError(chipTool, "AccessControl Acl Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];
        return err;
    }
};

class SubscribeAttributeAccessControlAcl : public ModelCommand {
public:
    SubscribeAttributeAccessControlAcl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "acl");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlAcl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAclWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                               params:params
                              subscriptionEstablished:NULL
                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                            NSLog(@"AccessControl.Acl response %@", [value description]);
                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Extension
 */
class ReadAccessControlExtension : public ModelCommand {
public:
    ReadAccessControlExtension()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "extension");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlExtension() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeExtensionWithParams:params
                                completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                    NSLog(@"AccessControl.Extension response %@", [value description]);
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogError(chipTool, "AccessControl Extension Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }
};

class SubscribeAttributeAccessControlExtension : public ModelCommand {
public:
    SubscribeAttributeAccessControlExtension()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "extension");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlExtension() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeExtensionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"AccessControl.Extension response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadAccessControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadAccessControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AccessControl.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AccessControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeAccessControlServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAccessControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"AccessControl.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadAccessControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadAccessControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AccessControl.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AccessControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeAccessControlClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAccessControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"AccessControl.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAccessControlAttributeList : public ModelCommand {
public:
    ReadAccessControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeAccessControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AccessControl.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAccessControlClusterRevision : public ModelCommand {
public:
    ReadAccessControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccessControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeAccessControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccessControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AccessControl.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AccountLogin                                                | 0x050E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GetSetupPIN                                                       |   0x00 |
| * Login                                                             |   0x02 |
| * Logout                                                            |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command GetSetupPIN
 */
class AccountLoginGetSetupPIN : public ModelCommand {
public:
    AccountLoginGetSetupPIN()
        : ModelCommand("get-setup-pin")
    {
        AddArgument("TempAccountIdentifier", &mTempAccountIdentifier);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAccountLoginClusterGetSetupPINParams alloc] init];
        params.tempAccountIdentifier = [[NSString alloc] initWithBytes:mTempAccountIdentifier.data()
                                                                length:mTempAccountIdentifier.size()
                                                              encoding:NSUTF8StringEncoding];
        [cluster getSetupPINWithParams:params
                     completionHandler:^(
                         CHIPAccountLoginClusterGetSetupPINResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    chip::ByteSpan mTempAccountIdentifier;
};

/*
 * Command Login
 */
class AccountLoginLogin : public ModelCommand {
public:
    AccountLoginLogin()
        : ModelCommand("login")
    {
        AddArgument("TempAccountIdentifier", &mTempAccountIdentifier);
        AddArgument("SetupPIN", &mSetupPIN);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAccountLoginClusterLoginParams alloc] init];
        params.tempAccountIdentifier = [[NSString alloc] initWithBytes:mTempAccountIdentifier.data()
                                                                length:mTempAccountIdentifier.size()
                                                              encoding:NSUTF8StringEncoding];
        params.setupPIN = [[NSString alloc] initWithBytes:mSetupPIN.data() length:mSetupPIN.size() encoding:NSUTF8StringEncoding];
        [cluster loginWithParams:params
               completionHandler:^(NSError * _Nullable error) {
                   err = [CHIPError errorToCHIPErrorCode:error];
                   ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                   SetCommandExitStatus(err);
               }];
        return err;
    }

private:
    chip::ByteSpan mTempAccountIdentifier;
    chip::ByteSpan mSetupPIN;
};

/*
 * Command Logout
 */
class AccountLoginLogout : public ModelCommand {
public:
    AccountLoginLogout()
        : ModelCommand("logout")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster logoutWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadAccountLoginServerGeneratedCommandList : public ModelCommand {
public:
    ReadAccountLoginServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AccountLogin.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AccountLogin ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeAccountLoginServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAccountLoginServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccountLoginServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"AccountLogin.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadAccountLoginClientGeneratedCommandList : public ModelCommand {
public:
    ReadAccountLoginClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AccountLogin.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AccountLogin ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeAccountLoginClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAccountLoginClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccountLoginClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"AccountLogin.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAccountLoginAttributeList : public ModelCommand {
public:
    ReadAccountLoginAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccountLogin.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccountLogin AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccountLoginAttributeList : public ModelCommand {
public:
    SubscribeAttributeAccountLoginAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccountLoginAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AccountLogin.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAccountLoginClusterRevision : public ModelCommand {
public:
    ReadAccountLoginClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccountLogin.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccountLogin ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAccountLoginClusterRevision : public ModelCommand {
public:
    SubscribeAttributeAccountLoginClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAccountLoginClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AccountLogin.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AdministratorCommissioning                                  | 0x003C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * OpenCommissioningWindow                                           |   0x00 |
| * OpenBasicCommissioningWindow                                      |   0x01 |
| * RevokeCommissioning                                               |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * WindowStatus                                                      | 0x0000 |
| * AdminFabricIndex                                                  | 0x0001 |
| * AdminVendorId                                                     | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command OpenBasicCommissioningWindow
 */
class AdministratorCommissioningOpenBasicCommissioningWindow : public ModelCommand {
public:
    AdministratorCommissioningOpenBasicCommissioningWindow()
        : ModelCommand("open-basic-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mCommissioningTimeout);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAdministratorCommissioningClusterOpenBasicCommissioningWindowParams alloc] init];
        params.commissioningTimeout = [NSNumber numberWithUnsignedShort:mCommissioningTimeout];
        [cluster openBasicCommissioningWindowWithParams:params
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    uint16_t mCommissioningTimeout;
};

/*
 * Command OpenCommissioningWindow
 */
class AdministratorCommissioningOpenCommissioningWindow : public ModelCommand {
public:
    AdministratorCommissioningOpenCommissioningWindow()
        : ModelCommand("open-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mCommissioningTimeout);
        AddArgument("Discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("Iterations", 0, UINT32_MAX, &mIterations);
        AddArgument("PasscodeID", 0, UINT16_MAX, &mPasscodeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAdministratorCommissioningClusterOpenCommissioningWindowParams alloc] init];
        params.commissioningTimeout = [NSNumber numberWithUnsignedShort:mCommissioningTimeout];
        params.pakeVerifier = [[NSData alloc] initWithBytes:mPAKEVerifier.data() length:mPAKEVerifier.size()];
        params.discriminator = [NSNumber numberWithUnsignedShort:mDiscriminator];
        params.iterations = [NSNumber numberWithUnsignedInt:mIterations];
        params.salt = [[NSData alloc] initWithBytes:mSalt.data() length:mSalt.size()];
        params.passcodeID = [NSNumber numberWithUnsignedShort:mPasscodeID];
        [cluster openCommissioningWindowWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
    uint16_t mCommissioningTimeout;
    chip::ByteSpan mPAKEVerifier;
    uint16_t mDiscriminator;
    uint32_t mIterations;
    chip::ByteSpan mSalt;
    uint16_t mPasscodeID;
};

/*
 * Command RevokeCommissioning
 */
class AdministratorCommissioningRevokeCommissioning : public ModelCommand {
public:
    AdministratorCommissioningRevokeCommissioning()
        : ModelCommand("revoke-commissioning")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster revokeCommissioningWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute WindowStatus
 */
class ReadAdministratorCommissioningWindowStatus : public ModelCommand {
public:
    ReadAdministratorCommissioningWindowStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "window-status");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningWindowStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWindowStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.WindowStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning WindowStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningWindowStatus : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningWindowStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "window-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningWindowStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeWindowStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"AdministratorCommissioning.WindowStatus response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AdminFabricIndex
 */
class ReadAdministratorCommissioningAdminFabricIndex : public ModelCommand {
public:
    ReadAdministratorCommissioningAdminFabricIndex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "admin-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAdminFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAdminFabricIndexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AdminFabricIndex response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AdminFabricIndex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningAdminFabricIndex : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningAdminFabricIndex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "admin-fabric-index");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningAdminFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAdminFabricIndexWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"AdministratorCommissioning.AdminFabricIndex response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AdminVendorId
 */
class ReadAdministratorCommissioningAdminVendorId : public ModelCommand {
public:
    ReadAdministratorCommissioningAdminVendorId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "admin-vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAdminVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAdminVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AdminVendorId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AdminVendorId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningAdminVendorId : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningAdminVendorId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "admin-vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningAdminVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAdminVendorIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AdministratorCommissioning.AdminVendorId response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadAdministratorCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReadAdministratorCommissioningServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AdministratorCommissioning.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AdministratorCommissioning ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"AdministratorCommissioning.ServerGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadAdministratorCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReadAdministratorCommissioningClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AdministratorCommissioning.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AdministratorCommissioning ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"AdministratorCommissioning.ClientGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAdministratorCommissioningAttributeList : public ModelCommand {
public:
    ReadAdministratorCommissioningAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningAttributeList : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AdministratorCommissioning.AttributeList response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAdministratorCommissioningClusterRevision : public ModelCommand {
public:
    ReadAdministratorCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAdministratorCommissioningClusterRevision : public ModelCommand {
public:
    SubscribeAttributeAdministratorCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAdministratorCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AdministratorCommissioning.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationBasic                                            | 0x050D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * VendorName                                                        | 0x0000 |
| * VendorID                                                          | 0x0001 |
| * ApplicationName                                                   | 0x0002 |
| * ProductID                                                         | 0x0003 |
| * Application                                                       | 0x0004 |
| * Status                                                            | 0x0005 |
| * ApplicationVersion                                                | 0x0006 |
| * AllowedVendorList                                                 | 0x0007 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute VendorName
 */
class ReadApplicationBasicVendorName : public ModelCommand {
public:
    ReadApplicationBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.VendorName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicVendorName : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ApplicationBasic.VendorName response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadApplicationBasicVendorID : public ModelCommand {
public:
    ReadApplicationBasicVendorID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.VendorID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic VendorID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicVendorID : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicVendorID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ApplicationBasic.VendorID response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationName
 */
class ReadApplicationBasicApplicationName : public ModelCommand {
public:
    ReadApplicationBasicApplicationName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeApplicationNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ApplicationName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ApplicationName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicApplicationName : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicApplicationName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicApplicationName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeApplicationNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ApplicationBasic.ApplicationName response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductID
 */
class ReadApplicationBasicProductID : public ModelCommand {
public:
    ReadApplicationBasicProductID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ProductID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ProductID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicProductID : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicProductID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ApplicationBasic.ProductID response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Application
 */
class ReadApplicationBasicApplication : public ModelCommand {
public:
    ReadApplicationBasicApplication()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplication() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeApplicationWithCompletionHandler:^(
            CHIPApplicationBasicClusterApplicationBasicApplication * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.Application response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic Application Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

/*
 * Attribute Status
 */
class ReadApplicationBasicStatus : public ModelCommand {
public:
    ReadApplicationBasicStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "status");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.Status response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic Status Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicStatus : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"ApplicationBasic.Status response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationVersion
 */
class ReadApplicationBasicApplicationVersion : public ModelCommand {
public:
    ReadApplicationBasicApplicationVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application-version");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeApplicationVersionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ApplicationVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ApplicationVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicApplicationVersion : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicApplicationVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicApplicationVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeApplicationVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"ApplicationBasic.ApplicationVersion response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AllowedVendorList
 */
class ReadApplicationBasicAllowedVendorList : public ModelCommand {
public:
    ReadApplicationBasicAllowedVendorList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "allowed-vendor-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAllowedVendorList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAllowedVendorListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.AllowedVendorList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic AllowedVendorList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicAllowedVendorList : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicAllowedVendorList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "allowed-vendor-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicAllowedVendorList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAllowedVendorListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ApplicationBasic.AllowedVendorList response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadApplicationBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationBasicServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ApplicationBasic.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ApplicationBasic ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ApplicationBasic.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadApplicationBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationBasicClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ApplicationBasic.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ApplicationBasic ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ApplicationBasic.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadApplicationBasicAttributeList : public ModelCommand {
public:
    ReadApplicationBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicAttributeList : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ApplicationBasic.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationBasicClusterRevision : public ModelCommand {
public:
    ReadApplicationBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationBasicClusterRevision : public ModelCommand {
public:
    SubscribeAttributeApplicationBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ApplicationBasic.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationLauncher                                         | 0x050C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LaunchApp                                                         |   0x00 |
| * StopApp                                                           |   0x01 |
| * HideApp                                                           |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CatalogList                                                       | 0x0000 |
| * CurrentApp                                                        | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command HideApp
 */
class ApplicationLauncherHideApp : public ModelCommand {
public:
    ApplicationLauncherHideApp()
        : ModelCommand("hide-app")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPApplicationLauncherClusterHideAppParams alloc] init];
        // application Struct parsing is not supported yet
        [cluster hideAppWithParams:params
                 completionHandler:^(
                     CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     err = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];
        return err;
    }

private:
};

/*
 * Command LaunchApp
 */
class ApplicationLauncherLaunchApp : public ModelCommand {
public:
    ApplicationLauncherLaunchApp()
        : ModelCommand("launch-app")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPApplicationLauncherClusterLaunchAppParams alloc] init];
        // application Struct parsing is not supported yet
        params.data = [[NSData alloc] initWithBytes:mData.data() length:mData.size()];
        [cluster launchAppWithParams:params
                   completionHandler:^(
                       CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       err = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];
        return err;
    }

private:
    chip::ByteSpan mData;
};

/*
 * Command StopApp
 */
class ApplicationLauncherStopApp : public ModelCommand {
public:
    ApplicationLauncherStopApp()
        : ModelCommand("stop-app")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPApplicationLauncherClusterStopAppParams alloc] init];
        // application Struct parsing is not supported yet
        [cluster stopAppWithParams:params
                 completionHandler:^(
                     CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     err = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];
        return err;
    }

private:
};

/*
 * Attribute CatalogList
 */
class ReadApplicationLauncherCatalogList : public ModelCommand {
public:
    ReadApplicationLauncherCatalogList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "catalog-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherCatalogList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCatalogListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.CatalogList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher CatalogList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherCatalogList : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherCatalogList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "catalog-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherCatalogList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCatalogListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ApplicationLauncher.CatalogList response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentApp
 */
class ReadApplicationLauncherCurrentApp : public ModelCommand {
public:
    ReadApplicationLauncherCurrentApp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-app");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherCurrentApp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentAppWithCompletionHandler:^(
            CHIPApplicationLauncherClusterApplicationEP * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.CurrentApp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher CurrentApp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteApplicationLauncherCurrentApp : public ModelCommand {
public:
    WriteApplicationLauncherCurrentApp()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "current-app");
        ModelCommand::AddArguments();
    }

    ~WriteApplicationLauncherCurrentApp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        CHIPApplicationLauncherClusterApplicationEP * value = [[CHIPApplicationLauncherClusterApplicationEP alloc] init];

        [cluster writeAttributeCurrentAppWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "ApplicationLauncher CurrentApp Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadApplicationLauncherServerGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationLauncherServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ApplicationLauncher.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ApplicationLauncher ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ApplicationLauncher.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadApplicationLauncherClientGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationLauncherClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ApplicationLauncher.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ApplicationLauncher ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ApplicationLauncher.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadApplicationLauncherAttributeList : public ModelCommand {
public:
    ReadApplicationLauncherAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherAttributeList : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ApplicationLauncher.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationLauncherClusterRevision : public ModelCommand {
public:
    ReadApplicationLauncherClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeApplicationLauncherClusterRevision : public ModelCommand {
public:
    SubscribeAttributeApplicationLauncherClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeApplicationLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ApplicationLauncher.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AudioOutput                                                 | 0x050B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SelectOutput                                                      |   0x00 |
| * RenameOutput                                                      |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OutputList                                                        | 0x0000 |
| * CurrentOutput                                                     | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RenameOutput
 */
class AudioOutputRenameOutput : public ModelCommand {
public:
    AudioOutputRenameOutput()
        : ModelCommand("rename-output")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        AddArgument("Name", &mName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAudioOutputClusterRenameOutputParams alloc] init];
        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        params.name = [[NSString alloc] initWithBytes:mName.data() length:mName.size() encoding:NSUTF8StringEncoding];
        [cluster renameOutputWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    uint8_t mIndex;
    chip::ByteSpan mName;
};

/*
 * Command SelectOutput
 */
class AudioOutputSelectOutput : public ModelCommand {
public:
    AudioOutputSelectOutput()
        : ModelCommand("select-output")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPAudioOutputClusterSelectOutputParams alloc] init];
        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        [cluster selectOutputWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    uint8_t mIndex;
};

/*
 * Attribute OutputList
 */
class ReadAudioOutputOutputList : public ModelCommand {
public:
    ReadAudioOutputOutputList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "output-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputOutputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOutputListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.OutputList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput OutputList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputOutputList : public ModelCommand {
public:
    SubscribeAttributeAudioOutputOutputList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "output-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputOutputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOutputListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"AudioOutput.OutputList response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentOutput
 */
class ReadAudioOutputCurrentOutput : public ModelCommand {
public:
    ReadAudioOutputCurrentOutput()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-output");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputCurrentOutput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentOutputWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.CurrentOutput response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput CurrentOutput Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputCurrentOutput : public ModelCommand {
public:
    SubscribeAttributeAudioOutputCurrentOutput()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-output");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputCurrentOutput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentOutputWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AudioOutput.CurrentOutput response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadAudioOutputServerGeneratedCommandList : public ModelCommand {
public:
    ReadAudioOutputServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AudioOutput.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AudioOutput ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeAudioOutputServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAudioOutputServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"AudioOutput.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadAudioOutputClientGeneratedCommandList : public ModelCommand {
public:
    ReadAudioOutputClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AudioOutput.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AudioOutput ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeAudioOutputClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeAudioOutputClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"AudioOutput.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAudioOutputAttributeList : public ModelCommand {
public:
    ReadAudioOutputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputAttributeList : public ModelCommand {
public:
    SubscribeAttributeAudioOutputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"AudioOutput.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAudioOutputClusterRevision : public ModelCommand {
public:
    ReadAudioOutputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeAudioOutputClusterRevision : public ModelCommand {
public:
    SubscribeAttributeAudioOutputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeAudioOutputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"AudioOutput.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BarrierControl                                              | 0x0103 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * BarrierControlGoToPercent                                         |   0x00 |
| * BarrierControlStop                                                |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * BarrierMovingState                                                | 0x0001 |
| * BarrierSafetyStatus                                               | 0x0002 |
| * BarrierCapabilities                                               | 0x0003 |
| * BarrierOpenEvents                                                 | 0x0004 |
| * BarrierCloseEvents                                                | 0x0005 |
| * BarrierCommandOpenEvents                                          | 0x0006 |
| * BarrierCommandCloseEvents                                         | 0x0007 |
| * BarrierOpenPeriod                                                 | 0x0008 |
| * BarrierClosePeriod                                                | 0x0009 |
| * BarrierPosition                                                   | 0x000A |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command BarrierControlGoToPercent
 */
class BarrierControlBarrierControlGoToPercent : public ModelCommand {
public:
    BarrierControlBarrierControlGoToPercent()
        : ModelCommand("barrier-control-go-to-percent")
    {
        AddArgument("PercentOpen", 0, UINT8_MAX, &mPercentOpen);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBarrierControlClusterBarrierControlGoToPercentParams alloc] init];
        params.percentOpen = [NSNumber numberWithUnsignedChar:mPercentOpen];
        [cluster barrierControlGoToPercentWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint8_t mPercentOpen;
};

/*
 * Command BarrierControlStop
 */
class BarrierControlBarrierControlStop : public ModelCommand {
public:
    BarrierControlBarrierControlStop()
        : ModelCommand("barrier-control-stop")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster barrierControlStopWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute BarrierMovingState
 */
class ReadBarrierControlBarrierMovingState : public ModelCommand {
public:
    ReadBarrierControlBarrierMovingState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-moving-state");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierMovingState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBarrierMovingStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierMovingState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierMovingState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlBarrierMovingState : public ModelCommand {
public:
    SubscribeAttributeBarrierControlBarrierMovingState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-moving-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlBarrierMovingState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBarrierMovingStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BarrierControl.BarrierMovingState response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierSafetyStatus
 */
class ReadBarrierControlBarrierSafetyStatus : public ModelCommand {
public:
    ReadBarrierControlBarrierSafetyStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBarrierSafetyStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierSafetyStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierSafetyStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlBarrierSafetyStatus : public ModelCommand {
public:
    SubscribeAttributeBarrierControlBarrierSafetyStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlBarrierSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBarrierSafetyStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"BarrierControl.BarrierSafetyStatus response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierCapabilities
 */
class ReadBarrierControlBarrierCapabilities : public ModelCommand {
public:
    ReadBarrierControlBarrierCapabilities()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBarrierCapabilitiesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierCapabilities response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierCapabilities Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlBarrierCapabilities : public ModelCommand {
public:
    SubscribeAttributeBarrierControlBarrierCapabilities()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlBarrierCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBarrierCapabilitiesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"BarrierControl.BarrierCapabilities response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierPosition
 */
class ReadBarrierControlBarrierPosition : public ModelCommand {
public:
    ReadBarrierControlBarrierPosition()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-position");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBarrierPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierPosition response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierPosition Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlBarrierPosition : public ModelCommand {
public:
    SubscribeAttributeBarrierControlBarrierPosition()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlBarrierPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBarrierPositionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BarrierControl.BarrierPosition response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBarrierControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadBarrierControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BarrierControl.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BarrierControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBarrierControlServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBarrierControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BarrierControl.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBarrierControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadBarrierControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BarrierControl.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BarrierControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBarrierControlClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBarrierControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BarrierControl.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBarrierControlAttributeList : public ModelCommand {
public:
    ReadBarrierControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeBarrierControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BarrierControl.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBarrierControlClusterRevision : public ModelCommand {
public:
    ReadBarrierControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBarrierControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBarrierControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBarrierControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BarrierControl.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Basic                                                       | 0x0028 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MfgSpecificPing                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DataModelRevision                                                 | 0x0000 |
| * VendorName                                                        | 0x0001 |
| * VendorID                                                          | 0x0002 |
| * ProductName                                                       | 0x0003 |
| * ProductID                                                         | 0x0004 |
| * NodeLabel                                                         | 0x0005 |
| * Location                                                          | 0x0006 |
| * HardwareVersion                                                   | 0x0007 |
| * HardwareVersionString                                             | 0x0008 |
| * SoftwareVersion                                                   | 0x0009 |
| * SoftwareVersionString                                             | 0x000A |
| * ManufacturingDate                                                 | 0x000B |
| * PartNumber                                                        | 0x000C |
| * ProductURL                                                        | 0x000D |
| * ProductLabel                                                      | 0x000E |
| * SerialNumber                                                      | 0x000F |
| * LocalConfigDisabled                                               | 0x0010 |
| * Reachable                                                         | 0x0011 |
| * UniqueID                                                          | 0x0012 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StartUp                                                           | 0x0000 |
| * ShutDown                                                          | 0x0001 |
| * Leave                                                             | 0x0002 |
| * ReachableChanged                                                  | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute DataModelRevision
 */
class ReadBasicDataModelRevision : public ModelCommand {
public:
    ReadBasicDataModelRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "data-model-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBasicDataModelRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDataModelRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.DataModelRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic DataModelRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicDataModelRevision : public ModelCommand {
public:
    SubscribeAttributeBasicDataModelRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "data-model-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicDataModelRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDataModelRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"Basic.DataModelRevision response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorName
 */
class ReadBasicVendorName : public ModelCommand {
public:
    ReadBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.VendorName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicVendorName : public ModelCommand {
public:
    SubscribeAttributeBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Basic.VendorName response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadBasicVendorID : public ModelCommand {
public:
    ReadBasicVendorID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.VendorID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic VendorID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicVendorID : public ModelCommand {
public:
    SubscribeAttributeBasicVendorID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"Basic.VendorID response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductName
 */
class ReadBasicProductName : public ModelCommand {
public:
    ReadBasicProductName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicProductName : public ModelCommand {
public:
    SubscribeAttributeBasicProductName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Basic.ProductName response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductID
 */
class ReadBasicProductID : public ModelCommand {
public:
    ReadBasicProductID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicProductID : public ModelCommand {
public:
    SubscribeAttributeBasicProductID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"Basic.ProductID response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NodeLabel
 */
class ReadBasicNodeLabel : public ModelCommand {
public:
    ReadBasicNodeLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "node-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNodeLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.NodeLabel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic NodeLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBasicNodeLabel : public ModelCommand {
public:
    WriteBasicNodeLabel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeNodeLabelWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    err = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogError(chipTool, "Basic NodeLabel Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeBasicNodeLabel : public ModelCommand {
public:
    SubscribeAttributeBasicNodeLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNodeLabelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"Basic.NodeLabel response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Location
 */
class ReadBasicLocation : public ModelCommand {
public:
    ReadBasicLocation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "location");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLocationWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.Location response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic Location Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBasicLocation : public ModelCommand {
public:
    WriteBasicLocation()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "location");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLocationWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "Basic Location Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeBasicLocation : public ModelCommand {
public:
    SubscribeAttributeBasicLocation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "location");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLocationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"Basic.Location response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersion
 */
class ReadBasicHardwareVersion : public ModelCommand {
public:
    ReadBasicHardwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHardwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.HardwareVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic HardwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicHardwareVersion : public ModelCommand {
public:
    SubscribeAttributeBasicHardwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeHardwareVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Basic.HardwareVersion response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersionString
 */
class ReadBasicHardwareVersionString : public ModelCommand {
public:
    ReadBasicHardwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHardwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.HardwareVersionString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic HardwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicHardwareVersionString : public ModelCommand {
public:
    SubscribeAttributeBasicHardwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeHardwareVersionStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"Basic.HardwareVersionString response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersion
 */
class ReadBasicSoftwareVersion : public ModelCommand {
public:
    ReadBasicSoftwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoftwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SoftwareVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SoftwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicSoftwareVersion : public ModelCommand {
public:
    SubscribeAttributeBasicSoftwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSoftwareVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Basic.SoftwareVersion response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersionString
 */
class ReadBasicSoftwareVersionString : public ModelCommand {
public:
    ReadBasicSoftwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoftwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SoftwareVersionString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SoftwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicSoftwareVersionString : public ModelCommand {
public:
    SubscribeAttributeBasicSoftwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSoftwareVersionStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"Basic.SoftwareVersionString response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ManufacturingDate
 */
class ReadBasicManufacturingDate : public ModelCommand {
public:
    ReadBasicManufacturingDate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "manufacturing-date");
        ModelCommand::AddArguments();
    }

    ~ReadBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeManufacturingDateWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ManufacturingDate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ManufacturingDate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicManufacturingDate : public ModelCommand {
public:
    SubscribeAttributeBasicManufacturingDate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "manufacturing-date");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeManufacturingDateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"Basic.ManufacturingDate response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartNumber
 */
class ReadBasicPartNumber : public ModelCommand {
public:
    ReadBasicPartNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "part-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.PartNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic PartNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicPartNumber : public ModelCommand {
public:
    SubscribeAttributeBasicPartNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "part-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Basic.PartNumber response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductURL
 */
class ReadBasicProductURL : public ModelCommand {
public:
    ReadBasicProductURL()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-url");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductURLWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductURL response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductURL Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicProductURL : public ModelCommand {
public:
    SubscribeAttributeBasicProductURL()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductURLWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Basic.ProductURL response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductLabel
 */
class ReadBasicProductLabel : public ModelCommand {
public:
    ReadBasicProductLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductLabel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicProductLabel : public ModelCommand {
public:
    SubscribeAttributeBasicProductLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductLabelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Basic.ProductLabel response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SerialNumber
 */
class ReadBasicSerialNumber : public ModelCommand {
public:
    ReadBasicSerialNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "serial-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSerialNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SerialNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SerialNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicSerialNumber : public ModelCommand {
public:
    SubscribeAttributeBasicSerialNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "serial-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSerialNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Basic.SerialNumber response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocalConfigDisabled
 */
class ReadBasicLocalConfigDisabled : public ModelCommand {
public:
    ReadBasicLocalConfigDisabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "local-config-disabled");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLocalConfigDisabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.LocalConfigDisabled response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic LocalConfigDisabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBasicLocalConfigDisabled : public ModelCommand {
public:
    WriteBasicLocalConfigDisabled()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeLocalConfigDisabledWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              err = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(chipTool, "Basic LocalConfigDisabled Error: %s", chip::ErrorStr(err));
                                              SetCommandExitStatus(err);
                                          }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeBasicLocalConfigDisabled : public ModelCommand {
public:
    SubscribeAttributeBasicLocalConfigDisabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLocalConfigDisabledWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Basic.LocalConfigDisabled response %@", [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Reachable
 */
class ReadBasicReachable : public ModelCommand {
public:
    ReadBasicReachable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reachable");
        ModelCommand::AddArguments();
    }

    ~ReadBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeReachableWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.Reachable response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic Reachable Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicReachable : public ModelCommand {
public:
    SubscribeAttributeBasicReachable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reachable");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeReachableWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"Basic.Reachable response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UniqueID
 */
class ReadBasicUniqueID : public ModelCommand {
public:
    ReadBasicUniqueID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "unique-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUniqueIDWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.UniqueID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic UniqueID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicUniqueID : public ModelCommand {
public:
    SubscribeAttributeBasicUniqueID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "unique-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUniqueIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"Basic.UniqueID response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReadBasicServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Basic.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Basic ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBasicServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBasicServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Basic.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReadBasicClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Basic.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Basic ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBasicClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBasicClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Basic.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBasicAttributeList : public ModelCommand {
public:
    ReadBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicAttributeList : public ModelCommand {
public:
    SubscribeAttributeBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Basic.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBasicClusterRevision : public ModelCommand {
public:
    ReadBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBasicClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Basic.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BinaryInputBasic                                            | 0x000F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActiveText                                                        | 0x0004 |
| * Description                                                       | 0x001C |
| * InactiveText                                                      | 0x002E |
| * OutOfService                                                      | 0x0051 |
| * Polarity                                                          | 0x0054 |
| * PresentValue                                                      | 0x0055 |
| * Reliability                                                       | 0x0067 |
| * StatusFlags                                                       | 0x006F |
| * ApplicationType                                                   | 0x0100 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute OutOfService
 */
class ReadBinaryInputBasicOutOfService : public ModelCommand {
public:
    ReadBinaryInputBasicOutOfService()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "out-of-service");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x00000051) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOutOfServiceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.OutOfService response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic OutOfService Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBinaryInputBasicOutOfService : public ModelCommand {
public:
    WriteBinaryInputBasicOutOfService()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) WriteAttribute (0x00000051) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeOutOfServiceWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "BinaryInputBasic OutOfService Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeBinaryInputBasicOutOfService : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicOutOfService()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x00000051) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOutOfServiceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BinaryInputBasic.OutOfService response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PresentValue
 */
class ReadBinaryInputBasicPresentValue : public ModelCommand {
public:
    ReadBinaryInputBasicPresentValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "present-value");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x00000055) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePresentValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.PresentValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic PresentValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBinaryInputBasicPresentValue : public ModelCommand {
public:
    WriteBinaryInputBasicPresentValue()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) WriteAttribute (0x00000055) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributePresentValueWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "BinaryInputBasic PresentValue Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeBinaryInputBasicPresentValue : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicPresentValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x00000055) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePresentValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BinaryInputBasic.PresentValue response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StatusFlags
 */
class ReadBinaryInputBasicStatusFlags : public ModelCommand {
public:
    ReadBinaryInputBasicStatusFlags()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "status-flags");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicStatusFlags() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000006F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.StatusFlags response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic StatusFlags Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicStatusFlags : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicStatusFlags()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "status-flags");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicStatusFlags() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000006F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStatusFlagsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"BinaryInputBasic.StatusFlags response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBinaryInputBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReadBinaryInputBasicServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BinaryInputBasic.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BinaryInputBasic ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BinaryInputBasic.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBinaryInputBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReadBinaryInputBasicClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BinaryInputBasic.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BinaryInputBasic ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BinaryInputBasic.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBinaryInputBasicAttributeList : public ModelCommand {
public:
    ReadBinaryInputBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicAttributeList : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BinaryInputBasic.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBinaryInputBasicClusterRevision : public ModelCommand {
public:
    ReadBinaryInputBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBinaryInputBasicClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBinaryInputBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBinaryInputBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BinaryInputBasic.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Binding                                                     | 0x001E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Binding                                                           | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Binding
 */
class ReadBindingBinding : public ModelCommand {
public:
    ReadBindingBinding()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "binding");
        ModelCommand::AddArguments();
    }

    ~ReadBindingBinding() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeBindingWithParams:params
                              completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                  NSLog(@"Binding.Binding response %@", [value description]);
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "Binding Binding Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }
};

class SubscribeAttributeBindingBinding : public ModelCommand {
public:
    SubscribeAttributeBindingBinding()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "binding");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingBinding() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBindingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"Binding.Binding response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBindingServerGeneratedCommandList : public ModelCommand {
public:
    ReadBindingServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Binding.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Binding ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBindingServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBindingServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Binding.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBindingClientGeneratedCommandList : public ModelCommand {
public:
    ReadBindingClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Binding.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Binding ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBindingClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBindingClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Binding.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBindingAttributeList : public ModelCommand {
public:
    ReadBindingAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Binding.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Binding AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBindingAttributeList : public ModelCommand {
public:
    SubscribeAttributeBindingAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Binding.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBindingClusterRevision : public ModelCommand {
public:
    ReadBindingClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBindingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Binding.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Binding ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBindingClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBindingClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBindingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Binding.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BooleanState                                                | 0x0045 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * StateValue                                                        | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateChange                                                       | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute StateValue
 */
class ReadBooleanStateStateValue : public ModelCommand {
public:
    ReadBooleanStateStateValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "state-value");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateStateValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStateValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.StateValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState StateValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBooleanStateStateValue : public ModelCommand {
public:
    SubscribeAttributeBooleanStateStateValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "state-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateStateValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStateValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BooleanState.StateValue response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBooleanStateServerGeneratedCommandList : public ModelCommand {
public:
    ReadBooleanStateServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BooleanState.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BooleanState ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBooleanStateServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBooleanStateServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BooleanState.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBooleanStateClientGeneratedCommandList : public ModelCommand {
public:
    ReadBooleanStateClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BooleanState.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BooleanState ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBooleanStateClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBooleanStateClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BooleanState.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBooleanStateAttributeList : public ModelCommand {
public:
    ReadBooleanStateAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBooleanStateAttributeList : public ModelCommand {
public:
    SubscribeAttributeBooleanStateAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BooleanState.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBooleanStateClusterRevision : public ModelCommand {
public:
    ReadBooleanStateClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBooleanStateClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBooleanStateClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBooleanStateClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BooleanState.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedActions                                              | 0x0025 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * InstantAction                                                     |   0x00 |
| * InstantActionWithTransition                                       |   0x01 |
| * StartAction                                                       |   0x02 |
| * StartActionWithDuration                                           |   0x03 |
| * StopAction                                                        |   0x04 |
| * PauseAction                                                       |   0x05 |
| * PauseActionWithDuration                                           |   0x06 |
| * ResumeAction                                                      |   0x07 |
| * EnableAction                                                      |   0x08 |
| * EnableActionWithDuration                                          |   0x09 |
| * DisableAction                                                     |   0x0A |
| * DisableActionWithDuration                                         |   0x0B |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActionList                                                        | 0x0000 |
| * EndpointList                                                      | 0x0001 |
| * SetupUrl                                                          | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateChanged                                                      | 0x0000 |
| * ActionFailed                                                      | 0x0001 |
\*----------------------------------------------------------------------------*/

/*
 * Command DisableAction
 */
class BridgedActionsDisableAction : public ModelCommand {
public:
    BridgedActionsDisableAction()
        : ModelCommand("disable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterDisableActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster disableActionWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command DisableActionWithDuration
 */
class BridgedActionsDisableActionWithDuration : public ModelCommand {
public:
    BridgedActionsDisableActionWithDuration()
        : ModelCommand("disable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterDisableActionWithDurationParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster disableActionWithDurationWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command EnableAction
 */
class BridgedActionsEnableAction : public ModelCommand {
public:
    BridgedActionsEnableAction()
        : ModelCommand("enable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterEnableActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster enableActionWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command EnableActionWithDuration
 */
class BridgedActionsEnableActionWithDuration : public ModelCommand {
public:
    BridgedActionsEnableActionWithDuration()
        : ModelCommand("enable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterEnableActionWithDurationParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster enableActionWithDurationWithParams:params
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command InstantAction
 */
class BridgedActionsInstantAction : public ModelCommand {
public:
    BridgedActionsInstantAction()
        : ModelCommand("instant-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterInstantActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster instantActionWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command InstantActionWithTransition
 */
class BridgedActionsInstantActionWithTransition : public ModelCommand {
public:
    BridgedActionsInstantActionWithTransition()
        : ModelCommand("instant-action-with-transition")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterInstantActionWithTransitionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster instantActionWithTransitionWithParams:params
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint16_t mTransitionTime;
};

/*
 * Command PauseAction
 */
class BridgedActionsPauseAction : public ModelCommand {
public:
    BridgedActionsPauseAction()
        : ModelCommand("pause-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterPauseActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster pauseActionWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command PauseActionWithDuration
 */
class BridgedActionsPauseActionWithDuration : public ModelCommand {
public:
    BridgedActionsPauseActionWithDuration()
        : ModelCommand("pause-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterPauseActionWithDurationParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster pauseActionWithDurationWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command ResumeAction
 */
class BridgedActionsResumeAction : public ModelCommand {
public:
    BridgedActionsResumeAction()
        : ModelCommand("resume-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterResumeActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster resumeActionWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command StartAction
 */
class BridgedActionsStartAction : public ModelCommand {
public:
    BridgedActionsStartAction()
        : ModelCommand("start-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterStartActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster startActionWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command StartActionWithDuration
 */
class BridgedActionsStartActionWithDuration : public ModelCommand {
public:
    BridgedActionsStartActionWithDuration()
        : ModelCommand("start-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterStartActionWithDurationParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster startActionWithDurationWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command StopAction
 */
class BridgedActionsStopAction : public ModelCommand {
public:
    BridgedActionsStopAction()
        : ModelCommand("stop-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPBridgedActionsClusterStopActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster stopActionWithParams:params
                    completionHandler:^(NSError * _Nullable error) {
                        err = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];
        return err;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Attribute ActionList
 */
class ReadBridgedActionsActionList : public ModelCommand {
public:
    ReadBridgedActionsActionList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "action-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsActionList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActionListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.ActionList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions ActionList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsActionList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsActionList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "action-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsActionList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActionListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedActions.ActionList response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndpointList
 */
class ReadBridgedActionsEndpointList : public ModelCommand {
public:
    ReadBridgedActionsEndpointList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "endpoint-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsEndpointList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEndpointListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.EndpointList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions EndpointList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsEndpointList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsEndpointList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "endpoint-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsEndpointList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEndpointListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BridgedActions.EndpointList response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SetupUrl
 */
class ReadBridgedActionsSetupUrl : public ModelCommand {
public:
    ReadBridgedActionsSetupUrl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "setup-url");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsSetupUrl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSetupUrlWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.SetupUrl response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions SetupUrl Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsSetupUrl : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsSetupUrl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "setup-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsSetupUrl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSetupUrlWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"BridgedActions.SetupUrl response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBridgedActionsServerGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedActionsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BridgedActions.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BridgedActions ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BridgedActions.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBridgedActionsClientGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedActionsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BridgedActions.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BridgedActions ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BridgedActions.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBridgedActionsAttributeList : public ModelCommand {
public:
    ReadBridgedActionsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsAttributeList : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BridgedActions.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedActionsClusterRevision : public ModelCommand {
public:
    ReadBridgedActionsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedActionsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBridgedActionsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedActionsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"BridgedActions.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedDeviceBasic                                          | 0x0039 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * VendorName                                                        | 0x0001 |
| * VendorID                                                          | 0x0002 |
| * ProductName                                                       | 0x0003 |
| * NodeLabel                                                         | 0x0005 |
| * HardwareVersion                                                   | 0x0007 |
| * HardwareVersionString                                             | 0x0008 |
| * SoftwareVersion                                                   | 0x0009 |
| * SoftwareVersionString                                             | 0x000A |
| * ManufacturingDate                                                 | 0x000B |
| * PartNumber                                                        | 0x000C |
| * ProductURL                                                        | 0x000D |
| * ProductLabel                                                      | 0x000E |
| * SerialNumber                                                      | 0x000F |
| * Reachable                                                         | 0x0011 |
| * UniqueID                                                          | 0x0012 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StartUp                                                           | 0x0000 |
| * ShutDown                                                          | 0x0001 |
| * Leave                                                             | 0x0002 |
| * ReachableChanged                                                  | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute VendorName
 */
class ReadBridgedDeviceBasicVendorName : public ModelCommand {
public:
    ReadBridgedDeviceBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.VendorName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicVendorName : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.VendorName response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadBridgedDeviceBasicVendorID : public ModelCommand {
public:
    ReadBridgedDeviceBasicVendorID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.VendorID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic VendorID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicVendorID : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicVendorID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"BridgedDeviceBasic.VendorID response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductName
 */
class ReadBridgedDeviceBasicProductName : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-name");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicProductName : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicProductName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"BridgedDeviceBasic.ProductName response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NodeLabel
 */
class ReadBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    ReadBridgedDeviceBasicNodeLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "node-label");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNodeLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.NodeLabel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic NodeLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    WriteBridgedDeviceBasicNodeLabel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) WriteAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeNodeLabelWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    err = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogError(chipTool, "BridgedDeviceBasic NodeLabel Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicNodeLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNodeLabelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"BridgedDeviceBasic.NodeLabel response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersion
 */
class ReadBridgedDeviceBasicHardwareVersion : public ModelCommand {
public:
    ReadBridgedDeviceBasicHardwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHardwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.HardwareVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic HardwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicHardwareVersion : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicHardwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeHardwareVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.HardwareVersion response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersionString
 */
class ReadBridgedDeviceBasicHardwareVersionString : public ModelCommand {
public:
    ReadBridgedDeviceBasicHardwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHardwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.HardwareVersionString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic HardwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicHardwareVersionString : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicHardwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeHardwareVersionStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BridgedDeviceBasic.HardwareVersionString response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersion
 */
class ReadBridgedDeviceBasicSoftwareVersion : public ModelCommand {
public:
    ReadBridgedDeviceBasicSoftwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoftwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SoftwareVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SoftwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicSoftwareVersion : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicSoftwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSoftwareVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.SoftwareVersion response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersionString
 */
class ReadBridgedDeviceBasicSoftwareVersionString : public ModelCommand {
public:
    ReadBridgedDeviceBasicSoftwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoftwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SoftwareVersionString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SoftwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicSoftwareVersionString : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicSoftwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSoftwareVersionStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BridgedDeviceBasic.SoftwareVersionString response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ManufacturingDate
 */
class ReadBridgedDeviceBasicManufacturingDate : public ModelCommand {
public:
    ReadBridgedDeviceBasicManufacturingDate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "manufacturing-date");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeManufacturingDateWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ManufacturingDate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ManufacturingDate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicManufacturingDate : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicManufacturingDate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "manufacturing-date");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeManufacturingDateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"BridgedDeviceBasic.ManufacturingDate response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartNumber
 */
class ReadBridgedDeviceBasicPartNumber : public ModelCommand {
public:
    ReadBridgedDeviceBasicPartNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "part-number");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.PartNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic PartNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicPartNumber : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicPartNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "part-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.PartNumber response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductURL
 */
class ReadBridgedDeviceBasicProductURL : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductURL()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-url");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductURLWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductURL response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductURL Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicProductURL : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicProductURL()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductURLWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.ProductURL response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductLabel
 */
class ReadBridgedDeviceBasicProductLabel : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-label");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeProductLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductLabel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicProductLabel : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicProductLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeProductLabelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BridgedDeviceBasic.ProductLabel response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SerialNumber
 */
class ReadBridgedDeviceBasicSerialNumber : public ModelCommand {
public:
    ReadBridgedDeviceBasicSerialNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "serial-number");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSerialNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SerialNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SerialNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicSerialNumber : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicSerialNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "serial-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSerialNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"BridgedDeviceBasic.SerialNumber response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Reachable
 */
class ReadBridgedDeviceBasicReachable : public ModelCommand {
public:
    ReadBridgedDeviceBasicReachable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reachable");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeReachableWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.Reachable response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic Reachable Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicReachable : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicReachable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reachable");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeReachableWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"BridgedDeviceBasic.Reachable response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UniqueID
 */
class ReadBridgedDeviceBasicUniqueID : public ModelCommand {
public:
    ReadBridgedDeviceBasicUniqueID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "unique-id");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUniqueIDWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.UniqueID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic UniqueID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicUniqueID : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicUniqueID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "unique-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUniqueIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"BridgedDeviceBasic.UniqueID response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBridgedDeviceBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedDeviceBasicServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BridgedDeviceBasic.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BridgedDeviceBasic ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BridgedDeviceBasic.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBridgedDeviceBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedDeviceBasicClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BridgedDeviceBasic.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BridgedDeviceBasic ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"BridgedDeviceBasic.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBridgedDeviceBasicAttributeList : public ModelCommand {
public:
    ReadBridgedDeviceBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicAttributeList : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"BridgedDeviceBasic.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedDeviceBasicClusterRevision : public ModelCommand {
public:
    ReadBridgedDeviceBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeBridgedDeviceBasicClusterRevision : public ModelCommand {
public:
    SubscribeAttributeBridgedDeviceBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeBridgedDeviceBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"BridgedDeviceBasic.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Channel                                                     | 0x0504 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeChannel                                                     |   0x00 |
| * ChangeChannelByNumber                                             |   0x02 |
| * SkipChannel                                                       |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ChannelList                                                       | 0x0000 |
| * Lineup                                                            | 0x0001 |
| * CurrentChannel                                                    | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeChannel
 */
class ChannelChangeChannel : public ModelCommand {
public:
    ChannelChangeChannel()
        : ModelCommand("change-channel")
    {
        AddArgument("Match", &mMatch);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPChannelClusterChangeChannelParams alloc] init];
        params.match = [[NSString alloc] initWithBytes:mMatch.data() length:mMatch.size() encoding:NSUTF8StringEncoding];
        [cluster
            changeChannelWithParams:params
                  completionHandler:^(CHIPChannelClusterChangeChannelResponseParams * _Nullable values, NSError * _Nullable error) {
                      NSLog(@"Values: %@", values);
                      err = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];
        return err;
    }

private:
    chip::ByteSpan mMatch;
};

/*
 * Command ChangeChannelByNumber
 */
class ChannelChangeChannelByNumber : public ModelCommand {
public:
    ChannelChangeChannelByNumber()
        : ModelCommand("change-channel-by-number")
    {
        AddArgument("MajorNumber", 0, UINT16_MAX, &mMajorNumber);
        AddArgument("MinorNumber", 0, UINT16_MAX, &mMinorNumber);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPChannelClusterChangeChannelByNumberParams alloc] init];
        params.majorNumber = [NSNumber numberWithUnsignedShort:mMajorNumber];
        params.minorNumber = [NSNumber numberWithUnsignedShort:mMinorNumber];
        [cluster changeChannelByNumberWithParams:params
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    uint16_t mMajorNumber;
    uint16_t mMinorNumber;
};

/*
 * Command SkipChannel
 */
class ChannelSkipChannel : public ModelCommand {
public:
    ChannelSkipChannel()
        : ModelCommand("skip-channel")
    {
        AddArgument("Count", 0, UINT16_MAX, &mCount);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPChannelClusterSkipChannelParams alloc] init];
        params.count = [NSNumber numberWithUnsignedShort:mCount];
        [cluster skipChannelWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint16_t mCount;
};

/*
 * Attribute ChannelList
 */
class ReadChannelChannelList : public ModelCommand {
public:
    ReadChannelChannelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelChannelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChannelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.ChannelList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel ChannelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelChannelList : public ModelCommand {
public:
    SubscribeAttributeChannelChannelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelChannelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeChannelListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Channel.ChannelList response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Lineup
 */
class ReadChannelLineup : public ModelCommand {
public:
    ReadChannelLineup()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lineup");
        ModelCommand::AddArguments();
    }

    ~ReadChannelLineup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeLineupWithCompletionHandler:^(CHIPChannelClusterLineupInfo * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Channel.Lineup response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Channel Lineup Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

/*
 * Attribute CurrentChannel
 */
class ReadChannelCurrentChannel : public ModelCommand {
public:
    ReadChannelCurrentChannel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-channel");
        ModelCommand::AddArguments();
    }

    ~ReadChannelCurrentChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentChannelWithCompletionHandler:^(
            CHIPChannelClusterChannelInfo * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.CurrentChannel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel CurrentChannel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadChannelServerGeneratedCommandList : public ModelCommand {
public:
    ReadChannelServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Channel.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Channel ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeChannelServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeChannelServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Channel.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadChannelClientGeneratedCommandList : public ModelCommand {
public:
    ReadChannelClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Channel.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Channel ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeChannelClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeChannelClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Channel.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadChannelAttributeList : public ModelCommand {
public:
    ReadChannelAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelAttributeList : public ModelCommand {
public:
    SubscribeAttributeChannelAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Channel.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadChannelClusterRevision : public ModelCommand {
public:
    ReadChannelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadChannelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeChannelClusterRevision : public ModelCommand {
public:
    SubscribeAttributeChannelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeChannelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Channel.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ColorControl                                                | 0x0300 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MoveToHue                                                         |   0x00 |
| * MoveHue                                                           |   0x01 |
| * StepHue                                                           |   0x02 |
| * MoveToSaturation                                                  |   0x03 |
| * MoveSaturation                                                    |   0x04 |
| * StepSaturation                                                    |   0x05 |
| * MoveToHueAndSaturation                                            |   0x06 |
| * MoveToColor                                                       |   0x07 |
| * MoveColor                                                         |   0x08 |
| * StepColor                                                         |   0x09 |
| * MoveToColorTemperature                                            |   0x0A |
| * EnhancedMoveToHue                                                 |   0x40 |
| * EnhancedMoveHue                                                   |   0x41 |
| * EnhancedStepHue                                                   |   0x42 |
| * EnhancedMoveToHueAndSaturation                                    |   0x43 |
| * ColorLoopSet                                                      |   0x44 |
| * StopMoveStep                                                      |   0x47 |
| * MoveColorTemperature                                              |   0x4B |
| * StepColorTemperature                                              |   0x4C |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentHue                                                        | 0x0000 |
| * CurrentSaturation                                                 | 0x0001 |
| * RemainingTime                                                     | 0x0002 |
| * CurrentX                                                          | 0x0003 |
| * CurrentY                                                          | 0x0004 |
| * DriftCompensation                                                 | 0x0005 |
| * CompensationText                                                  | 0x0006 |
| * ColorTemperature                                                  | 0x0007 |
| * ColorMode                                                         | 0x0008 |
| * ColorControlOptions                                               | 0x000F |
| * NumberOfPrimaries                                                 | 0x0010 |
| * Primary1X                                                         | 0x0011 |
| * Primary1Y                                                         | 0x0012 |
| * Primary1Intensity                                                 | 0x0013 |
| * Primary2X                                                         | 0x0015 |
| * Primary2Y                                                         | 0x0016 |
| * Primary2Intensity                                                 | 0x0017 |
| * Primary3X                                                         | 0x0019 |
| * Primary3Y                                                         | 0x001A |
| * Primary3Intensity                                                 | 0x001B |
| * Primary4X                                                         | 0x0020 |
| * Primary4Y                                                         | 0x0021 |
| * Primary4Intensity                                                 | 0x0022 |
| * Primary5X                                                         | 0x0024 |
| * Primary5Y                                                         | 0x0025 |
| * Primary5Intensity                                                 | 0x0026 |
| * Primary6X                                                         | 0x0028 |
| * Primary6Y                                                         | 0x0029 |
| * Primary6Intensity                                                 | 0x002A |
| * WhitePointX                                                       | 0x0030 |
| * WhitePointY                                                       | 0x0031 |
| * ColorPointRX                                                      | 0x0032 |
| * ColorPointRY                                                      | 0x0033 |
| * ColorPointRIntensity                                              | 0x0034 |
| * ColorPointGX                                                      | 0x0036 |
| * ColorPointGY                                                      | 0x0037 |
| * ColorPointGIntensity                                              | 0x0038 |
| * ColorPointBX                                                      | 0x003A |
| * ColorPointBY                                                      | 0x003B |
| * ColorPointBIntensity                                              | 0x003C |
| * EnhancedCurrentHue                                                | 0x4000 |
| * EnhancedColorMode                                                 | 0x4001 |
| * ColorLoopActive                                                   | 0x4002 |
| * ColorLoopDirection                                                | 0x4003 |
| * ColorLoopTime                                                     | 0x4004 |
| * ColorLoopStartEnhancedHue                                         | 0x4005 |
| * ColorLoopStoredEnhancedHue                                        | 0x4006 |
| * ColorCapabilities                                                 | 0x400A |
| * ColorTempPhysicalMin                                              | 0x400B |
| * ColorTempPhysicalMax                                              | 0x400C |
| * CoupleColorTempToLevelMinMireds                                   | 0x400D |
| * StartUpColorTemperatureMireds                                     | 0x4010 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ColorLoopSet
 */
class ColorControlColorLoopSet : public ModelCommand {
public:
    ColorControlColorLoopSet()
        : ModelCommand("color-loop-set")
    {
        AddArgument("UpdateFlags", 0, UINT8_MAX, &mUpdateFlags);
        AddArgument("Action", 0, UINT8_MAX, &mAction);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("Time", 0, UINT16_MAX, &mTime);
        AddArgument("StartHue", 0, UINT16_MAX, &mStartHue);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000044) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:mUpdateFlags];
        params.action = [NSNumber numberWithUnsignedChar:mAction];
        params.direction = [NSNumber numberWithUnsignedChar:mDirection];
        params.time = [NSNumber numberWithUnsignedShort:mTime];
        params.startHue = [NSNumber numberWithUnsignedShort:mStartHue];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    uint8_t mUpdateFlags;
    uint8_t mAction;
    uint8_t mDirection;
    uint16_t mTime;
    uint16_t mStartHue;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveHue
 */
class ColorControlEnhancedMoveHue : public ModelCommand {
public:
    ColorControlEnhancedMoveHue()
        : ModelCommand("enhanced-move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT16_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000041) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedShort:mRate];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveHueWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             err = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];
        return err;
    }

private:
    uint8_t mMoveMode;
    uint16_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveToHue
 */
class ColorControlEnhancedMoveToHue : public ModelCommand {
public:
    ColorControlEnhancedMoveToHue()
        : ModelCommand("enhanced-move-to-hue")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mEnhancedHue);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000040) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:mEnhancedHue];
        params.direction = [NSNumber numberWithUnsignedChar:mDirection];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               err = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return err;
    }

private:
    uint16_t mEnhancedHue;
    uint8_t mDirection;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveToHueAndSaturation
 */
class ColorControlEnhancedMoveToHueAndSaturation : public ModelCommand {
public:
    ColorControlEnhancedMoveToHueAndSaturation()
        : ModelCommand("enhanced-move-to-hue-and-saturation")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mEnhancedHue);
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000043) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueAndSaturationParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:mEnhancedHue];
        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveToHueAndSaturationWithParams:params
                                        completionHandler:^(NSError * _Nullable error) {
                                            err = [CHIPError errorToCHIPErrorCode:error];
                                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                            SetCommandExitStatus(err);
                                        }];
        return err;
    }

private:
    uint16_t mEnhancedHue;
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedStepHue
 */
class ColorControlEnhancedStepHue : public ModelCommand {
public:
    ColorControlEnhancedStepHue()
        : ModelCommand("enhanced-step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT16_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000042) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterEnhancedStepHueParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedShort:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedStepHueWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             err = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];
        return err;
    }

private:
    uint8_t mStepMode;
    uint16_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveColor
 */
class ColorControlMoveColor : public ModelCommand {
public:
    ColorControlMoveColor()
        : ModelCommand("move-color")
    {
        AddArgument("RateX", INT16_MIN, INT16_MAX, &mRateX);
        AddArgument("RateY", INT16_MIN, INT16_MAX, &mRateY);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveColorParams alloc] init];
        params.rateX = [NSNumber numberWithShort:mRateX];
        params.rateY = [NSNumber numberWithShort:mRateY];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveColorWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       err = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];
        return err;
    }

private:
    int16_t mRateX;
    int16_t mRateY;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveColorTemperature
 */
class ColorControlMoveColorTemperature : public ModelCommand {
public:
    ColorControlMoveColorTemperature()
        : ModelCommand("move-color-temperature")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT16_MAX, &mRate);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mColorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mColorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedShort:mRate];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:mColorTemperatureMinimum];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:mColorTemperatureMaximum];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint8_t mMoveMode;
    uint16_t mRate;
    uint16_t mColorTemperatureMinimum;
    uint16_t mColorTemperatureMaximum;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveHue
 */
class ColorControlMoveHue : public ModelCommand {
public:
    ColorControlMoveHue()
        : ModelCommand("move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveHueWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     err = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];
        return err;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveSaturation
 */
class ColorControlMoveSaturation : public ModelCommand {
public:
    ColorControlMoveSaturation()
        : ModelCommand("move-saturation")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            err = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];
        return err;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColor
 */
class ColorControlMoveToColor : public ModelCommand {
public:
    ColorControlMoveToColor()
        : ModelCommand("move-to-color")
    {
        AddArgument("ColorX", 0, UINT16_MAX, &mColorX);
        AddArgument("ColorY", 0, UINT16_MAX, &mColorY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToColorParams alloc] init];
        params.colorX = [NSNumber numberWithUnsignedShort:mColorX];
        params.colorY = [NSNumber numberWithUnsignedShort:mColorY];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToColorWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint16_t mColorX;
    uint16_t mColorY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColorTemperature
 */
class ColorControlMoveToColorTemperature : public ModelCommand {
public:
    ColorControlMoveToColorTemperature()
        : ModelCommand("move-to-color-temperature")
    {
        AddArgument("ColorTemperature", 0, UINT16_MAX, &mColorTemperature);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToColorTemperatureParams alloc] init];
        params.colorTemperature = [NSNumber numberWithUnsignedShort:mColorTemperature];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToColorTemperatureWithParams:params
                                completionHandler:^(NSError * _Nullable error) {
                                    err = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }

private:
    uint16_t mColorTemperature;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHue
 */
class ColorControlMoveToHue : public ModelCommand {
public:
    ColorControlMoveToHue()
        : ModelCommand("move-to-hue")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mHue);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToHueParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:mHue];
        params.direction = [NSNumber numberWithUnsignedChar:mDirection];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToHueWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       err = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];
        return err;
    }

private:
    uint8_t mHue;
    uint8_t mDirection;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHueAndSaturation
 */
class ColorControlMoveToHueAndSaturation : public ModelCommand {
public:
    ColorControlMoveToHueAndSaturation()
        : ModelCommand("move-to-hue-and-saturation")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mHue);
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToHueAndSaturationParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:mHue];
        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToHueAndSaturationWithParams:params
                                completionHandler:^(NSError * _Nullable error) {
                                    err = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }

private:
    uint8_t mHue;
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToSaturation
 */
class ColorControlMoveToSaturation : public ModelCommand {
public:
    ColorControlMoveToSaturation()
        : ModelCommand("move-to-saturation")
    {
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterMoveToSaturationParams alloc] init];
        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToSaturationWithParams:params
                          completionHandler:^(NSError * _Nullable error) {
                              err = [CHIPError errorToCHIPErrorCode:error];
                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];
        return err;
    }

private:
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColor
 */
class ColorControlStepColor : public ModelCommand {
public:
    ColorControlStepColor()
        : ModelCommand("step-color")
    {
        AddArgument("StepX", INT16_MIN, INT16_MAX, &mStepX);
        AddArgument("StepY", INT16_MIN, INT16_MAX, &mStepY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStepColorParams alloc] init];
        params.stepX = [NSNumber numberWithShort:mStepX];
        params.stepY = [NSNumber numberWithShort:mStepY];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepColorWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       err = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];
        return err;
    }

private:
    int16_t mStepX;
    int16_t mStepY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColorTemperature
 */
class ColorControlStepColorTemperature : public ModelCommand {
public:
    ColorControlStepColorTemperature()
        : ModelCommand("step-color-temperature")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT16_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mColorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mColorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStepColorTemperatureParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedShort:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:mColorTemperatureMinimum];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:mColorTemperatureMaximum];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint8_t mStepMode;
    uint16_t mStepSize;
    uint16_t mTransitionTime;
    uint16_t mColorTemperatureMinimum;
    uint16_t mColorTemperatureMaximum;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepHue
 */
class ColorControlStepHue : public ModelCommand {
public:
    ColorControlStepHue()
        : ModelCommand("step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStepHueParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedChar:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepHueWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     err = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];
        return err;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepSaturation
 */
class ColorControlStepSaturation : public ModelCommand {
public:
    ColorControlStepSaturation()
        : ModelCommand("step-saturation")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStepSaturationParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedChar:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            err = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];
        return err;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StopMoveStep
 */
class ColorControlStopMoveStep : public ModelCommand {
public:
    ColorControlStopMoveStep()
        : ModelCommand("stop-move-step")
    {
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000047) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPColorControlClusterStopMoveStepParams alloc] init];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stopMoveStepWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Attribute CurrentHue
 */
class ReadColorControlCurrentHue : public ModelCommand {
public:
    ReadColorControlCurrentHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentHue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentHue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCurrentHue : public ModelCommand {
public:
    SubscribeAttributeColorControlCurrentHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentHueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ColorControl.CurrentHue response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentSaturation
 */
class ReadColorControlCurrentSaturation : public ModelCommand {
public:
    ReadColorControlCurrentSaturation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-saturation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentSaturation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentSaturationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentSaturation response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentSaturation Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCurrentSaturation : public ModelCommand {
public:
    SubscribeAttributeColorControlCurrentSaturation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-saturation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCurrentSaturation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentSaturationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.CurrentSaturation response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadColorControlRemainingTime : public ModelCommand {
public:
    ReadColorControlRemainingTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.RemainingTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl RemainingTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlRemainingTime : public ModelCommand {
public:
    SubscribeAttributeColorControlRemainingTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRemainingTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.RemainingTime response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentX
 */
class ReadColorControlCurrentX : public ModelCommand {
public:
    ReadColorControlCurrentX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCurrentX : public ModelCommand {
public:
    SubscribeAttributeColorControlCurrentX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCurrentX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ColorControl.CurrentX response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentY
 */
class ReadColorControlCurrentY : public ModelCommand {
public:
    ReadColorControlCurrentY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCurrentY : public ModelCommand {
public:
    SubscribeAttributeColorControlCurrentY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCurrentY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ColorControl.CurrentY response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DriftCompensation
 */
class ReadColorControlDriftCompensation : public ModelCommand {
public:
    ReadColorControlDriftCompensation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "drift-compensation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlDriftCompensation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDriftCompensationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.DriftCompensation response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl DriftCompensation Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlDriftCompensation : public ModelCommand {
public:
    SubscribeAttributeColorControlDriftCompensation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "drift-compensation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlDriftCompensation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDriftCompensationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.DriftCompensation response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CompensationText
 */
class ReadColorControlCompensationText : public ModelCommand {
public:
    ReadColorControlCompensationText()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "compensation-text");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCompensationText() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCompensationTextWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CompensationText response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CompensationText Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCompensationText : public ModelCommand {
public:
    SubscribeAttributeColorControlCompensationText()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "compensation-text");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCompensationText() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCompensationTextWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ColorControl.CompensationText response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTemperature
 */
class ReadColorControlColorTemperature : public ModelCommand {
public:
    ReadColorControlColorTemperature()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTemperature response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTemperature Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorTemperature : public ModelCommand {
public:
    SubscribeAttributeColorControlColorTemperature()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorTemperatureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ColorControl.ColorTemperature response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorMode
 */
class ReadColorControlColorMode : public ModelCommand {
public:
    ReadColorControlColorMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorMode : public ModelCommand {
public:
    SubscribeAttributeColorControlColorMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.ColorMode response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorControlOptions
 */
class ReadColorControlColorControlOptions : public ModelCommand {
public:
    ReadColorControlColorControlOptions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-control-options");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorControlOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorControlOptions response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorControlOptions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorControlOptions : public ModelCommand {
public:
    WriteColorControlColorControlOptions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeColorControlOptionsWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "ColorControl ColorControlOptions Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeColorControlColorControlOptions : public ModelCommand {
public:
    SubscribeAttributeColorControlColorControlOptions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeColorControlOptionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ColorControl.ColorControlOptions response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPrimaries
 */
class ReadColorControlNumberOfPrimaries : public ModelCommand {
public:
    ReadColorControlNumberOfPrimaries()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-primaries");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlNumberOfPrimaries() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfPrimariesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.NumberOfPrimaries response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl NumberOfPrimaries Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlNumberOfPrimaries : public ModelCommand {
public:
    SubscribeAttributeColorControlNumberOfPrimaries()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-primaries");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlNumberOfPrimaries() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNumberOfPrimariesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.NumberOfPrimaries response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1X
 */
class ReadColorControlPrimary1X : public ModelCommand {
public:
    ReadColorControlPrimary1X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary1XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary1X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary1X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary1X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary1XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary1X response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Y
 */
class ReadColorControlPrimary1Y : public ModelCommand {
public:
    ReadColorControlPrimary1Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary1YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary1Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary1Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary1Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary1YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary1Y response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Intensity
 */
class ReadColorControlPrimary1Intensity : public ModelCommand {
public:
    ReadColorControlPrimary1Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary1IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary1Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary1Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary1Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary1IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary1Intensity response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2X
 */
class ReadColorControlPrimary2X : public ModelCommand {
public:
    ReadColorControlPrimary2X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary2XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary2X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary2X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary2X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary2XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary2X response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Y
 */
class ReadColorControlPrimary2Y : public ModelCommand {
public:
    ReadColorControlPrimary2Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary2YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary2Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary2Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary2Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary2YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary2Y response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Intensity
 */
class ReadColorControlPrimary2Intensity : public ModelCommand {
public:
    ReadColorControlPrimary2Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary2IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary2Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary2Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary2Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary2IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary2Intensity response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3X
 */
class ReadColorControlPrimary3X : public ModelCommand {
public:
    ReadColorControlPrimary3X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary3XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary3X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary3X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary3X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary3XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary3X response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Y
 */
class ReadColorControlPrimary3Y : public ModelCommand {
public:
    ReadColorControlPrimary3Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary3YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary3Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary3Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary3Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary3YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary3Y response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Intensity
 */
class ReadColorControlPrimary3Intensity : public ModelCommand {
public:
    ReadColorControlPrimary3Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary3IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary3Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary3Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary3Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary3IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary3Intensity response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4X
 */
class ReadColorControlPrimary4X : public ModelCommand {
public:
    ReadColorControlPrimary4X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary4XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary4X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary4X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary4X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary4XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary4X response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Y
 */
class ReadColorControlPrimary4Y : public ModelCommand {
public:
    ReadColorControlPrimary4Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary4YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary4Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary4Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary4Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary4YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary4Y response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Intensity
 */
class ReadColorControlPrimary4Intensity : public ModelCommand {
public:
    ReadColorControlPrimary4Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary4IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary4Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary4Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary4Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary4IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary4Intensity response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5X
 */
class ReadColorControlPrimary5X : public ModelCommand {
public:
    ReadColorControlPrimary5X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary5XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary5X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary5X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary5X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000024) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary5XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary5X response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Y
 */
class ReadColorControlPrimary5Y : public ModelCommand {
public:
    ReadColorControlPrimary5Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary5YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary5Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary5Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary5Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000025) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary5YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary5Y response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Intensity
 */
class ReadColorControlPrimary5Intensity : public ModelCommand {
public:
    ReadColorControlPrimary5Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary5IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary5Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary5Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary5Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000026) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary5IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary5Intensity response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6X
 */
class ReadColorControlPrimary6X : public ModelCommand {
public:
    ReadColorControlPrimary6X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary6XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6X response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary6X : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary6X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary6X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000028) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary6XWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary6X response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Y
 */
class ReadColorControlPrimary6Y : public ModelCommand {
public:
    ReadColorControlPrimary6Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary6YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6Y response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary6Y : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary6Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary6Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000029) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary6YWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ColorControl.Primary6Y response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Intensity
 */
class ReadColorControlPrimary6Intensity : public ModelCommand {
public:
    ReadColorControlPrimary6Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePrimary6IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6Intensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlPrimary6Intensity : public ModelCommand {
public:
    SubscribeAttributeColorControlPrimary6Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlPrimary6Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePrimary6IntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.Primary6Intensity response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointX
 */
class ReadColorControlWhitePointX : public ModelCommand {
public:
    ReadColorControlWhitePointX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWhitePointXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.WhitePointX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl WhitePointX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlWhitePointX : public ModelCommand {
public:
    WriteColorControlWhitePointX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000030) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeWhitePointXWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "ColorControl WhitePointX Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlWhitePointX : public ModelCommand {
public:
    SubscribeAttributeColorControlWhitePointX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000030) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWhitePointXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ColorControl.WhitePointX response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointY
 */
class ReadColorControlWhitePointY : public ModelCommand {
public:
    ReadColorControlWhitePointY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWhitePointYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.WhitePointY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl WhitePointY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlWhitePointY : public ModelCommand {
public:
    WriteColorControlWhitePointY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000031) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeWhitePointYWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "ColorControl WhitePointY Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlWhitePointY : public ModelCommand {
public:
    SubscribeAttributeColorControlWhitePointY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000031) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWhitePointYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ColorControl.WhitePointY response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRX
 */
class ReadColorControlColorPointRX : public ModelCommand {
public:
    ReadColorControlColorPointRX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointRXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointRX : public ModelCommand {
public:
    WriteColorControlColorPointRX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000032) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointRXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointRX Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointRX : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointRX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000032) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointRXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointRX response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRY
 */
class ReadColorControlColorPointRY : public ModelCommand {
public:
    ReadColorControlColorPointRY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-ry");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000033) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointRYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointRY : public ModelCommand {
public:
    WriteColorControlColorPointRY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000033) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointRYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointRY Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointRY : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointRY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000033) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointRYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointRY response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRIntensity
 */
class ReadColorControlColorPointRIntensity : public ModelCommand {
public:
    ReadColorControlColorPointRIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000034) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointRIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRIntensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointRIntensity : public ModelCommand {
public:
    WriteColorControlColorPointRIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000034) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeColorPointRIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               err = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(
                                                   chipTool, "ColorControl ColorPointRIntensity Error: %s", chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeColorControlColorPointRIntensity : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointRIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000034) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointRIntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorPointRIntensity response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGX
 */
class ReadColorControlColorPointGX : public ModelCommand {
public:
    ReadColorControlColorPointGX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000036) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointGXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointGX : public ModelCommand {
public:
    WriteColorControlColorPointGX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000036) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointGXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointGX Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointGX : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointGX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000036) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointGXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointGX response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGY
 */
class ReadColorControlColorPointGY : public ModelCommand {
public:
    ReadColorControlColorPointGY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gy");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000037) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointGYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointGY : public ModelCommand {
public:
    WriteColorControlColorPointGY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000037) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointGYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointGY Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointGY : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointGY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000037) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointGYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointGY response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGIntensity
 */
class ReadColorControlColorPointGIntensity : public ModelCommand {
public:
    ReadColorControlColorPointGIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000038) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointGIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGIntensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointGIntensity : public ModelCommand {
public:
    WriteColorControlColorPointGIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000038) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeColorPointGIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               err = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(
                                                   chipTool, "ColorControl ColorPointGIntensity Error: %s", chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeColorControlColorPointGIntensity : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointGIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000038) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointGIntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorPointGIntensity response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBX
 */
class ReadColorControlColorPointBX : public ModelCommand {
public:
    ReadColorControlColorPointBX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointBXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBX response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointBX : public ModelCommand {
public:
    WriteColorControlColorPointBX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointBXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointBX Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointBX : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointBX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointBXWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointBX response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBY
 */
class ReadColorControlColorPointBY : public ModelCommand {
public:
    ReadColorControlColorPointBY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-by");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointBYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBY response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointBY : public ModelCommand {
public:
    WriteColorControlColorPointBY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeColorPointBYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "ColorControl ColorPointBY Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlColorPointBY : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointBY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointBYWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ColorControl.ColorPointBY response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBIntensity
 */
class ReadColorControlColorPointBIntensity : public ModelCommand {
public:
    ReadColorControlColorPointBIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorPointBIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBIntensity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlColorPointBIntensity : public ModelCommand {
public:
    WriteColorControlColorPointBIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeColorPointBIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               err = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(
                                                   chipTool, "ColorControl ColorPointBIntensity Error: %s", chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeColorControlColorPointBIntensity : public ModelCommand {
public:
    SubscribeAttributeColorControlColorPointBIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorPointBIntensityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorPointBIntensity response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedCurrentHue
 */
class ReadColorControlEnhancedCurrentHue : public ModelCommand {
public:
    ReadColorControlEnhancedCurrentHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.EnhancedCurrentHue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl EnhancedCurrentHue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlEnhancedCurrentHue : public ModelCommand {
public:
    SubscribeAttributeColorControlEnhancedCurrentHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlEnhancedCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeEnhancedCurrentHueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.EnhancedCurrentHue response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedColorMode
 */
class ReadColorControlEnhancedColorMode : public ModelCommand {
public:
    ReadColorControlEnhancedColorMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnhancedColorModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.EnhancedColorMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl EnhancedColorMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlEnhancedColorMode : public ModelCommand {
public:
    SubscribeAttributeColorControlEnhancedColorMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlEnhancedColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnhancedColorModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.EnhancedColorMode response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopActive
 */
class ReadColorControlColorLoopActive : public ModelCommand {
public:
    ReadColorControlColorLoopActive()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-active");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopActive() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopActive response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopActive Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopActive : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopActive()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-active");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopActive() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorLoopActiveWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ColorControl.ColorLoopActive response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopDirection
 */
class ReadColorControlColorLoopDirection : public ModelCommand {
public:
    ReadColorControlColorLoopDirection()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-direction");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopDirection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopDirection response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopDirection Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopDirection : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopDirection()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-direction");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopDirection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeColorLoopDirectionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.ColorLoopDirection response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopTime
 */
class ReadColorControlColorLoopTime : public ModelCommand {
public:
    ReadColorControlColorLoopTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopTime : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorLoopTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.ColorLoopTime response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStartEnhancedHue
 */
class ReadColorControlColorLoopStartEnhancedHue : public ModelCommand {
public:
    ReadColorControlColorLoopStartEnhancedHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStartEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ColorLoopStartEnhancedHue response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ColorLoopStartEnhancedHue Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopStartEnhancedHue : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopStartEnhancedHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopStartEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeColorLoopStartEnhancedHueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorLoopStartEnhancedHue response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStoredEnhancedHue
 */
class ReadColorControlColorLoopStoredEnhancedHue : public ModelCommand {
public:
    ReadColorControlColorLoopStoredEnhancedHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStoredEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ColorLoopStoredEnhancedHue response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ColorLoopStoredEnhancedHue Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeColorControlColorLoopStoredEnhancedHue : public ModelCommand {
public:
    SubscribeAttributeColorControlColorLoopStoredEnhancedHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorLoopStoredEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeColorLoopStoredEnhancedHueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ColorControl.ColorLoopStoredEnhancedHue response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorCapabilities
 */
class ReadColorControlColorCapabilities : public ModelCommand {
public:
    ReadColorControlColorCapabilities()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorCapabilitiesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorCapabilities response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorCapabilities Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorCapabilities : public ModelCommand {
public:
    SubscribeAttributeColorControlColorCapabilities()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorCapabilitiesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ColorControl.ColorCapabilities response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMin
 */
class ReadColorControlColorTempPhysicalMin : public ModelCommand {
public:
    ReadColorControlColorTempPhysicalMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorTempPhysicalMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTempPhysicalMin response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTempPhysicalMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorTempPhysicalMin : public ModelCommand {
public:
    SubscribeAttributeColorControlColorTempPhysicalMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorTempPhysicalMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorTempPhysicalMinWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorTempPhysicalMin response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMax
 */
class ReadColorControlColorTempPhysicalMax : public ModelCommand {
public:
    ReadColorControlColorTempPhysicalMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeColorTempPhysicalMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTempPhysicalMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTempPhysicalMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlColorTempPhysicalMax : public ModelCommand {
public:
    SubscribeAttributeColorControlColorTempPhysicalMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlColorTempPhysicalMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeColorTempPhysicalMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ColorControl.ColorTempPhysicalMax response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CoupleColorTempToLevelMinMireds
 */
class ReadColorControlCoupleColorTempToLevelMinMireds : public ModelCommand {
public:
    ReadColorControlCoupleColorTempToLevelMinMireds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCoupleColorTempToLevelMinMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCoupleColorTempToLevelMinMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CoupleColorTempToLevelMinMireds response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CoupleColorTempToLevelMinMireds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlCoupleColorTempToLevelMinMireds : public ModelCommand {
public:
    SubscribeAttributeColorControlCoupleColorTempToLevelMinMireds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlCoupleColorTempToLevelMinMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCoupleColorTempToLevelMinMiredsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                      params:params
                                                     subscriptionEstablished:NULL
                                                               reportHandler:^(
                                                                   NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                   NSLog(
                                                                       @"ColorControl.CoupleColorTempToLevelMinMireds response %@",
                                                                       [value description]);
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpColorTemperatureMireds
 */
class ReadColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    ReadColorControlStartUpColorTemperatureMireds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartUpColorTemperatureMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.StartUpColorTemperatureMireds response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl StartUpColorTemperatureMireds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    WriteColorControlStartUpColorTemperatureMireds()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00004010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster
            writeAttributeStartUpColorTemperatureMiredsWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   err = [CHIPError errorToCHIPErrorCode:error];
                                                   ChipLogError(chipTool, "ColorControl StartUpColorTemperatureMireds Error: %s",
                                                       chip::ErrorStr(err));
                                                   SetCommandExitStatus(err);
                                               }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    SubscribeAttributeColorControlStartUpColorTemperatureMireds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeStartUpColorTemperatureMiredsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:NULL
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"ColorControl.StartUpColorTemperatureMireds response %@",
                                                                     [value description]);
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadColorControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadColorControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeColorControlServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeColorControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ColorControl.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadColorControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadColorControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeColorControlClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeColorControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ColorControl.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadColorControlAttributeList : public ModelCommand {
public:
    ReadColorControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeColorControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ColorControl.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadColorControlClusterRevision : public ModelCommand {
public:
    ReadColorControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeColorControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeColorControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeColorControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ColorControl.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ContentLauncher                                             | 0x050A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LaunchContent                                                     |   0x00 |
| * LaunchURL                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AcceptHeader                                                      | 0x0000 |
| * SupportedStreamingProtocols                                       | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command LaunchContent
 */
class ContentLauncherLaunchContent : public ModelCommand {
public:
    ContentLauncherLaunchContent()
        : ModelCommand("launch-content")
    {
        AddArgument("AutoPlay", 0, 1, &mAutoPlay);
        AddArgument("Data", &mData);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPContentLauncherClusterLaunchContentParams alloc] init];
        // search Struct parsing is not supported yet
        params.autoPlay = [NSNumber numberWithBool:mAutoPlay];
        params.data = [[NSString alloc] initWithBytes:mData.data() length:mData.size() encoding:NSUTF8StringEncoding];
        [cluster launchContentWithParams:params
                       completionHandler:^(
                           CHIPContentLauncherClusterLaunchResponseParams * _Nullable values, NSError * _Nullable error) {
                           NSLog(@"Values: %@", values);
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    bool mAutoPlay;
    chip::ByteSpan mData;
};

/*
 * Command LaunchURL
 */
class ContentLauncherLaunchURL : public ModelCommand {
public:
    ContentLauncherLaunchURL()
        : ModelCommand("launch-url")
    {
        AddArgument("ContentURL", &mContentURL);
        AddArgument("DisplayString", &mDisplayString);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPContentLauncherClusterLaunchURLParams alloc] init];
        params.contentURL = [[NSString alloc] initWithBytes:mContentURL.data()
                                                     length:mContentURL.size()
                                                   encoding:NSUTF8StringEncoding];
        params.displayString = [[NSString alloc] initWithBytes:mDisplayString.data()
                                                        length:mDisplayString.size()
                                                      encoding:NSUTF8StringEncoding];
        // brandingInformation Struct parsing is not supported yet
        [cluster
            launchURLWithParams:params
              completionHandler:^(CHIPContentLauncherClusterLaunchResponseParams * _Nullable values, NSError * _Nullable error) {
                  NSLog(@"Values: %@", values);
                  err = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];
        return err;
    }

private:
    chip::ByteSpan mContentURL;
    chip::ByteSpan mDisplayString;
};

/*
 * Attribute AcceptHeader
 */
class ReadContentLauncherAcceptHeader : public ModelCommand {
public:
    ReadContentLauncherAcceptHeader()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accept-header");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAcceptHeader() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAcceptHeaderWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.AcceptHeader response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher AcceptHeader Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeContentLauncherAcceptHeader : public ModelCommand {
public:
    SubscribeAttributeContentLauncherAcceptHeader()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accept-header");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherAcceptHeader() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAcceptHeaderWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"ContentLauncher.AcceptHeader response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedStreamingProtocols
 */
class ReadContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    ReadContentLauncherSupportedStreamingProtocols()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeSupportedStreamingProtocolsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ContentLauncher.SupportedStreamingProtocols response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ContentLauncher SupportedStreamingProtocols Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    WriteContentLauncherSupportedStreamingProtocols()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster
            writeAttributeSupportedStreamingProtocolsWithValue:value
                                             completionHandler:^(NSError * _Nullable error) {
                                                 err = [CHIPError errorToCHIPErrorCode:error];
                                                 ChipLogError(chipTool, "ContentLauncher SupportedStreamingProtocols Error: %s",
                                                     chip::ErrorStr(err));
                                                 SetCommandExitStatus(err);
                                             }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    SubscribeAttributeContentLauncherSupportedStreamingProtocols()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSupportedStreamingProtocolsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ContentLauncher.SupportedStreamingProtocols response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadContentLauncherServerGeneratedCommandList : public ModelCommand {
public:
    ReadContentLauncherServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ContentLauncher.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ContentLauncher ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeContentLauncherServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeContentLauncherServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ContentLauncher.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadContentLauncherClientGeneratedCommandList : public ModelCommand {
public:
    ReadContentLauncherClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ContentLauncher.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ContentLauncher ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeContentLauncherClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeContentLauncherClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ContentLauncher.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadContentLauncherAttributeList : public ModelCommand {
public:
    ReadContentLauncherAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeContentLauncherAttributeList : public ModelCommand {
public:
    SubscribeAttributeContentLauncherAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ContentLauncher.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadContentLauncherClusterRevision : public ModelCommand {
public:
    ReadContentLauncherClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeContentLauncherClusterRevision : public ModelCommand {
public:
    SubscribeAttributeContentLauncherClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeContentLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ContentLauncher.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Descriptor                                                  | 0x001D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DeviceList                                                        | 0x0000 |
| * ServerList                                                        | 0x0001 |
| * ClientList                                                        | 0x0002 |
| * PartsList                                                         | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute DeviceList
 */
class ReadDescriptorDeviceList : public ModelCommand {
public:
    ReadDescriptorDeviceList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "device-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorDeviceList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDeviceListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.DeviceList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor DeviceList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorDeviceList : public ModelCommand {
public:
    SubscribeAttributeDescriptorDeviceList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "device-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorDeviceList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDeviceListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Descriptor.DeviceList response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerList
 */
class ReadDescriptorServerList : public ModelCommand {
public:
    ReadDescriptorServerList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorServerList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeServerListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ServerList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ServerList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorServerList : public ModelCommand {
public:
    SubscribeAttributeDescriptorServerList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorServerList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeServerListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Descriptor.ServerList response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientList
 */
class ReadDescriptorClientList : public ModelCommand {
public:
    ReadDescriptorClientList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClientList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClientListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ClientList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ClientList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorClientList : public ModelCommand {
public:
    SubscribeAttributeDescriptorClientList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorClientList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClientListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Descriptor.ClientList response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartsList
 */
class ReadDescriptorPartsList : public ModelCommand {
public:
    ReadDescriptorPartsList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "parts-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorPartsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartsListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.PartsList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor PartsList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorPartsList : public ModelCommand {
public:
    SubscribeAttributeDescriptorPartsList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "parts-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorPartsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartsListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"Descriptor.PartsList response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadDescriptorServerGeneratedCommandList : public ModelCommand {
public:
    ReadDescriptorServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Descriptor.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Descriptor ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDescriptorServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDescriptorServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Descriptor.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadDescriptorClientGeneratedCommandList : public ModelCommand {
public:
    ReadDescriptorClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Descriptor.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Descriptor ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDescriptorClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDescriptorClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Descriptor.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDescriptorAttributeList : public ModelCommand {
public:
    ReadDescriptorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorAttributeList : public ModelCommand {
public:
    SubscribeAttributeDescriptorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Descriptor.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadDescriptorClusterRevision : public ModelCommand {
public:
    ReadDescriptorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDescriptorClusterRevision : public ModelCommand {
public:
    SubscribeAttributeDescriptorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDescriptorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Descriptor.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster DiagnosticLogs                                              | 0x0032 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * RetrieveLogsRequest                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RetrieveLogsRequest
 */
class DiagnosticLogsRetrieveLogsRequest : public ModelCommand {
public:
    DiagnosticLogsRetrieveLogsRequest()
        : ModelCommand("retrieve-logs-request")
    {
        AddArgument("Intent", 0, UINT8_MAX, &mIntent);
        AddArgument("RequestedProtocol", 0, UINT8_MAX, &mRequestedProtocol);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDiagnosticLogsClusterRetrieveLogsRequestParams alloc] init];
        params.intent = [NSNumber numberWithUnsignedChar:mIntent];
        params.requestedProtocol = [NSNumber numberWithUnsignedChar:mRequestedProtocol];
        params.transferFileDesignator = [[NSData alloc] initWithBytes:mTransferFileDesignator.data()
                                                               length:mTransferFileDesignator.size()];
        [cluster retrieveLogsRequestWithParams:params
                             completionHandler:^(CHIPDiagnosticLogsClusterRetrieveLogsResponseParams * _Nullable values,
                                 NSError * _Nullable error) {
                                 NSLog(@"Values: %@", values);
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint8_t mIntent;
    uint8_t mRequestedProtocol;
    chip::ByteSpan mTransferFileDesignator;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadDiagnosticLogsServerGeneratedCommandList : public ModelCommand {
public:
    ReadDiagnosticLogsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DiagnosticLogs.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DiagnosticLogs ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDiagnosticLogsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDiagnosticLogsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDiagnosticLogsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"DiagnosticLogs.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadDiagnosticLogsClientGeneratedCommandList : public ModelCommand {
public:
    ReadDiagnosticLogsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DiagnosticLogs.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DiagnosticLogs ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDiagnosticLogsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDiagnosticLogsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDiagnosticLogsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"DiagnosticLogs.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDiagnosticLogsAttributeList : public ModelCommand {
public:
    ReadDiagnosticLogsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DiagnosticLogs.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DiagnosticLogs AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDiagnosticLogsAttributeList : public ModelCommand {
public:
    SubscribeAttributeDiagnosticLogsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDiagnosticLogsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"DiagnosticLogs.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster DoorLock                                                    | 0x0101 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LockDoor                                                          |   0x00 |
| * UnlockDoor                                                        |   0x01 |
| * UnlockWithTimeout                                                 |   0x03 |
| * GetLogRecord                                                      |   0x04 |
| * SetPINCode                                                        |   0x05 |
| * GetPINCode                                                        |   0x06 |
| * ClearPINCode                                                      |   0x07 |
| * ClearAllPINCodes                                                  |   0x08 |
| * SetUserStatus                                                     |   0x09 |
| * GetUserStatus                                                     |   0x0A |
| * SetWeekDaySchedule                                                |   0x0B |
| * GetWeekDaySchedule                                                |   0x0C |
| * ClearWeekDaySchedule                                              |   0x0D |
| * SetYearDaySchedule                                                |   0x0E |
| * GetYearDaySchedule                                                |   0x0F |
| * ClearYearDaySchedule                                              |   0x10 |
| * SetHolidaySchedule                                                |   0x11 |
| * GetHolidaySchedule                                                |   0x12 |
| * ClearHolidaySchedule                                              |   0x13 |
| * SetUserType                                                       |   0x14 |
| * GetUserType                                                       |   0x15 |
| * SetRFIDCode                                                       |   0x16 |
| * GetRFIDCode                                                       |   0x17 |
| * ClearRFIDCode                                                     |   0x18 |
| * ClearAllRFIDCodes                                                 |   0x19 |
| * SetUser                                                           |   0x1A |
| * GetUser                                                           |   0x1B |
| * ClearUser                                                         |   0x1D |
| * SetCredential                                                     |   0x22 |
| * GetCredentialStatus                                               |   0x24 |
| * ClearCredential                                                   |   0x26 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LockState                                                         | 0x0000 |
| * LockType                                                          | 0x0001 |
| * ActuatorEnabled                                                   | 0x0002 |
| * DoorState                                                         | 0x0003 |
| * DoorOpenEvents                                                    | 0x0004 |
| * DoorClosedEvents                                                  | 0x0005 |
| * OpenPeriod                                                        | 0x0006 |
| * NumberOfLogRecordsSupported                                       | 0x0010 |
| * NumberOfTotalUsersSupported                                       | 0x0011 |
| * NumberOfPINUsersSupported                                         | 0x0012 |
| * NumberOfRFIDUsersSupported                                        | 0x0013 |
| * NumberOfWeekDaySchedulesSupportedPerUser                          | 0x0014 |
| * NumberOfYearDaySchedulesSupportedPerUser                          | 0x0015 |
| * NumberOfHolidaySchedulesSupported                                 | 0x0016 |
| * MaxPINCodeLength                                                  | 0x0017 |
| * MinPINCodeLength                                                  | 0x0018 |
| * MaxRFIDCodeLength                                                 | 0x0019 |
| * MinRFIDCodeLength                                                 | 0x001A |
| * CredentialRulesSupport                                            | 0x001B |
| * EnableLogging                                                     | 0x0020 |
| * Language                                                          | 0x0021 |
| * LEDSettings                                                       | 0x0022 |
| * AutoRelockTime                                                    | 0x0023 |
| * SoundVolume                                                       | 0x0024 |
| * OperatingMode                                                     | 0x0025 |
| * SupportedOperatingModes                                           | 0x0026 |
| * DefaultConfigurationRegister                                      | 0x0027 |
| * EnableLocalProgramming                                            | 0x0028 |
| * EnableOneTouchLocking                                             | 0x0029 |
| * EnableInsideStatusLED                                             | 0x002A |
| * EnablePrivacyModeButton                                           | 0x002B |
| * LocalProgrammingFeatures                                          | 0x002C |
| * WrongCodeEntryLimit                                               | 0x0030 |
| * UserCodeTemporaryDisableTime                                      | 0x0031 |
| * SendPINOverTheAir                                                 | 0x0032 |
| * RequirePINforRemoteOperation                                      | 0x0033 |
| * ExpiringUserTimeout                                               | 0x0035 |
| * AlarmMask                                                         | 0x0040 |
| * KeypadOperationEventMask                                          | 0x0041 |
| * RemoteOperationEventMask                                          | 0x0042 |
| * ManualOperationEventMask                                          | 0x0043 |
| * RFIDOperationEventMask                                            | 0x0044 |
| * KeypadProgrammingEventMask                                        | 0x0045 |
| * RemoteProgrammingEventMask                                        | 0x0046 |
| * RFIDProgrammingEventMask                                          | 0x0047 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * DoorLockAlarm                                                     | 0x0000 |
| * DoorStateChange                                                   | 0x0001 |
| * LockOperation                                                     | 0x0002 |
| * LockOperationError                                                | 0x0003 |
| * LockUserChange                                                    | 0x0004 |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearCredential
 */
class DoorLockClearCredential : public ModelCommand {
public:
    DoorLockClearCredential()
        : ModelCommand("clear-credential")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearCredentialParams alloc] init];
        // credential Struct parsing is not supported yet
        [cluster clearCredentialWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             err = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];
        return err;
    }

private:
};

/*
 * Command ClearUser
 */
class DoorLockClearUser : public ModelCommand {
public:
    DoorLockClearUser()
        : ModelCommand("clear-user")
    {
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearUserParams alloc] init];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearUserWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       err = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];
        return err;
    }

private:
    uint16_t mUserIndex;
};

/*
 * Command ClearWeekDaySchedule
 */
class DoorLockClearWeekDaySchedule : public ModelCommand {
public:
    DoorLockClearWeekDaySchedule()
        : ModelCommand("clear-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearWeekDayScheduleParams alloc] init];
        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearWeekDayScheduleWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command ClearYearDaySchedule
 */
class DoorLockClearYearDaySchedule : public ModelCommand {
public:
    DoorLockClearYearDaySchedule()
        : ModelCommand("clear-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterClearYearDayScheduleParams alloc] init];
        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearYearDayScheduleWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command GetCredentialStatus
 */
class DoorLockGetCredentialStatus : public ModelCommand {
public:
    DoorLockGetCredentialStatus()
        : ModelCommand("get-credential-status")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetCredentialStatusParams alloc] init];
        // credential Struct parsing is not supported yet
        [cluster getCredentialStatusWithParams:params
                             completionHandler:^(CHIPDoorLockClusterGetCredentialStatusResponseParams * _Nullable values,
                                 NSError * _Nullable error) {
                                 NSLog(@"Values: %@", values);
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
};

/*
 * Command GetUser
 */
class DoorLockGetUser : public ModelCommand {
public:
    DoorLockGetUser()
        : ModelCommand("get-user")
    {
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetUserParams alloc] init];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getUserWithParams:params
                 completionHandler:^(CHIPDoorLockClusterGetUserResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     err = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];
        return err;
    }

private:
    uint16_t mUserIndex;
};

/*
 * Command GetWeekDaySchedule
 */
class DoorLockGetWeekDaySchedule : public ModelCommand {
public:
    DoorLockGetWeekDaySchedule()
        : ModelCommand("get-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetWeekDayScheduleParams alloc] init];
        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getWeekDayScheduleWithParams:params
                            completionHandler:^(
                                CHIPDoorLockClusterGetWeekDayScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command GetYearDaySchedule
 */
class DoorLockGetYearDaySchedule : public ModelCommand {
public:
    DoorLockGetYearDaySchedule()
        : ModelCommand("get-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterGetYearDayScheduleParams alloc] init];
        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getYearDayScheduleWithParams:params
                            completionHandler:^(
                                CHIPDoorLockClusterGetYearDayScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command LockDoor
 */
class DoorLockLockDoor : public ModelCommand {
public:
    DoorLockLockDoor()
        : ModelCommand("lock-door")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterLockDoorParams alloc] init];
        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster lockDoorWithParams:params
                  completionHandler:^(NSError * _Nullable error) {
                      err = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];
        return err;
    }

private:
    chip::ByteSpan mPinCode;
};

/*
 * Command SetCredential
 */
class DoorLockSetCredential : public ModelCommand {
public:
    DoorLockSetCredential()
        : ModelCommand("set-credential")
    {
        AddArgument("OperationType", 0, UINT8_MAX, &mOperationType);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("UserStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("UserType", 0, UINT8_MAX, &mUserType);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetCredentialParams alloc] init];
        params.operationType = [NSNumber numberWithUnsignedChar:mOperationType];
        // credential Struct parsing is not supported yet
        params.credentialData = [[NSData alloc] initWithBytes:mCredentialData.data() length:mCredentialData.size()];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        params.userStatus = [NSNumber numberWithUnsignedChar:mUserStatus];
        params.userType = [NSNumber numberWithUnsignedChar:mUserType];
        [cluster setCredentialWithParams:params
                       completionHandler:^(
                           CHIPDoorLockClusterSetCredentialResponseParams * _Nullable values, NSError * _Nullable error) {
                           NSLog(@"Values: %@", values);
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint8_t mOperationType;
    chip::ByteSpan mCredentialData;
    uint16_t mUserIndex;
    uint8_t mUserStatus;
    uint8_t mUserType;
};

/*
 * Command SetUser
 */
class DoorLockSetUser : public ModelCommand {
public:
    DoorLockSetUser()
        : ModelCommand("set-user")
    {
        AddArgument("OperationType", 0, UINT8_MAX, &mOperationType);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("UserName", &mUserName);
        AddArgument("UserUniqueId", 0, UINT32_MAX, &mUserUniqueId);
        AddArgument("UserStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("UserType", 0, UINT8_MAX, &mUserType);
        AddArgument("CredentialRule", 0, UINT8_MAX, &mCredentialRule);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetUserParams alloc] init];
        params.operationType = [NSNumber numberWithUnsignedChar:mOperationType];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        params.userName = [[NSString alloc] initWithBytes:mUserName.data() length:mUserName.size() encoding:NSUTF8StringEncoding];
        params.userUniqueId = [NSNumber numberWithUnsignedInt:mUserUniqueId];
        params.userStatus = [NSNumber numberWithUnsignedChar:mUserStatus];
        params.userType = [NSNumber numberWithUnsignedChar:mUserType];
        params.credentialRule = [NSNumber numberWithUnsignedChar:mCredentialRule];
        [cluster setUserWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     err = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];
        return err;
    }

private:
    uint8_t mOperationType;
    uint16_t mUserIndex;
    chip::ByteSpan mUserName;
    uint32_t mUserUniqueId;
    uint8_t mUserStatus;
    uint8_t mUserType;
    uint8_t mCredentialRule;
};

/*
 * Command SetWeekDaySchedule
 */
class DoorLockSetWeekDaySchedule : public ModelCommand {
public:
    DoorLockSetWeekDaySchedule()
        : ModelCommand("set-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("DaysMask", 0, UINT8_MAX, &mDaysMask);
        AddArgument("StartHour", 0, UINT8_MAX, &mStartHour);
        AddArgument("StartMinute", 0, UINT8_MAX, &mStartMinute);
        AddArgument("EndHour", 0, UINT8_MAX, &mEndHour);
        AddArgument("EndMinute", 0, UINT8_MAX, &mEndMinute);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetWeekDayScheduleParams alloc] init];
        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        params.daysMask = [NSNumber numberWithUnsignedChar:mDaysMask];
        params.startHour = [NSNumber numberWithUnsignedChar:mStartHour];
        params.startMinute = [NSNumber numberWithUnsignedChar:mStartMinute];
        params.endHour = [NSNumber numberWithUnsignedChar:mEndHour];
        params.endMinute = [NSNumber numberWithUnsignedChar:mEndMinute];
        [cluster setWeekDayScheduleWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
    uint8_t mDaysMask;
    uint8_t mStartHour;
    uint8_t mStartMinute;
    uint8_t mEndHour;
    uint8_t mEndMinute;
};

/*
 * Command SetYearDaySchedule
 */
class DoorLockSetYearDaySchedule : public ModelCommand {
public:
    DoorLockSetYearDaySchedule()
        : ModelCommand("set-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("LocalStartTime", 0, UINT32_MAX, &mLocalStartTime);
        AddArgument("LocalEndTime", 0, UINT32_MAX, &mLocalEndTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterSetYearDayScheduleParams alloc] init];
        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        params.localStartTime = [NSNumber numberWithUnsignedInt:mLocalStartTime];
        params.localEndTime = [NSNumber numberWithUnsignedInt:mLocalEndTime];
        [cluster setYearDayScheduleWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
    uint32_t mLocalStartTime;
    uint32_t mLocalEndTime;
};

/*
 * Command UnlockDoor
 */
class DoorLockUnlockDoor : public ModelCommand {
public:
    DoorLockUnlockDoor()
        : ModelCommand("unlock-door")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterUnlockDoorParams alloc] init];
        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster unlockDoorWithParams:params
                    completionHandler:^(NSError * _Nullable error) {
                        err = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];
        return err;
    }

private:
    chip::ByteSpan mPinCode;
};

/*
 * Command UnlockWithTimeout
 */
class DoorLockUnlockWithTimeout : public ModelCommand {
public:
    DoorLockUnlockWithTimeout()
        : ModelCommand("unlock-with-timeout")
    {
        AddArgument("Timeout", 0, UINT16_MAX, &mTimeout);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPDoorLockClusterUnlockWithTimeoutParams alloc] init];
        params.timeout = [NSNumber numberWithUnsignedShort:mTimeout];
        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster unlockWithTimeoutWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               err = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return err;
    }

private:
    uint16_t mTimeout;
    chip::ByteSpan mPinCode;
};

/*
 * Attribute LockState
 */
class ReadDoorLockLockState : public ModelCommand {
public:
    ReadDoorLockLockState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLockStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.LockState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock LockState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockLockState : public ModelCommand {
public:
    SubscribeAttributeDoorLockLockState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lock-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockLockState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLockStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"DoorLock.LockState response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LockType
 */
class ReadDoorLockLockType : public ModelCommand {
public:
    ReadDoorLockLockType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-type");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLockTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.LockType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock LockType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockLockType : public ModelCommand {
public:
    SubscribeAttributeDoorLockLockType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lock-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockLockType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLockTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"DoorLock.LockType response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActuatorEnabled
 */
class ReadDoorLockActuatorEnabled : public ModelCommand {
public:
    ReadDoorLockActuatorEnabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "actuator-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockActuatorEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActuatorEnabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.ActuatorEnabled response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock ActuatorEnabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockActuatorEnabled : public ModelCommand {
public:
    SubscribeAttributeDoorLockActuatorEnabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "actuator-enabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockActuatorEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActuatorEnabledWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"DoorLock.ActuatorEnabled response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DoorState
 */
class ReadDoorLockDoorState : public ModelCommand {
public:
    ReadDoorLockDoorState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "door-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockDoorState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDoorStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.DoorState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock DoorState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockDoorState : public ModelCommand {
public:
    SubscribeAttributeDoorLockDoorState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "door-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockDoorState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDoorStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"DoorLock.DoorState response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfTotalUsersSupported
 */
class ReadDoorLockNumberOfTotalUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfTotalUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-total-users-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfTotalUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfTotalUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfTotalUsersSupported response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfTotalUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfTotalUsersSupported : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfTotalUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-total-users-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfTotalUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfTotalUsersSupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"DoorLock.NumberOfTotalUsersSupported response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPINUsersSupported
 */
class ReadDoorLockNumberOfPINUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfPINUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-pinusers-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfPINUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfPINUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfPINUsersSupported response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfPINUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfPINUsersSupported : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfPINUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-pinusers-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfPINUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfPINUsersSupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"DoorLock.NumberOfPINUsersSupported response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfRFIDUsersSupported
 */
class ReadDoorLockNumberOfRFIDUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfRFIDUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-rfidusers-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfRFIDUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfRFIDUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfRFIDUsersSupported response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfRFIDUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfRFIDUsersSupported : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfRFIDUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-rfidusers-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfRFIDUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfRFIDUsersSupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"DoorLock.NumberOfRFIDUsersSupported response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfWeekDaySchedulesSupportedPerUser
 */
class ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser : public ModelCommand {
public:
    ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-week-day-schedules-supported-per-user");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfWeekDaySchedulesSupportedPerUserWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.NumberOfWeekDaySchedulesSupportedPerUser response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock NumberOfWeekDaySchedulesSupportedPerUser Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfWeekDaySchedulesSupportedPerUser : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfWeekDaySchedulesSupportedPerUser()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-week-day-schedules-supported-per-user");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfWeekDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfWeekDaySchedulesSupportedPerUserWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                               params:params
                                                              subscriptionEstablished:NULL
                                                                        reportHandler:^(
                                                                            NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                            NSLog(@"DoorLock."
                                                                                  @"NumberOfWeekDaySchedulesSupportedPerUser "
                                                                                  @"response %@",
                                                                                [value description]);
                                                                            SetCommandExitStatus(
                                                                                [CHIPError errorToCHIPErrorCode:error]);
                                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfYearDaySchedulesSupportedPerUser
 */
class ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser : public ModelCommand {
public:
    ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-year-day-schedules-supported-per-user");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfYearDaySchedulesSupportedPerUserWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.NumberOfYearDaySchedulesSupportedPerUser response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock NumberOfYearDaySchedulesSupportedPerUser Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockNumberOfYearDaySchedulesSupportedPerUser : public ModelCommand {
public:
    SubscribeAttributeDoorLockNumberOfYearDaySchedulesSupportedPerUser()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-year-day-schedules-supported-per-user");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockNumberOfYearDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfYearDaySchedulesSupportedPerUserWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                               params:params
                                                              subscriptionEstablished:NULL
                                                                        reportHandler:^(
                                                                            NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                            NSLog(@"DoorLock."
                                                                                  @"NumberOfYearDaySchedulesSupportedPerUser "
                                                                                  @"response %@",
                                                                                [value description]);
                                                                            SetCommandExitStatus(
                                                                                [CHIPError errorToCHIPErrorCode:error]);
                                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxPINCodeLength
 */
class ReadDoorLockMaxPINCodeLength : public ModelCommand {
public:
    ReadDoorLockMaxPINCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pincode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMaxPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxPINCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MaxPINCodeLength response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MaxPINCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockMaxPINCodeLength : public ModelCommand {
public:
    SubscribeAttributeDoorLockMaxPINCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-pincode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockMaxPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxPINCodeLengthWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"DoorLock.MaxPINCodeLength response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinPINCodeLength
 */
class ReadDoorLockMinPINCodeLength : public ModelCommand {
public:
    ReadDoorLockMinPINCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-pincode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMinPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinPINCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MinPINCodeLength response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MinPINCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockMinPINCodeLength : public ModelCommand {
public:
    SubscribeAttributeDoorLockMinPINCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-pincode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockMinPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000018) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinPINCodeLengthWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"DoorLock.MinPINCodeLength response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxRFIDCodeLength
 */
class ReadDoorLockMaxRFIDCodeLength : public ModelCommand {
public:
    ReadDoorLockMaxRFIDCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-rfidcode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMaxRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxRFIDCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MaxRFIDCodeLength response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MaxRFIDCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockMaxRFIDCodeLength : public ModelCommand {
public:
    SubscribeAttributeDoorLockMaxRFIDCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-rfidcode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockMaxRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxRFIDCodeLengthWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"DoorLock.MaxRFIDCodeLength response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinRFIDCodeLength
 */
class ReadDoorLockMinRFIDCodeLength : public ModelCommand {
public:
    ReadDoorLockMinRFIDCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-rfidcode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMinRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinRFIDCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MinRFIDCodeLength response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MinRFIDCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockMinRFIDCodeLength : public ModelCommand {
public:
    SubscribeAttributeDoorLockMinRFIDCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-rfidcode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockMinRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinRFIDCodeLengthWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"DoorLock.MinRFIDCodeLength response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Language
 */
class ReadDoorLockLanguage : public ModelCommand {
public:
    ReadDoorLockLanguage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "language");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLanguageWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.Language response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock Language Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockLanguage : public ModelCommand {
public:
    WriteDoorLockLanguage()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "language");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLanguageWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "DoorLock Language Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeDoorLockLanguage : public ModelCommand {
public:
    SubscribeAttributeDoorLockLanguage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "language");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLanguageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"DoorLock.Language response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AutoRelockTime
 */
class ReadDoorLockAutoRelockTime : public ModelCommand {
public:
    ReadDoorLockAutoRelockTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "auto-relock-time");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAutoRelockTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.AutoRelockTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock AutoRelockTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockAutoRelockTime : public ModelCommand {
public:
    WriteDoorLockAutoRelockTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "auto-relock-time");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000023) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeAutoRelockTimeWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "DoorLock AutoRelockTime Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeDoorLockAutoRelockTime : public ModelCommand {
public:
    SubscribeAttributeDoorLockAutoRelockTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "auto-relock-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000023) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAutoRelockTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"DoorLock.AutoRelockTime response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoundVolume
 */
class ReadDoorLockSoundVolume : public ModelCommand {
public:
    ReadDoorLockSoundVolume()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "sound-volume");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSoundVolumeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.SoundVolume response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock SoundVolume Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockSoundVolume : public ModelCommand {
public:
    WriteDoorLockSoundVolume()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "sound-volume");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000024) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeSoundVolumeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "DoorLock SoundVolume Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeDoorLockSoundVolume : public ModelCommand {
public:
    SubscribeAttributeDoorLockSoundVolume()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "sound-volume");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000024) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSoundVolumeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"DoorLock.SoundVolume response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperatingMode
 */
class ReadDoorLockOperatingMode : public ModelCommand {
public:
    ReadDoorLockOperatingMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operating-mode");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOperatingModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.OperatingMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock OperatingMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockOperatingMode : public ModelCommand {
public:
    WriteDoorLockOperatingMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "operating-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000025) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOperatingModeWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        err = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "DoorLock OperatingMode Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeDoorLockOperatingMode : public ModelCommand {
public:
    SubscribeAttributeDoorLockOperatingMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operating-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000025) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOperatingModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"DoorLock.OperatingMode response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedOperatingModes
 */
class ReadDoorLockSupportedOperatingModes : public ModelCommand {
public:
    ReadDoorLockSupportedOperatingModes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-operating-modes");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockSupportedOperatingModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeSupportedOperatingModesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.SupportedOperatingModes response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock SupportedOperatingModes Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockSupportedOperatingModes : public ModelCommand {
public:
    SubscribeAttributeDoorLockSupportedOperatingModes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-operating-modes");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockSupportedOperatingModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000026) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedOperatingModesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"DoorLock.SupportedOperatingModes response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnableOneTouchLocking
 */
class ReadDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    ReadDoorLockEnableOneTouchLocking()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnableOneTouchLockingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.EnableOneTouchLocking response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock EnableOneTouchLocking Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    WriteDoorLockEnableOneTouchLocking()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000029) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster
            writeAttributeEnableOneTouchLockingWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           err = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogError(chipTool, "DoorLock EnableOneTouchLocking Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    SubscribeAttributeDoorLockEnableOneTouchLocking()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000029) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeEnableOneTouchLockingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"DoorLock.EnableOneTouchLocking response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnablePrivacyModeButton
 */
class ReadDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    ReadDoorLockEnablePrivacyModeButton()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeEnablePrivacyModeButtonWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.EnablePrivacyModeButton response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock EnablePrivacyModeButton Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    WriteDoorLockEnablePrivacyModeButton()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeEnablePrivacyModeButtonWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  err = [CHIPError errorToCHIPErrorCode:error];
                                                  ChipLogError(
                                                      chipTool, "DoorLock EnablePrivacyModeButton Error: %s", chip::ErrorStr(err));
                                                  SetCommandExitStatus(err);
                                              }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    SubscribeAttributeDoorLockEnablePrivacyModeButton()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnablePrivacyModeButtonWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"DoorLock.EnablePrivacyModeButton response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WrongCodeEntryLimit
 */
class ReadDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    ReadDoorLockWrongCodeEntryLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWrongCodeEntryLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.WrongCodeEntryLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock WrongCodeEntryLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    WriteDoorLockWrongCodeEntryLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000030) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeWrongCodeEntryLimitWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              err = [CHIPError errorToCHIPErrorCode:error];
                                              ChipLogError(chipTool, "DoorLock WrongCodeEntryLimit Error: %s", chip::ErrorStr(err));
                                              SetCommandExitStatus(err);
                                          }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    SubscribeAttributeDoorLockWrongCodeEntryLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000030) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWrongCodeEntryLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"DoorLock.WrongCodeEntryLimit response %@", [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadDoorLockServerGeneratedCommandList : public ModelCommand {
public:
    ReadDoorLockServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDoorLockServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"DoorLock.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadDoorLockClientGeneratedCommandList : public ModelCommand {
public:
    ReadDoorLockClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeDoorLockClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeDoorLockClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"DoorLock.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDoorLockAttributeList : public ModelCommand {
public:
    ReadDoorLockAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockAttributeList : public ModelCommand {
public:
    SubscribeAttributeDoorLockAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"DoorLock.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadDoorLockClusterRevision : public ModelCommand {
public:
    ReadDoorLockClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeDoorLockClusterRevision : public ModelCommand {
public:
    SubscribeAttributeDoorLockClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeDoorLockClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"DoorLock.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ElectricalMeasurement                                       | 0x0B04 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GetProfileInfoCommand                                             |   0x00 |
| * GetMeasurementProfileCommand                                      |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasurementType                                                   | 0x0000 |
| * DcVoltage                                                         | 0x0100 |
| * DcVoltageMin                                                      | 0x0101 |
| * DcVoltageMax                                                      | 0x0102 |
| * DcCurrent                                                         | 0x0103 |
| * DcCurrentMin                                                      | 0x0104 |
| * DcCurrentMax                                                      | 0x0105 |
| * DcPower                                                           | 0x0106 |
| * DcPowerMin                                                        | 0x0107 |
| * DcPowerMax                                                        | 0x0108 |
| * DcVoltageMultiplier                                               | 0x0200 |
| * DcVoltageDivisor                                                  | 0x0201 |
| * DcCurrentMultiplier                                               | 0x0202 |
| * DcCurrentDivisor                                                  | 0x0203 |
| * DcPowerMultiplier                                                 | 0x0204 |
| * DcPowerDivisor                                                    | 0x0205 |
| * AcFrequency                                                       | 0x0300 |
| * AcFrequencyMin                                                    | 0x0301 |
| * AcFrequencyMax                                                    | 0x0302 |
| * NeutralCurrent                                                    | 0x0303 |
| * TotalActivePower                                                  | 0x0304 |
| * TotalReactivePower                                                | 0x0305 |
| * TotalApparentPower                                                | 0x0306 |
| * Measured1stHarmonicCurrent                                        | 0x0307 |
| * Measured3rdHarmonicCurrent                                        | 0x0308 |
| * Measured5thHarmonicCurrent                                        | 0x0309 |
| * Measured7thHarmonicCurrent                                        | 0x030A |
| * Measured9thHarmonicCurrent                                        | 0x030B |
| * Measured11thHarmonicCurrent                                       | 0x030C |
| * MeasuredPhase1stHarmonicCurrent                                   | 0x030D |
| * MeasuredPhase3rdHarmonicCurrent                                   | 0x030E |
| * MeasuredPhase5thHarmonicCurrent                                   | 0x030F |
| * MeasuredPhase7thHarmonicCurrent                                   | 0x0310 |
| * MeasuredPhase9thHarmonicCurrent                                   | 0x0311 |
| * MeasuredPhase11thHarmonicCurrent                                  | 0x0312 |
| * AcFrequencyMultiplier                                             | 0x0400 |
| * AcFrequencyDivisor                                                | 0x0401 |
| * PowerMultiplier                                                   | 0x0402 |
| * PowerDivisor                                                      | 0x0403 |
| * HarmonicCurrentMultiplier                                         | 0x0404 |
| * PhaseHarmonicCurrentMultiplier                                    | 0x0405 |
| * InstantaneousVoltage                                              | 0x0500 |
| * InstantaneousLineCurrent                                          | 0x0501 |
| * InstantaneousActiveCurrent                                        | 0x0502 |
| * InstantaneousReactiveCurrent                                      | 0x0503 |
| * InstantaneousPower                                                | 0x0504 |
| * RmsVoltage                                                        | 0x0505 |
| * RmsVoltageMin                                                     | 0x0506 |
| * RmsVoltageMax                                                     | 0x0507 |
| * RmsCurrent                                                        | 0x0508 |
| * RmsCurrentMin                                                     | 0x0509 |
| * RmsCurrentMax                                                     | 0x050A |
| * ActivePower                                                       | 0x050B |
| * ActivePowerMin                                                    | 0x050C |
| * ActivePowerMax                                                    | 0x050D |
| * ReactivePower                                                     | 0x050E |
| * ApparentPower                                                     | 0x050F |
| * PowerFactor                                                       | 0x0510 |
| * AverageRmsVoltageMeasurementPeriod                                | 0x0511 |
| * AverageRmsUnderVoltageCounter                                     | 0x0513 |
| * RmsExtremeOverVoltagePeriod                                       | 0x0514 |
| * RmsExtremeUnderVoltagePeriod                                      | 0x0515 |
| * RmsVoltageSagPeriod                                               | 0x0516 |
| * RmsVoltageSwellPeriod                                             | 0x0517 |
| * AcVoltageMultiplier                                               | 0x0600 |
| * AcVoltageDivisor                                                  | 0x0601 |
| * AcCurrentMultiplier                                               | 0x0602 |
| * AcCurrentDivisor                                                  | 0x0603 |
| * AcPowerMultiplier                                                 | 0x0604 |
| * AcPowerDivisor                                                    | 0x0605 |
| * OverloadAlarmsMask                                                | 0x0700 |
| * VoltageOverload                                                   | 0x0701 |
| * CurrentOverload                                                   | 0x0702 |
| * AcOverloadAlarmsMask                                              | 0x0800 |
| * AcVoltageOverload                                                 | 0x0801 |
| * AcCurrentOverload                                                 | 0x0802 |
| * AcActivePowerOverload                                             | 0x0803 |
| * AcReactivePowerOverload                                           | 0x0804 |
| * AverageRmsOverVoltage                                             | 0x0805 |
| * AverageRmsUnderVoltage                                            | 0x0806 |
| * RmsExtremeOverVoltage                                             | 0x0807 |
| * RmsExtremeUnderVoltage                                            | 0x0808 |
| * RmsVoltageSag                                                     | 0x0809 |
| * RmsVoltageSwell                                                   | 0x080A |
| * LineCurrentPhaseB                                                 | 0x0901 |
| * ActiveCurrentPhaseB                                               | 0x0902 |
| * ReactiveCurrentPhaseB                                             | 0x0903 |
| * RmsVoltagePhaseB                                                  | 0x0905 |
| * RmsVoltageMinPhaseB                                               | 0x0906 |
| * RmsVoltageMaxPhaseB                                               | 0x0907 |
| * RmsCurrentPhaseB                                                  | 0x0908 |
| * RmsCurrentMinPhaseB                                               | 0x0909 |
| * RmsCurrentMaxPhaseB                                               | 0x090A |
| * ActivePowerPhaseB                                                 | 0x090B |
| * ActivePowerMinPhaseB                                              | 0x090C |
| * ActivePowerMaxPhaseB                                              | 0x090D |
| * ReactivePowerPhaseB                                               | 0x090E |
| * ApparentPowerPhaseB                                               | 0x090F |
| * PowerFactorPhaseB                                                 | 0x0910 |
| * AverageRmsVoltageMeasurementPeriodPhaseB                          | 0x0911 |
| * AverageRmsOverVoltageCounterPhaseB                                | 0x0912 |
| * AverageRmsUnderVoltageCounterPhaseB                               | 0x0913 |
| * RmsExtremeOverVoltagePeriodPhaseB                                 | 0x0914 |
| * RmsExtremeUnderVoltagePeriodPhaseB                                | 0x0915 |
| * RmsVoltageSagPeriodPhaseB                                         | 0x0916 |
| * RmsVoltageSwellPeriodPhaseB                                       | 0x0917 |
| * LineCurrentPhaseC                                                 | 0x0A01 |
| * ActiveCurrentPhaseC                                               | 0x0A02 |
| * ReactiveCurrentPhaseC                                             | 0x0A03 |
| * RmsVoltagePhaseC                                                  | 0x0A05 |
| * RmsVoltageMinPhaseC                                               | 0x0A06 |
| * RmsVoltageMaxPhaseC                                               | 0x0A07 |
| * RmsCurrentPhaseC                                                  | 0x0A08 |
| * RmsCurrentMinPhaseC                                               | 0x0A09 |
| * RmsCurrentMaxPhaseC                                               | 0x0A0A |
| * ActivePowerPhaseC                                                 | 0x0A0B |
| * ActivePowerMinPhaseC                                              | 0x0A0C |
| * ActivePowerMaxPhaseC                                              | 0x0A0D |
| * ReactivePowerPhaseC                                               | 0x0A0E |
| * ApparentPowerPhaseC                                               | 0x0A0F |
| * PowerFactorPhaseC                                                 | 0x0A10 |
| * AverageRmsVoltageMeasurementPeriodPhaseC                          | 0x0A11 |
| * AverageRmsOverVoltageCounterPhaseC                                | 0x0A12 |
| * AverageRmsUnderVoltageCounterPhaseC                               | 0x0A13 |
| * RmsExtremeOverVoltagePeriodPhaseC                                 | 0x0A14 |
| * RmsExtremeUnderVoltagePeriodPhaseC                                | 0x0A15 |
| * RmsVoltageSagPeriodPhaseC                                         | 0x0A16 |
| * RmsVoltageSwellPeriodPhaseC                                       | 0x0A17 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasurementType
 */
class ReadElectricalMeasurementMeasurementType : public ModelCommand {
public:
    ReadElectricalMeasurementMeasurementType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measurement-type");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementMeasurementType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasurementTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.MeasurementType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement MeasurementType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementMeasurementType : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementMeasurementType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measurement-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementMeasurementType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMeasurementTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ElectricalMeasurement.MeasurementType response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalActivePower
 */
class ReadElectricalMeasurementTotalActivePower : public ModelCommand {
public:
    ReadElectricalMeasurementTotalActivePower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "total-active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementTotalActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000304) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTotalActivePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.TotalActivePower response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement TotalActivePower Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementTotalActivePower : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementTotalActivePower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "total-active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementTotalActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000304) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTotalActivePowerWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ElectricalMeasurement.TotalActivePower response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltage
 */
class ReadElectricalMeasurementRmsVoltage : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000505) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsVoltageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltage response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsVoltage : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsVoltage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000505) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRmsVoltageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ElectricalMeasurement.RmsVoltage response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMin
 */
class ReadElectricalMeasurementRmsVoltageMin : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltageMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000506) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsVoltageMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltageMin response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltageMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsVoltageMin : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsVoltageMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsVoltageMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000506) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRmsVoltageMinWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.RmsVoltageMin response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMax
 */
class ReadElectricalMeasurementRmsVoltageMax : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltageMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000507) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsVoltageMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltageMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltageMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsVoltageMax : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsVoltageMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsVoltageMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000507) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRmsVoltageMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.RmsVoltageMax response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrent
 */
class ReadElectricalMeasurementRmsCurrent : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrent()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000508) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsCurrentWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrent response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrent Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsCurrent : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsCurrent()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000508) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRmsCurrentWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ElectricalMeasurement.RmsCurrent response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMin
 */
class ReadElectricalMeasurementRmsCurrentMin : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrentMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000509) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsCurrentMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrentMin response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrentMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsCurrentMin : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsCurrentMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsCurrentMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000509) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRmsCurrentMinWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.RmsCurrentMin response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMax
 */
class ReadElectricalMeasurementRmsCurrentMax : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrentMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRmsCurrentMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrentMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrentMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementRmsCurrentMax : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementRmsCurrentMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementRmsCurrentMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRmsCurrentMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.RmsCurrentMax response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePower
 */
class ReadElectricalMeasurementActivePower : public ModelCommand {
public:
    ReadElectricalMeasurementActivePower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActivePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePower response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePower Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementActivePower : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementActivePower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActivePowerWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ElectricalMeasurement.ActivePower response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMin
 */
class ReadElectricalMeasurementActivePowerMin : public ModelCommand {
public:
    ReadElectricalMeasurementActivePowerMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActivePowerMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePowerMin response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePowerMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementActivePowerMin : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementActivePowerMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementActivePowerMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActivePowerMinWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ElectricalMeasurement.ActivePowerMin response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMax
 */
class ReadElectricalMeasurementActivePowerMax : public ModelCommand {
public:
    ReadElectricalMeasurementActivePowerMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActivePowerMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePowerMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePowerMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementActivePowerMax : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementActivePowerMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementActivePowerMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActivePowerMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ElectricalMeasurement.ActivePowerMax response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadElectricalMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReadElectricalMeasurementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ElectricalMeasurement.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ElectricalMeasurement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ElectricalMeasurement.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadElectricalMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReadElectricalMeasurementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ElectricalMeasurement.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ElectricalMeasurement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ElectricalMeasurement.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadElectricalMeasurementAttributeList : public ModelCommand {
public:
    ReadElectricalMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ElectricalMeasurement.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadElectricalMeasurementClusterRevision : public ModelCommand {
public:
    ReadElectricalMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeElectricalMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeElectricalMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeElectricalMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ElectricalMeasurement.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster EthernetNetworkDiagnostics                                  | 0x0037 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * PHYRate                                                           | 0x0000 |
| * FullDuplex                                                        | 0x0001 |
| * PacketRxCount                                                     | 0x0002 |
| * PacketTxCount                                                     | 0x0003 |
| * TxErrCount                                                        | 0x0004 |
| * CollisionCount                                                    | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * CarrierDetect                                                     | 0x0007 |
| * TimeSinceReset                                                    | 0x0008 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class EthernetNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    EthernetNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute PHYRate
 */
class ReadEthernetNetworkDiagnosticsPHYRate : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPHYRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "phyrate");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPHYRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePHYRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PHYRate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PHYRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsPHYRate : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsPHYRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "phyrate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsPHYRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePHYRateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"EthernetNetworkDiagnostics.PHYRate response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FullDuplex
 */
class ReadEthernetNetworkDiagnosticsFullDuplex : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsFullDuplex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "full-duplex");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFullDuplex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFullDuplexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.FullDuplex response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics FullDuplex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsFullDuplex : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsFullDuplex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "full-duplex");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsFullDuplex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFullDuplexWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"EthernetNetworkDiagnostics.FullDuplex response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketRxCount
 */
class ReadEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPacketRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PacketRxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PacketRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsPacketRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsPacketRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketRxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"EthernetNetworkDiagnostics.PacketRxCount response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketTxCount
 */
class ReadEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPacketTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PacketTxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PacketTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsPacketTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsPacketTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketTxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"EthernetNetworkDiagnostics.PacketTxCount response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCount
 */
class ReadEthernetNetworkDiagnosticsTxErrCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsTxErrCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTxErrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxErrCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.TxErrCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics TxErrCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsTxErrCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsTxErrCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsTxErrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxErrCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"EthernetNetworkDiagnostics.TxErrCount response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CollisionCount
 */
class ReadEthernetNetworkDiagnosticsCollisionCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsCollisionCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "collision-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCollisionCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCollisionCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.CollisionCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics CollisionCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsCollisionCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsCollisionCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "collision-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsCollisionCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCollisionCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"EthernetNetworkDiagnostics.CollisionCount response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadEthernetNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.OverrunCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOverrunCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"EthernetNetworkDiagnostics.OverrunCount response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CarrierDetect
 */
class ReadEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsCarrierDetect()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "carrier-detect");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCarrierDetect() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCarrierDetectWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.CarrierDetect response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics CarrierDetect Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsCarrierDetect()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "carrier-detect");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsCarrierDetect() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCarrierDetectWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"EthernetNetworkDiagnostics.CarrierDetect response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TimeSinceReset
 */
class ReadEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsTimeSinceReset()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "time-since-reset");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTimeSinceReset() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTimeSinceResetWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.TimeSinceReset response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics TimeSinceReset Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsTimeSinceReset()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "time-since-reset");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsTimeSinceReset() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTimeSinceResetWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"EthernetNetworkDiagnostics.TimeSinceReset response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadEthernetNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"EthernetNetworkDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "EthernetNetworkDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"EthernetNetworkDiagnostics.ServerGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadEthernetNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"EthernetNetworkDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "EthernetNetworkDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"EthernetNetworkDiagnostics.ClientGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadEthernetNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"EthernetNetworkDiagnostics.AttributeList response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadEthernetNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"EthernetNetworkDiagnostics.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadEthernetNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeEthernetNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeEthernetNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeEthernetNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"EthernetNetworkDiagnostics.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FixedLabel                                                  | 0x0040 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute LabelList
 */
class ReadFixedLabelLabelList : public ModelCommand {
public:
    ReadFixedLabelLabelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLabelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.LabelList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel LabelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFixedLabelLabelList : public ModelCommand {
public:
    SubscribeAttributeFixedLabelLabelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "label-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLabelListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"FixedLabel.LabelList response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadFixedLabelServerGeneratedCommandList : public ModelCommand {
public:
    ReadFixedLabelServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"FixedLabel.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "FixedLabel ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeFixedLabelServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeFixedLabelServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"FixedLabel.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadFixedLabelClientGeneratedCommandList : public ModelCommand {
public:
    ReadFixedLabelClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"FixedLabel.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "FixedLabel ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeFixedLabelClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeFixedLabelClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"FixedLabel.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFixedLabelAttributeList : public ModelCommand {
public:
    ReadFixedLabelAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFixedLabelAttributeList : public ModelCommand {
public:
    SubscribeAttributeFixedLabelAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"FixedLabel.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadFixedLabelClusterRevision : public ModelCommand {
public:
    ReadFixedLabelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFixedLabelClusterRevision : public ModelCommand {
public:
    SubscribeAttributeFixedLabelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFixedLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"FixedLabel.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FlowMeasurement                                             | 0x0404 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadFlowMeasurementMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"FlowMeasurement.MeasuredValue response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadFlowMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"FlowMeasurement.MinMeasuredValue response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadFlowMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"FlowMeasurement.MaxMeasuredValue response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadFlowMeasurementTolerance : public ModelCommand {
public:
    ReadFlowMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.Tolerance response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementTolerance : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeToleranceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"FlowMeasurement.Tolerance response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadFlowMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReadFlowMeasurementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"FlowMeasurement.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "FlowMeasurement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"FlowMeasurement.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadFlowMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReadFlowMeasurementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"FlowMeasurement.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "FlowMeasurement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"FlowMeasurement.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFlowMeasurementAttributeList : public ModelCommand {
public:
    ReadFlowMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"FlowMeasurement.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadFlowMeasurementClusterRevision : public ModelCommand {
public:
    ReadFlowMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeFlowMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeFlowMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeFlowMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"FlowMeasurement.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralCommissioning                                        | 0x0030 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ArmFailSafe                                                       |   0x00 |
| * SetRegulatoryConfig                                               |   0x02 |
| * CommissioningComplete                                             |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Breadcrumb                                                        | 0x0000 |
| * BasicCommissioningInfo                                            | 0x0001 |
| * RegulatoryConfig                                                  | 0x0002 |
| * LocationCapability                                                | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ArmFailSafe
 */
class GeneralCommissioningArmFailSafe : public ModelCommand {
public:
    GeneralCommissioningArmFailSafe()
        : ModelCommand("arm-fail-safe")
    {
        AddArgument("ExpiryLengthSeconds", 0, UINT16_MAX, &mExpiryLengthSeconds);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mTimeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGeneralCommissioningClusterArmFailSafeParams alloc] init];
        params.expiryLengthSeconds = [NSNumber numberWithUnsignedShort:mExpiryLengthSeconds];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        params.timeoutMs = [NSNumber numberWithUnsignedInt:mTimeoutMs];
        [cluster armFailSafeWithParams:params
                     completionHandler:^(
                         CHIPGeneralCommissioningClusterArmFailSafeResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint16_t mExpiryLengthSeconds;
    uint64_t mBreadcrumb;
    uint32_t mTimeoutMs;
};

/*
 * Command CommissioningComplete
 */
class GeneralCommissioningCommissioningComplete : public ModelCommand {
public:
    GeneralCommissioningCommissioningComplete()
        : ModelCommand("commissioning-complete")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster commissioningCompleteWithCompletionHandler:^(
            CHIPGeneralCommissioningClusterCommissioningCompleteResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command SetRegulatoryConfig
 */
class GeneralCommissioningSetRegulatoryConfig : public ModelCommand {
public:
    GeneralCommissioningSetRegulatoryConfig()
        : ModelCommand("set-regulatory-config")
    {
        AddArgument("Location", 0, UINT8_MAX, &mLocation);
        AddArgument("CountryCode", &mCountryCode);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mTimeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGeneralCommissioningClusterSetRegulatoryConfigParams alloc] init];
        params.location = [NSNumber numberWithUnsignedChar:mLocation];
        params.countryCode = [[NSString alloc] initWithBytes:mCountryCode.data()
                                                      length:mCountryCode.size()
                                                    encoding:NSUTF8StringEncoding];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        params.timeoutMs = [NSNumber numberWithUnsignedInt:mTimeoutMs];
        [cluster
            setRegulatoryConfigWithParams:params
                        completionHandler:^(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            err = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];
        return err;
    }

private:
    uint8_t mLocation;
    chip::ByteSpan mCountryCode;
    uint64_t mBreadcrumb;
    uint32_t mTimeoutMs;
};

/*
 * Attribute Breadcrumb
 */
class ReadGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    ReadGeneralCommissioningBreadcrumb()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "breadcrumb");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBreadcrumbWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.Breadcrumb response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning Breadcrumb Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    WriteGeneralCommissioningBreadcrumb()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeBreadcrumbWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "GeneralCommissioning Breadcrumb Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningBreadcrumb()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBreadcrumbWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GeneralCommissioning.Breadcrumb response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BasicCommissioningInfo
 */
class ReadGeneralCommissioningBasicCommissioningInfo : public ModelCommand {
public:
    ReadGeneralCommissioningBasicCommissioningInfo()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "basic-commissioning-info");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBasicCommissioningInfo() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBasicCommissioningInfoWithCompletionHandler:^(
            CHIPGeneralCommissioningClusterBasicCommissioningInfo * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.BasicCommissioningInfo response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning BasicCommissioningInfo Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

/*
 * Attribute RegulatoryConfig
 */
class ReadGeneralCommissioningRegulatoryConfig : public ModelCommand {
public:
    ReadGeneralCommissioningRegulatoryConfig()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "regulatory-config");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningRegulatoryConfig() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRegulatoryConfigWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.RegulatoryConfig response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning RegulatoryConfig Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningRegulatoryConfig : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningRegulatoryConfig()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "regulatory-config");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningRegulatoryConfig() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRegulatoryConfigWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"GeneralCommissioning.RegulatoryConfig response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocationCapability
 */
class ReadGeneralCommissioningLocationCapability : public ModelCommand {
public:
    ReadGeneralCommissioningLocationCapability()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "location-capability");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningLocationCapability() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLocationCapabilityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.LocationCapability response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning LocationCapability Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningLocationCapability : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningLocationCapability()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "location-capability");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningLocationCapability() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLocationCapabilityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"GeneralCommissioning.LocationCapability response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadGeneralCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralCommissioningServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GeneralCommissioning.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GeneralCommissioning ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GeneralCommissioning.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadGeneralCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralCommissioningClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GeneralCommissioning.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GeneralCommissioning ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GeneralCommissioning.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGeneralCommissioningAttributeList : public ModelCommand {
public:
    ReadGeneralCommissioningAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningAttributeList : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"GeneralCommissioning.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralCommissioningClusterRevision : public ModelCommand {
public:
    ReadGeneralCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralCommissioningClusterRevision : public ModelCommand {
public:
    SubscribeAttributeGeneralCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GeneralCommissioning.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralDiagnostics                                          | 0x0033 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NetworkInterfaces                                                 | 0x0000 |
| * RebootCount                                                       | 0x0001 |
| * UpTime                                                            | 0x0002 |
| * TotalOperationalHours                                             | 0x0003 |
| * BootReasons                                                       | 0x0004 |
| * ActiveHardwareFaults                                              | 0x0005 |
| * ActiveRadioFaults                                                 | 0x0006 |
| * ActiveNetworkFaults                                               | 0x0007 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * HardwareFaultChange                                               | 0x0000 |
| * RadioFaultChange                                                  | 0x0001 |
| * NetworkFaultChange                                                | 0x0002 |
| * BootReason                                                        | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute NetworkInterfaces
 */
class ReadGeneralDiagnosticsNetworkInterfaces : public ModelCommand {
public:
    ReadGeneralDiagnosticsNetworkInterfaces()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "network-interfaces");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsNetworkInterfaces() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNetworkInterfacesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.NetworkInterfaces response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics NetworkInterfaces Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsNetworkInterfaces : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsNetworkInterfaces()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "network-interfaces");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsNetworkInterfaces() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNetworkInterfacesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"GeneralDiagnostics.NetworkInterfaces response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RebootCount
 */
class ReadGeneralDiagnosticsRebootCount : public ModelCommand {
public:
    ReadGeneralDiagnosticsRebootCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reboot-count");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsRebootCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRebootCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.RebootCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics RebootCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsRebootCount : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsRebootCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reboot-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsRebootCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRebootCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"GeneralDiagnostics.RebootCount response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpTime
 */
class ReadGeneralDiagnosticsUpTime : public ModelCommand {
public:
    ReadGeneralDiagnosticsUpTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "up-time");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsUpTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUpTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.UpTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics UpTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsUpTime : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsUpTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "up-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsUpTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUpTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"GeneralDiagnostics.UpTime response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalOperationalHours
 */
class ReadGeneralDiagnosticsTotalOperationalHours : public ModelCommand {
public:
    ReadGeneralDiagnosticsTotalOperationalHours()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "total-operational-hours");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsTotalOperationalHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTotalOperationalHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.TotalOperationalHours response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics TotalOperationalHours Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsTotalOperationalHours : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsTotalOperationalHours()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "total-operational-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsTotalOperationalHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTotalOperationalHoursWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GeneralDiagnostics.TotalOperationalHours response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BootReasons
 */
class ReadGeneralDiagnosticsBootReasons : public ModelCommand {
public:
    ReadGeneralDiagnosticsBootReasons()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "boot-reasons");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsBootReasons() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBootReasonsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.BootReasons response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics BootReasons Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsBootReasons : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsBootReasons()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "boot-reasons");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsBootReasons() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBootReasonsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"GeneralDiagnostics.BootReasons response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveHardwareFaults
 */
class ReadGeneralDiagnosticsActiveHardwareFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveHardwareFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-hardware-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveHardwareFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveHardwareFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveHardwareFaults response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveHardwareFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsActiveHardwareFaults : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsActiveHardwareFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-hardware-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsActiveHardwareFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveHardwareFaultsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"GeneralDiagnostics.ActiveHardwareFaults response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveRadioFaults
 */
class ReadGeneralDiagnosticsActiveRadioFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveRadioFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-radio-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveRadioFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveRadioFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveRadioFaults response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveRadioFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsActiveRadioFaults : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsActiveRadioFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-radio-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsActiveRadioFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveRadioFaultsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"GeneralDiagnostics.ActiveRadioFaults response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveNetworkFaults
 */
class ReadGeneralDiagnosticsActiveNetworkFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveNetworkFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveNetworkFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveNetworkFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveNetworkFaults response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveNetworkFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsActiveNetworkFaults : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsActiveNetworkFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-network-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsActiveNetworkFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveNetworkFaultsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"GeneralDiagnostics.ActiveNetworkFaults response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadGeneralDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GeneralDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GeneralDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GeneralDiagnostics.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadGeneralDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GeneralDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GeneralDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GeneralDiagnostics.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGeneralDiagnosticsAttributeList : public ModelCommand {
public:
    ReadGeneralDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"GeneralDiagnostics.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadGeneralDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGeneralDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeGeneralDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGeneralDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GeneralDiagnostics.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GroupKeyManagement                                          | 0x003F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * KeySetWrite                                                       |   0x00 |
| * KeySetRead                                                        |   0x01 |
| * KeySetRemove                                                      |   0x03 |
| * KeySetReadAllIndices                                              |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GroupKeyMap                                                       | 0x0000 |
| * GroupTable                                                        | 0x0001 |
| * MaxGroupsPerFabric                                                | 0x0002 |
| * MaxGroupKeysPerFabric                                             | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command KeySetRead
 */
class GroupKeyManagementKeySetRead : public ModelCommand {
public:
    GroupKeyManagementKeySetRead()
        : ModelCommand("key-set-read")
    {
        AddArgument("GroupKeySetID", 0, UINT16_MAX, &mGroupKeySetID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:mGroupKeySetID];
        [cluster keySetReadWithParams:params
                    completionHandler:^(
                        CHIPGroupKeyManagementClusterKeySetReadResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        err = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];
        return err;
    }

private:
    uint16_t mGroupKeySetID;
};

/*
 * Command KeySetReadAllIndices
 */
class GroupKeyManagementKeySetReadAllIndices : public ModelCommand {
public:
    GroupKeyManagementKeySetReadAllIndices()
        : ModelCommand("key-set-read-all-indices")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadAllIndicesParams alloc] init];
        // GroupKeySetIDs Array parsing is not supported yet
        [cluster
            keySetReadAllIndicesWithParams:params
                         completionHandler:^(CHIPGroupKeyManagementClusterKeySetReadAllIndicesResponseParams * _Nullable values,
                             NSError * _Nullable error) {
                             NSLog(@"Values: %@", values);
                             err = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];
        return err;
    }

private:
};

/*
 * Command KeySetRemove
 */
class GroupKeyManagementKeySetRemove : public ModelCommand {
public:
    GroupKeyManagementKeySetRemove()
        : ModelCommand("key-set-remove")
    {
        AddArgument("GroupKeySetID", 0, UINT16_MAX, &mGroupKeySetID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetRemoveParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:mGroupKeySetID];
        [cluster keySetRemoveWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    uint16_t mGroupKeySetID;
};

/*
 * Command KeySetWrite
 */
class GroupKeyManagementKeySetWrite : public ModelCommand {
public:
    GroupKeyManagementKeySetWrite()
        : ModelCommand("key-set-write")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetWriteParams alloc] init];
        // GroupKeySet Struct parsing is not supported yet
        [cluster keySetWriteWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
};

/*
 * Attribute GroupKeyMap
 */
class ReadGroupKeyManagementGroupKeyMap : public ModelCommand {
public:
    ReadGroupKeyManagementGroupKeyMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "group-key-map");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeGroupKeyMapWithParams:params
                                  completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                      NSLog(@"GroupKeyManagement.GroupKeyMap response %@", [value description]);
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "GroupKeyManagement GroupKeyMap Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementGroupKeyMap : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementGroupKeyMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "group-key-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGroupKeyMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"GroupKeyManagement.GroupKeyMap response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GroupTable
 */
class ReadGroupKeyManagementGroupTable : public ModelCommand {
public:
    ReadGroupKeyManagementGroupTable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "group-table");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupTable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeGroupTableWithParams:params
                                 completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                     NSLog(@"GroupKeyManagement.GroupTable response %@", [value description]);
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogError(chipTool, "GroupKeyManagement GroupTable Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementGroupTable : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementGroupTable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "group-table");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementGroupTable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGroupTableWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GroupKeyManagement.GroupTable response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxGroupsPerFabric
 */
class ReadGroupKeyManagementMaxGroupsPerFabric : public ModelCommand {
public:
    ReadGroupKeyManagementMaxGroupsPerFabric()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-groups-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementMaxGroupsPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxGroupsPerFabricWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.MaxGroupsPerFabric response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement MaxGroupsPerFabric Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementMaxGroupsPerFabric : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementMaxGroupsPerFabric()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-groups-per-fabric");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementMaxGroupsPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxGroupsPerFabricWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"GroupKeyManagement.MaxGroupsPerFabric response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxGroupKeysPerFabric
 */
class ReadGroupKeyManagementMaxGroupKeysPerFabric : public ModelCommand {
public:
    ReadGroupKeyManagementMaxGroupKeysPerFabric()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-group-keys-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementMaxGroupKeysPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxGroupKeysPerFabricWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.MaxGroupKeysPerFabric response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement MaxGroupKeysPerFabric Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementMaxGroupKeysPerFabric : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementMaxGroupKeysPerFabric()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-group-keys-per-fabric");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementMaxGroupKeysPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxGroupKeysPerFabricWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GroupKeyManagement.MaxGroupKeysPerFabric response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadGroupKeyManagementServerGeneratedCommandList : public ModelCommand {
public:
    ReadGroupKeyManagementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GroupKeyManagement.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GroupKeyManagement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GroupKeyManagement.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadGroupKeyManagementClientGeneratedCommandList : public ModelCommand {
public:
    ReadGroupKeyManagementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GroupKeyManagement.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GroupKeyManagement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"GroupKeyManagement.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGroupKeyManagementAttributeList : public ModelCommand {
public:
    ReadGroupKeyManagementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementAttributeList : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"GroupKeyManagement.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupKeyManagementClusterRevision : public ModelCommand {
public:
    ReadGroupKeyManagementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupKeyManagementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeGroupKeyManagementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupKeyManagementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"GroupKeyManagement.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Groups                                                      | 0x0004 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddGroup                                                          |   0x00 |
| * ViewGroup                                                         |   0x01 |
| * GetGroupMembership                                                |   0x02 |
| * RemoveGroup                                                       |   0x03 |
| * RemoveAllGroups                                                   |   0x04 |
| * AddGroupIfIdentifying                                             |   0x05 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NameSupport                                                       | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddGroup
 */
class GroupsAddGroup : public ModelCommand {
public:
    GroupsAddGroup()
        : ModelCommand("add-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("GroupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterAddGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.groupName = [[NSString alloc] initWithBytes:mGroupName.data()
                                                    length:mGroupName.size()
                                                  encoding:NSUTF8StringEncoding];
        [cluster addGroupWithParams:params
                  completionHandler:^(CHIPGroupsClusterAddGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                      NSLog(@"Values: %@", values);
                      err = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];
        return err;
    }

private:
    chip::GroupId mGroupId;
    chip::ByteSpan mGroupName;
};

/*
 * Command AddGroupIfIdentifying
 */
class GroupsAddGroupIfIdentifying : public ModelCommand {
public:
    GroupsAddGroupIfIdentifying()
        : ModelCommand("add-group-if-identifying")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("GroupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterAddGroupIfIdentifyingParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.groupName = [[NSString alloc] initWithBytes:mGroupName.data()
                                                    length:mGroupName.size()
                                                  encoding:NSUTF8StringEncoding];
        [cluster addGroupIfIdentifyingWithParams:params
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    chip::GroupId mGroupId;
    chip::ByteSpan mGroupName;
};

/*
 * Command GetGroupMembership
 */
class GroupsGetGroupMembership : public ModelCommand {
public:
    GroupsGetGroupMembership()
        : ModelCommand("get-group-membership")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterGetGroupMembershipParams alloc] init];
        // groupList Array parsing is not supported yet
        [cluster getGroupMembershipWithParams:params
                            completionHandler:^(
                                CHIPGroupsClusterGetGroupMembershipResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
};

/*
 * Command RemoveAllGroups
 */
class GroupsRemoveAllGroups : public ModelCommand {
public:
    GroupsRemoveAllGroups()
        : ModelCommand("remove-all-groups")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster removeAllGroupsWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command RemoveGroup
 */
class GroupsRemoveGroup : public ModelCommand {
public:
    GroupsRemoveGroup()
        : ModelCommand("remove-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterRemoveGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster removeGroupWithParams:params
                     completionHandler:^(CHIPGroupsClusterRemoveGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    chip::GroupId mGroupId;
};

/*
 * Command ViewGroup
 */
class GroupsViewGroup : public ModelCommand {
public:
    GroupsViewGroup()
        : ModelCommand("view-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       err = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];
        return err;
    }

private:
    chip::GroupId mGroupId;
};

/*
 * Attribute NameSupport
 */
class ReadGroupsNameSupport : public ModelCommand {
public:
    ReadGroupsNameSupport()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNameSupportWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.NameSupport response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups NameSupport Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupsNameSupport : public ModelCommand {
public:
    SubscribeAttributeGroupsNameSupport()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNameSupportWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Groups.NameSupport response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadGroupsServerGeneratedCommandList : public ModelCommand {
public:
    ReadGroupsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Groups.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Groups ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeGroupsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGroupsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Groups.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadGroupsClientGeneratedCommandList : public ModelCommand {
public:
    ReadGroupsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Groups.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Groups ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeGroupsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeGroupsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Groups.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGroupsAttributeList : public ModelCommand {
public:
    ReadGroupsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupsAttributeList : public ModelCommand {
public:
    SubscribeAttributeGroupsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Groups.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupsClusterRevision : public ModelCommand {
public:
    ReadGroupsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeGroupsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeGroupsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeGroupsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Groups.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Identify                                                    | 0x0003 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Identify                                                          |   0x00 |
| * IdentifyQuery                                                     |   0x01 |
| * TriggerEffect                                                     |   0x40 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * IdentifyTime                                                      | 0x0000 |
| * IdentifyType                                                      | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Identify
 */
class IdentifyIdentify : public ModelCommand {
public:
    IdentifyIdentify()
        : ModelCommand("identify")
    {
        AddArgument("IdentifyTime", 0, UINT16_MAX, &mIdentifyTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPIdentifyClusterIdentifyParams alloc] init];
        params.identifyTime = [NSNumber numberWithUnsignedShort:mIdentifyTime];
        [cluster identifyWithParams:params
                  completionHandler:^(NSError * _Nullable error) {
                      err = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];
        return err;
    }

private:
    uint16_t mIdentifyTime;
};

/*
 * Command IdentifyQuery
 */
class IdentifyIdentifyQuery : public ModelCommand {
public:
    IdentifyIdentifyQuery()
        : ModelCommand("identify-query")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster identifyQueryWithCompletionHandler:^(
            CHIPIdentifyClusterIdentifyQueryResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command TriggerEffect
 */
class IdentifyTriggerEffect : public ModelCommand {
public:
    IdentifyTriggerEffect()
        : ModelCommand("trigger-effect")
    {
        AddArgument("EffectIdentifier", 0, UINT8_MAX, &mEffectIdentifier);
        AddArgument("EffectVariant", 0, UINT8_MAX, &mEffectVariant);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000040) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPIdentifyClusterTriggerEffectParams alloc] init];
        params.effectIdentifier = [NSNumber numberWithUnsignedChar:mEffectIdentifier];
        params.effectVariant = [NSNumber numberWithUnsignedChar:mEffectVariant];
        [cluster triggerEffectWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint8_t mEffectIdentifier;
    uint8_t mEffectVariant;
};

/*
 * Attribute IdentifyTime
 */
class ReadIdentifyIdentifyTime : public ModelCommand {
public:
    ReadIdentifyIdentifyTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-time");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeIdentifyTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.IdentifyTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify IdentifyTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteIdentifyIdentifyTime : public ModelCommand {
public:
    WriteIdentifyIdentifyTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeIdentifyTimeWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "Identify IdentifyTime Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeIdentifyIdentifyTime : public ModelCommand {
public:
    SubscribeAttributeIdentifyIdentifyTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeIdentifyTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Identify.IdentifyTime response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute IdentifyType
 */
class ReadIdentifyIdentifyType : public ModelCommand {
public:
    ReadIdentifyIdentifyType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-type");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeIdentifyTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.IdentifyType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify IdentifyType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIdentifyIdentifyType : public ModelCommand {
public:
    SubscribeAttributeIdentifyIdentifyType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "identify-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyIdentifyType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeIdentifyTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Identify.IdentifyType response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadIdentifyServerGeneratedCommandList : public ModelCommand {
public:
    ReadIdentifyServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Identify.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Identify ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeIdentifyServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeIdentifyServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Identify.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadIdentifyClientGeneratedCommandList : public ModelCommand {
public:
    ReadIdentifyClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Identify.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Identify ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeIdentifyClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeIdentifyClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Identify.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadIdentifyAttributeList : public ModelCommand {
public:
    ReadIdentifyAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIdentifyAttributeList : public ModelCommand {
public:
    SubscribeAttributeIdentifyAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Identify.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadIdentifyClusterRevision : public ModelCommand {
public:
    ReadIdentifyClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIdentifyClusterRevision : public ModelCommand {
public:
    SubscribeAttributeIdentifyClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIdentifyClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Identify.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster IlluminanceMeasurement                                      | 0x0400 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * LightSensorType                                                   | 0x0004 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadIlluminanceMeasurementMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"IlluminanceMeasurement.MeasuredValue response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadIlluminanceMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"IlluminanceMeasurement.MinMeasuredValue response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadIlluminanceMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"IlluminanceMeasurement.MaxMeasuredValue response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadIlluminanceMeasurementTolerance : public ModelCommand {
public:
    ReadIlluminanceMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.Tolerance response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementTolerance : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeToleranceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"IlluminanceMeasurement.Tolerance response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LightSensorType
 */
class ReadIlluminanceMeasurementLightSensorType : public ModelCommand {
public:
    ReadIlluminanceMeasurementLightSensorType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "light-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementLightSensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLightSensorTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.LightSensorType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement LightSensorType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementLightSensorType : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementLightSensorType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "light-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementLightSensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLightSensorTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"IlluminanceMeasurement.LightSensorType response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadIlluminanceMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReadIlluminanceMeasurementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"IlluminanceMeasurement.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "IlluminanceMeasurement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(
                                                                  @"IlluminanceMeasurement.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadIlluminanceMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReadIlluminanceMeasurementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"IlluminanceMeasurement.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "IlluminanceMeasurement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(
                                                                  @"IlluminanceMeasurement.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadIlluminanceMeasurementAttributeList : public ModelCommand {
public:
    ReadIlluminanceMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"IlluminanceMeasurement.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadIlluminanceMeasurementClusterRevision : public ModelCommand {
public:
    ReadIlluminanceMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeIlluminanceMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeIlluminanceMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeIlluminanceMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"IlluminanceMeasurement.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster KeypadInput                                                 | 0x0509 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SendKey                                                           |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command SendKey
 */
class KeypadInputSendKey : public ModelCommand {
public:
    KeypadInputSendKey()
        : ModelCommand("send-key")
    {
        AddArgument("KeyCode", 0, UINT8_MAX, &mKeyCode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPKeypadInputClusterSendKeyParams alloc] init];
        params.keyCode = [NSNumber numberWithUnsignedChar:mKeyCode];
        [cluster sendKeyWithParams:params
                 completionHandler:^(CHIPKeypadInputClusterSendKeyResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     err = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];
        return err;
    }

private:
    uint8_t mKeyCode;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadKeypadInputServerGeneratedCommandList : public ModelCommand {
public:
    ReadKeypadInputServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"KeypadInput.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "KeypadInput ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeKeypadInputServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeKeypadInputServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeKeypadInputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"KeypadInput.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadKeypadInputClientGeneratedCommandList : public ModelCommand {
public:
    ReadKeypadInputClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"KeypadInput.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "KeypadInput ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeKeypadInputClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeKeypadInputClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeKeypadInputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"KeypadInput.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadKeypadInputAttributeList : public ModelCommand {
public:
    ReadKeypadInputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"KeypadInput.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "KeypadInput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeKeypadInputAttributeList : public ModelCommand {
public:
    SubscribeAttributeKeypadInputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeKeypadInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"KeypadInput.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadKeypadInputClusterRevision : public ModelCommand {
public:
    ReadKeypadInputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"KeypadInput.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "KeypadInput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeKeypadInputClusterRevision : public ModelCommand {
public:
    SubscribeAttributeKeypadInputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeKeypadInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"KeypadInput.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LevelControl                                                | 0x0008 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MoveToLevel                                                       |   0x00 |
| * Move                                                              |   0x01 |
| * Step                                                              |   0x02 |
| * Stop                                                              |   0x03 |
| * MoveToLevelWithOnOff                                              |   0x04 |
| * MoveWithOnOff                                                     |   0x05 |
| * StepWithOnOff                                                     |   0x06 |
| * StopWithOnOff                                                     |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentLevel                                                      | 0x0000 |
| * RemainingTime                                                     | 0x0001 |
| * MinLevel                                                          | 0x0002 |
| * MaxLevel                                                          | 0x0003 |
| * CurrentFrequency                                                  | 0x0004 |
| * MinFrequency                                                      | 0x0005 |
| * MaxFrequency                                                      | 0x0006 |
| * Options                                                           | 0x000F |
| * OnOffTransitionTime                                               | 0x0010 |
| * OnLevel                                                           | 0x0011 |
| * OnTransitionTime                                                  | 0x0012 |
| * OffTransitionTime                                                 | 0x0013 |
| * DefaultMoveRate                                                   | 0x0014 |
| * StartUpCurrentLevel                                               | 0x4000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Move
 */
class LevelControlMove : public ModelCommand {
public:
    LevelControlMove()
        : ModelCommand("move")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterMoveParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];
        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster moveWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  err = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];
        return err;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command MoveToLevel
 */
class LevelControlMoveToLevel : public ModelCommand {
public:
    LevelControlMoveToLevel()
        : ModelCommand("move-to-level")
    {
        AddArgument("Level", 0, UINT8_MAX, &mLevel);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:mLevel];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];
        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command MoveToLevelWithOnOff
 */
class LevelControlMoveToLevelWithOnOff : public ModelCommand {
public:
    LevelControlMoveToLevelWithOnOff()
        : ModelCommand("move-to-level-with-on-off")
    {
        AddArgument("Level", 0, UINT8_MAX, &mLevel);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelWithOnOffParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:mLevel];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster moveToLevelWithOnOffWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
};

/*
 * Command MoveWithOnOff
 */
class LevelControlMoveWithOnOff : public ModelCommand {
public:
    LevelControlMoveWithOnOff()
        : ModelCommand("move-with-on-off")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterMoveWithOnOffParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        [cluster moveWithOnOffWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
};

/*
 * Command Step
 */
class LevelControlStep : public ModelCommand {
public:
    LevelControlStep()
        : ModelCommand("step")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterStepParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];
        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster stepWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  err = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];
        return err;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command StepWithOnOff
 */
class LevelControlStepWithOnOff : public ModelCommand {
public:
    LevelControlStepWithOnOff()
        : ModelCommand("step-with-on-off")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterStepWithOnOffParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster stepWithOnOffWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
};

/*
 * Command Stop
 */
class LevelControlStop : public ModelCommand {
public:
    LevelControlStop()
        : ModelCommand("stop")
    {
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPLevelControlClusterStopParams alloc] init];
        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];
        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster stopWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  err = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];
        return err;
    }

private:
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command StopWithOnOff
 */
class LevelControlStopWithOnOff : public ModelCommand {
public:
    LevelControlStopWithOnOff()
        : ModelCommand("stop-with-on-off")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster stopWithOnOffWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute CurrentLevel
 */
class ReadLevelControlCurrentLevel : public ModelCommand {
public:
    ReadLevelControlCurrentLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.CurrentLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl CurrentLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlCurrentLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlCurrentLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"LevelControl.CurrentLevel response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadLevelControlRemainingTime : public ModelCommand {
public:
    ReadLevelControlRemainingTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.RemainingTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl RemainingTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlRemainingTime : public ModelCommand {
public:
    SubscribeAttributeLevelControlRemainingTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRemainingTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"LevelControl.RemainingTime response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinLevel
 */
class ReadLevelControlMinLevel : public ModelCommand {
public:
    ReadLevelControlMinLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MinLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MinLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlMinLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlMinLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlMinLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"LevelControl.MinLevel response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxLevel
 */
class ReadLevelControlMaxLevel : public ModelCommand {
public:
    ReadLevelControlMaxLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MaxLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MaxLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlMaxLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlMaxLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlMaxLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"LevelControl.MaxLevel response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFrequency
 */
class ReadLevelControlCurrentFrequency : public ModelCommand {
public:
    ReadLevelControlCurrentFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.CurrentFrequency response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl CurrentFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlCurrentFrequency : public ModelCommand {
public:
    SubscribeAttributeLevelControlCurrentFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlCurrentFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentFrequencyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"LevelControl.CurrentFrequency response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinFrequency
 */
class ReadLevelControlMinFrequency : public ModelCommand {
public:
    ReadLevelControlMinFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MinFrequency response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MinFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlMinFrequency : public ModelCommand {
public:
    SubscribeAttributeLevelControlMinFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlMinFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinFrequencyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"LevelControl.MinFrequency response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFrequency
 */
class ReadLevelControlMaxFrequency : public ModelCommand {
public:
    ReadLevelControlMaxFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MaxFrequency response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MaxFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlMaxFrequency : public ModelCommand {
public:
    SubscribeAttributeLevelControlMaxFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlMaxFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxFrequencyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"LevelControl.MaxFrequency response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Options
 */
class ReadLevelControlOptions : public ModelCommand {
public:
    ReadLevelControlOptions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "options");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.Options response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl Options Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOptions : public ModelCommand {
public:
    WriteLevelControlOptions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOptionsWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "LevelControl Options Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeLevelControlOptions : public ModelCommand {
public:
    SubscribeAttributeLevelControlOptions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOptionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"LevelControl.Options response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnOffTransitionTime
 */
class ReadLevelControlOnOffTransitionTime : public ModelCommand {
public:
    ReadLevelControlOnOffTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnOffTransitionTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnOffTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOnOffTransitionTime : public ModelCommand {
public:
    WriteLevelControlOnOffTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster
            writeAttributeOnOffTransitionTimeWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "LevelControl OnOffTransitionTime Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeLevelControlOnOffTransitionTime : public ModelCommand {
public:
    SubscribeAttributeLevelControlOnOffTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOnOffTransitionTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"LevelControl.OnOffTransitionTime response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnLevel
 */
class ReadLevelControlOnLevel : public ModelCommand {
public:
    ReadLevelControlOnLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOnLevel : public ModelCommand {
public:
    WriteLevelControlOnLevel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOnLevelWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "LevelControl OnLevel Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeLevelControlOnLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlOnLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"LevelControl.OnLevel response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTransitionTime
 */
class ReadLevelControlOnTransitionTime : public ModelCommand {
public:
    ReadLevelControlOnTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnTransitionTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOnTransitionTime : public ModelCommand {
public:
    WriteLevelControlOnTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeOnTransitionTimeWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           err = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogError(chipTool, "LevelControl OnTransitionTime Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeLevelControlOnTransitionTime : public ModelCommand {
public:
    SubscribeAttributeLevelControlOnTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnTransitionTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"LevelControl.OnTransitionTime response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffTransitionTime
 */
class ReadLevelControlOffTransitionTime : public ModelCommand {
public:
    ReadLevelControlOffTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OffTransitionTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OffTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlOffTransitionTime : public ModelCommand {
public:
    WriteLevelControlOffTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeOffTransitionTimeWithValue:value
                                        completionHandler:^(NSError * _Nullable error) {
                                            err = [CHIPError errorToCHIPErrorCode:error];
                                            ChipLogError(chipTool, "LevelControl OffTransitionTime Error: %s", chip::ErrorStr(err));
                                            SetCommandExitStatus(err);
                                        }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeLevelControlOffTransitionTime : public ModelCommand {
public:
    SubscribeAttributeLevelControlOffTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOffTransitionTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"LevelControl.OffTransitionTime response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DefaultMoveRate
 */
class ReadLevelControlDefaultMoveRate : public ModelCommand {
public:
    ReadLevelControlDefaultMoveRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "default-move-rate");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDefaultMoveRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.DefaultMoveRate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl DefaultMoveRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlDefaultMoveRate : public ModelCommand {
public:
    WriteLevelControlDefaultMoveRate()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeDefaultMoveRateWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "LevelControl DefaultMoveRate Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeLevelControlDefaultMoveRate : public ModelCommand {
public:
    SubscribeAttributeLevelControlDefaultMoveRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDefaultMoveRateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LevelControl.DefaultMoveRate response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpCurrentLevel
 */
class ReadLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    ReadLevelControlStartUpCurrentLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartUpCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.StartUpCurrentLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl StartUpCurrentLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    WriteLevelControlStartUpCurrentLevel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00004000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeStartUpCurrentLevelWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "LevelControl StartUpCurrentLevel Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    SubscribeAttributeLevelControlStartUpCurrentLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00004000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeStartUpCurrentLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"LevelControl.StartUpCurrentLevel response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadLevelControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadLevelControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LevelControl.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LevelControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeLevelControlServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLevelControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"LevelControl.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadLevelControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadLevelControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LevelControl.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LevelControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeLevelControlClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLevelControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"LevelControl.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadLevelControlAttributeList : public ModelCommand {
public:
    ReadLevelControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlAttributeList : public ModelCommand {
public:
    SubscribeAttributeLevelControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"LevelControl.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadLevelControlFeatureMap : public ModelCommand {
public:
    ReadLevelControlFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlFeatureMap : public ModelCommand {
public:
    SubscribeAttributeLevelControlFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"LevelControl.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLevelControlClusterRevision : public ModelCommand {
public:
    ReadLevelControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLevelControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributeLevelControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLevelControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LevelControl.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LocalizationConfiguration                                   | 0x002B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActiveLocale                                                      | 0x0001 |
| * SupportedLocales                                                  | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute ActiveLocale
 */
class ReadLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    ReadLocalizationConfigurationActiveLocale()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-locale");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveLocaleWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.ActiveLocale response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration ActiveLocale Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    WriteLocalizationConfigurationActiveLocale()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "active-locale");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster
            writeAttributeActiveLocaleWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "LocalizationConfiguration ActiveLocale Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationActiveLocale()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-locale");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActiveLocaleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"LocalizationConfiguration.ActiveLocale response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedLocales
 */
class ReadLocalizationConfigurationSupportedLocales : public ModelCommand {
public:
    ReadLocalizationConfigurationSupportedLocales()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-locales");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationSupportedLocales() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportedLocalesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.SupportedLocales response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration SupportedLocales Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLocalizationConfigurationSupportedLocales : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationSupportedLocales()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-locales");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationSupportedLocales() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedLocalesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"LocalizationConfiguration.SupportedLocales response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadLocalizationConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReadLocalizationConfigurationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LocalizationConfiguration.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LocalizationConfiguration ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeLocalizationConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"LocalizationConfiguration.ServerGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadLocalizationConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReadLocalizationConfigurationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LocalizationConfiguration.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LocalizationConfiguration ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeLocalizationConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"LocalizationConfiguration.ClientGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLocalizationConfigurationClusterRevision : public ModelCommand {
public:
    ReadLocalizationConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLocalizationConfigurationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeLocalizationConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLocalizationConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LocalizationConfiguration.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LowPower                                                    | 0x0508 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Sleep                                                             |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Sleep
 */
class LowPowerSleep : public ModelCommand {
public:
    LowPowerSleep()
        : ModelCommand("sleep")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster sleepWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadLowPowerServerGeneratedCommandList : public ModelCommand {
public:
    ReadLowPowerServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LowPower.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LowPower ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeLowPowerServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLowPowerServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLowPowerServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"LowPower.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadLowPowerClientGeneratedCommandList : public ModelCommand {
public:
    ReadLowPowerClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LowPower.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LowPower ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeLowPowerClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeLowPowerClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLowPowerClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"LowPower.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadLowPowerAttributeList : public ModelCommand {
public:
    ReadLowPowerAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LowPower.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LowPower AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLowPowerAttributeList : public ModelCommand {
public:
    SubscribeAttributeLowPowerAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLowPowerAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"LowPower.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLowPowerClusterRevision : public ModelCommand {
public:
    ReadLowPowerClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LowPower.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LowPower ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeLowPowerClusterRevision : public ModelCommand {
public:
    SubscribeAttributeLowPowerClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeLowPowerClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"LowPower.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaInput                                                  | 0x0507 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SelectInput                                                       |   0x00 |
| * ShowInputStatus                                                   |   0x01 |
| * HideInputStatus                                                   |   0x02 |
| * RenameInput                                                       |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * InputList                                                         | 0x0000 |
| * CurrentInput                                                      | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command HideInputStatus
 */
class MediaInputHideInputStatus : public ModelCommand {
public:
    MediaInputHideInputStatus()
        : ModelCommand("hide-input-status")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster hideInputStatusWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command RenameInput
 */
class MediaInputRenameInput : public ModelCommand {
public:
    MediaInputRenameInput()
        : ModelCommand("rename-input")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        AddArgument("Name", &mName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaInputClusterRenameInputParams alloc] init];
        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        params.name = [[NSString alloc] initWithBytes:mName.data() length:mName.size() encoding:NSUTF8StringEncoding];
        [cluster renameInputWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint8_t mIndex;
    chip::ByteSpan mName;
};

/*
 * Command SelectInput
 */
class MediaInputSelectInput : public ModelCommand {
public:
    MediaInputSelectInput()
        : ModelCommand("select-input")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaInputClusterSelectInputParams alloc] init];
        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        [cluster selectInputWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint8_t mIndex;
};

/*
 * Command ShowInputStatus
 */
class MediaInputShowInputStatus : public ModelCommand {
public:
    MediaInputShowInputStatus()
        : ModelCommand("show-input-status")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster showInputStatusWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute InputList
 */
class ReadMediaInputInputList : public ModelCommand {
public:
    ReadMediaInputInputList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "input-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputInputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInputListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.InputList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput InputList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputInputList : public ModelCommand {
public:
    SubscribeAttributeMediaInputInputList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "input-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputInputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInputListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"MediaInput.InputList response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentInput
 */
class ReadMediaInputCurrentInput : public ModelCommand {
public:
    ReadMediaInputCurrentInput()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-input");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputCurrentInput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentInputWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.CurrentInput response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput CurrentInput Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputCurrentInput : public ModelCommand {
public:
    SubscribeAttributeMediaInputCurrentInput()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-input");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputCurrentInput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentInputWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"MediaInput.CurrentInput response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadMediaInputServerGeneratedCommandList : public ModelCommand {
public:
    ReadMediaInputServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"MediaInput.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "MediaInput ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeMediaInputServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeMediaInputServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"MediaInput.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadMediaInputClientGeneratedCommandList : public ModelCommand {
public:
    ReadMediaInputClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"MediaInput.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "MediaInput ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeMediaInputClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeMediaInputClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"MediaInput.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadMediaInputAttributeList : public ModelCommand {
public:
    ReadMediaInputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputAttributeList : public ModelCommand {
public:
    SubscribeAttributeMediaInputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"MediaInput.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaInputClusterRevision : public ModelCommand {
public:
    ReadMediaInputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaInputClusterRevision : public ModelCommand {
public:
    SubscribeAttributeMediaInputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"MediaInput.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaPlayback                                               | 0x0506 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Play                                                              |   0x00 |
| * Pause                                                             |   0x01 |
| * StopPlayback                                                      |   0x02 |
| * StartOver                                                         |   0x03 |
| * Previous                                                          |   0x04 |
| * Next                                                              |   0x05 |
| * Rewind                                                            |   0x06 |
| * FastForward                                                       |   0x07 |
| * SkipForward                                                       |   0x08 |
| * SkipBackward                                                      |   0x09 |
| * Seek                                                              |   0x0B |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentState                                                      | 0x0000 |
| * StartTime                                                         | 0x0001 |
| * Duration                                                          | 0x0002 |
| * SampledPosition                                                   | 0x0003 |
| * PlaybackSpeed                                                     | 0x0004 |
| * SeekRangeEnd                                                      | 0x0005 |
| * SeekRangeStart                                                    | 0x0006 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command FastForward
 */
class MediaPlaybackFastForward : public ModelCommand {
public:
    MediaPlaybackFastForward()
        : ModelCommand("fast-forward")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster fastForwardWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command Next
 */
class MediaPlaybackNext : public ModelCommand {
public:
    MediaPlaybackNext()
        : ModelCommand("next")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster nextWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command Pause
 */
class MediaPlaybackPause : public ModelCommand {
public:
    MediaPlaybackPause()
        : ModelCommand("pause")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster pauseWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command Play
 */
class MediaPlaybackPlay : public ModelCommand {
public:
    MediaPlaybackPlay()
        : ModelCommand("play")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster playWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command Previous
 */
class MediaPlaybackPrevious : public ModelCommand {
public:
    MediaPlaybackPrevious()
        : ModelCommand("previous")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster previousWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command Rewind
 */
class MediaPlaybackRewind : public ModelCommand {
public:
    MediaPlaybackRewind()
        : ModelCommand("rewind")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster rewindWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command Seek
 */
class MediaPlaybackSeek : public ModelCommand {
public:
    MediaPlaybackSeek()
        : ModelCommand("seek")
    {
        AddArgument("Position", 0, UINT64_MAX, &mPosition);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaPlaybackClusterSeekParams alloc] init];
        params.position = [NSNumber numberWithUnsignedLongLong:mPosition];
        [cluster seekWithParams:params
              completionHandler:^(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                  NSLog(@"Values: %@", values);
                  err = [CHIPError errorToCHIPErrorCode:error];
                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];
        return err;
    }

private:
    uint64_t mPosition;
};

/*
 * Command SkipBackward
 */
class MediaPlaybackSkipBackward : public ModelCommand {
public:
    MediaPlaybackSkipBackward()
        : ModelCommand("skip-backward")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mDeltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaPlaybackClusterSkipBackwardParams alloc] init];
        params.deltaPositionMilliseconds = [NSNumber numberWithUnsignedLongLong:mDeltaPositionMilliseconds];
        [cluster
            skipBackwardWithParams:params
                 completionHandler:^(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     err = [CHIPError errorToCHIPErrorCode:error];
                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];
        return err;
    }

private:
    uint64_t mDeltaPositionMilliseconds;
};

/*
 * Command SkipForward
 */
class MediaPlaybackSkipForward : public ModelCommand {
public:
    MediaPlaybackSkipForward()
        : ModelCommand("skip-forward")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mDeltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPMediaPlaybackClusterSkipForwardParams alloc] init];
        params.deltaPositionMilliseconds = [NSNumber numberWithUnsignedLongLong:mDeltaPositionMilliseconds];
        [cluster
            skipForwardWithParams:params
                completionHandler:^(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                    NSLog(@"Values: %@", values);
                    err = [CHIPError errorToCHIPErrorCode:error];
                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                    SetCommandExitStatus(err);
                }];
        return err;
    }

private:
    uint64_t mDeltaPositionMilliseconds;
};

/*
 * Command StartOver
 */
class MediaPlaybackStartOver : public ModelCommand {
public:
    MediaPlaybackStartOver()
        : ModelCommand("start-over")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster startOverWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command StopPlayback
 */
class MediaPlaybackStopPlayback : public ModelCommand {
public:
    MediaPlaybackStopPlayback()
        : ModelCommand("stop-playback")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster stopPlaybackWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute CurrentState
 */
class ReadMediaPlaybackCurrentState : public ModelCommand {
public:
    ReadMediaPlaybackCurrentState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-state");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackCurrentState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.CurrentState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback CurrentState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackCurrentState : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackCurrentState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackCurrentState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"MediaPlayback.CurrentState response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartTime
 */
class ReadMediaPlaybackStartTime : public ModelCommand {
public:
    ReadMediaPlaybackStartTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-time");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackStartTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.StartTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback StartTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackStartTime : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackStartTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackStartTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStartTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"MediaPlayback.StartTime response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Duration
 */
class ReadMediaPlaybackDuration : public ModelCommand {
public:
    ReadMediaPlaybackDuration()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "duration");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackDuration() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDurationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.Duration response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback Duration Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackDuration : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackDuration()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "duration");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackDuration() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDurationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"MediaPlayback.Duration response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SampledPosition
 */
class ReadMediaPlaybackSampledPosition : public ModelCommand {
public:
    ReadMediaPlaybackSampledPosition()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "sampled-position");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSampledPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSampledPositionWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackPosition * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.SampledPosition response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback SampledPosition Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

/*
 * Attribute PlaybackSpeed
 */
class ReadMediaPlaybackPlaybackSpeed : public ModelCommand {
public:
    ReadMediaPlaybackPlaybackSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "playback-speed");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPlaybackSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePlaybackSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.PlaybackSpeed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback PlaybackSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackPlaybackSpeed : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackPlaybackSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "playback-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackPlaybackSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePlaybackSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"MediaPlayback.PlaybackSpeed response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeEnd
 */
class ReadMediaPlaybackSeekRangeEnd : public ModelCommand {
public:
    ReadMediaPlaybackSeekRangeEnd()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-end");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeEnd() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSeekRangeEndWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.SeekRangeEnd response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback SeekRangeEnd Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackSeekRangeEnd : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackSeekRangeEnd()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "seek-range-end");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackSeekRangeEnd() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSeekRangeEndWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"MediaPlayback.SeekRangeEnd response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeStart
 */
class ReadMediaPlaybackSeekRangeStart : public ModelCommand {
public:
    ReadMediaPlaybackSeekRangeStart()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-start");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeStart() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSeekRangeStartWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.SeekRangeStart response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback SeekRangeStart Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackSeekRangeStart : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackSeekRangeStart()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "seek-range-start");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackSeekRangeStart() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSeekRangeStartWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"MediaPlayback.SeekRangeStart response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadMediaPlaybackServerGeneratedCommandList : public ModelCommand {
public:
    ReadMediaPlaybackServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"MediaPlayback.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "MediaPlayback ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"MediaPlayback.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadMediaPlaybackClientGeneratedCommandList : public ModelCommand {
public:
    ReadMediaPlaybackClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"MediaPlayback.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "MediaPlayback ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"MediaPlayback.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadMediaPlaybackAttributeList : public ModelCommand {
public:
    ReadMediaPlaybackAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackAttributeList : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"MediaPlayback.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaPlaybackClusterRevision : public ModelCommand {
public:
    ReadMediaPlaybackClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeMediaPlaybackClusterRevision : public ModelCommand {
public:
    SubscribeAttributeMediaPlaybackClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeMediaPlaybackClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"MediaPlayback.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ModeSelect                                                  | 0x0050 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeToMode                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentMode                                                       | 0x0000 |
| * SupportedModes                                                    | 0x0001 |
| * OnMode                                                            | 0x0002 |
| * StartUpMode                                                       | 0x0003 |
| * Description                                                       | 0x0004 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeToMode
 */
class ModeSelectChangeToMode : public ModelCommand {
public:
    ModeSelectChangeToMode()
        : ModelCommand("change-to-mode")
    {
        AddArgument("NewMode", 0, UINT8_MAX, &mNewMode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPModeSelectClusterChangeToModeParams alloc] init];
        params.newMode = [NSNumber numberWithUnsignedChar:mNewMode];
        [cluster changeToModeWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    uint8_t mNewMode;
};

/*
 * Attribute CurrentMode
 */
class ReadModeSelectCurrentMode : public ModelCommand {
public:
    ReadModeSelectCurrentMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectCurrentMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.CurrentMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect CurrentMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectCurrentMode : public ModelCommand {
public:
    SubscribeAttributeModeSelectCurrentMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectCurrentMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ModeSelect.CurrentMode response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedModes
 */
class ReadModeSelectSupportedModes : public ModelCommand {
public:
    ReadModeSelectSupportedModes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-modes");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectSupportedModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportedModesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.SupportedModes response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect SupportedModes Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectSupportedModes : public ModelCommand {
public:
    SubscribeAttributeModeSelectSupportedModes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-modes");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectSupportedModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedModesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ModeSelect.SupportedModes response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnMode
 */
class ReadModeSelectOnMode : public ModelCommand {
public:
    ReadModeSelectOnMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.OnMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect OnMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteModeSelectOnMode : public ModelCommand {
public:
    WriteModeSelectOnMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) WriteAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOnModeWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "ModeSelect OnMode Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeModeSelectOnMode : public ModelCommand {
public:
    SubscribeAttributeModeSelectOnMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"ModeSelect.OnMode response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpMode
 */
class ReadModeSelectStartUpMode : public ModelCommand {
public:
    ReadModeSelectStartUpMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartUpModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.StartUpMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect StartUpMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectStartUpMode : public ModelCommand {
public:
    SubscribeAttributeModeSelectStartUpMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStartUpModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ModeSelect.StartUpMode response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadModeSelectDescription : public ModelCommand {
public:
    ReadModeSelectDescription()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDescriptionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.Description response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect Description Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectDescription : public ModelCommand {
public:
    SubscribeAttributeModeSelectDescription()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDescriptionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ModeSelect.Description response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadModeSelectServerGeneratedCommandList : public ModelCommand {
public:
    ReadModeSelectServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ModeSelect.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ModeSelect ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeModeSelectServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeModeSelectServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ModeSelect.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadModeSelectClientGeneratedCommandList : public ModelCommand {
public:
    ReadModeSelectClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ModeSelect.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ModeSelect ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeModeSelectClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeModeSelectClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ModeSelect.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadModeSelectAttributeList : public ModelCommand {
public:
    ReadModeSelectAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectAttributeList : public ModelCommand {
public:
    SubscribeAttributeModeSelectAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ModeSelect.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadModeSelectClusterRevision : public ModelCommand {
public:
    ReadModeSelectClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeModeSelectClusterRevision : public ModelCommand {
public:
    SubscribeAttributeModeSelectClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeModeSelectClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ModeSelect.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster NetworkCommissioning                                        | 0x0031 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ScanNetworks                                                      |   0x00 |
| * AddOrUpdateWiFiNetwork                                            |   0x02 |
| * AddOrUpdateThreadNetwork                                          |   0x03 |
| * RemoveNetwork                                                     |   0x04 |
| * ConnectNetwork                                                    |   0x06 |
| * ReorderNetwork                                                    |   0x08 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxNetworks                                                       | 0x0000 |
| * Networks                                                          | 0x0001 |
| * ScanMaxTimeSeconds                                                | 0x0002 |
| * ConnectMaxTimeSeconds                                             | 0x0003 |
| * InterfaceEnabled                                                  | 0x0004 |
| * LastNetworkingStatus                                              | 0x0005 |
| * LastNetworkID                                                     | 0x0006 |
| * LastConnectErrorValue                                             | 0x0007 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddOrUpdateThreadNetwork
 */
class NetworkCommissioningAddOrUpdateThreadNetwork : public ModelCommand {
public:
    NetworkCommissioningAddOrUpdateThreadNetwork()
        : ModelCommand("add-or-update-thread-network")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterAddOrUpdateThreadNetworkParams alloc] init];
        params.operationalDataset = [[NSData alloc] initWithBytes:mOperationalDataset.data() length:mOperationalDataset.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster addOrUpdateThreadNetworkWithParams:params
                                  completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                                      NSError * _Nullable error) {
                                      NSLog(@"Values: %@", values);
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    chip::ByteSpan mOperationalDataset;
    uint64_t mBreadcrumb;
};

/*
 * Command AddOrUpdateWiFiNetwork
 */
class NetworkCommissioningAddOrUpdateWiFiNetwork : public ModelCommand {
public:
    NetworkCommissioningAddOrUpdateWiFiNetwork()
        : ModelCommand("add-or-update-wi-fi-network")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterAddOrUpdateWiFiNetworkParams alloc] init];
        params.ssid = [[NSData alloc] initWithBytes:mSsid.data() length:mSsid.size()];
        params.credentials = [[NSData alloc] initWithBytes:mCredentials.data() length:mCredentials.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster addOrUpdateWiFiNetworkWithParams:params
                                completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    err = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }

private:
    chip::ByteSpan mSsid;
    chip::ByteSpan mCredentials;
    uint64_t mBreadcrumb;
};

/*
 * Command ConnectNetwork
 */
class NetworkCommissioningConnectNetwork : public ModelCommand {
public:
    NetworkCommissioningConnectNetwork()
        : ModelCommand("connect-network")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterConnectNetworkParams alloc] init];
        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster connectNetworkWithParams:params
                        completionHandler:^(CHIPNetworkCommissioningClusterConnectNetworkResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            err = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];
        return err;
    }

private:
    chip::ByteSpan mNetworkID;
    uint64_t mBreadcrumb;
};

/*
 * Command RemoveNetwork
 */
class NetworkCommissioningRemoveNetwork : public ModelCommand {
public:
    NetworkCommissioningRemoveNetwork()
        : ModelCommand("remove-network")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterRemoveNetworkParams alloc] init];
        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster removeNetworkWithParams:params
                       completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                           NSError * _Nullable error) {
                           NSLog(@"Values: %@", values);
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    chip::ByteSpan mNetworkID;
    uint64_t mBreadcrumb;
};

/*
 * Command ReorderNetwork
 */
class NetworkCommissioningReorderNetwork : public ModelCommand {
public:
    NetworkCommissioningReorderNetwork()
        : ModelCommand("reorder-network")
    {
        AddArgument("NetworkIndex", 0, UINT8_MAX, &mNetworkIndex);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterReorderNetworkParams alloc] init];
        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];
        params.networkIndex = [NSNumber numberWithUnsignedChar:mNetworkIndex];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster reorderNetworkWithParams:params
                        completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            err = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];
        return err;
    }

private:
    chip::ByteSpan mNetworkID;
    uint8_t mNetworkIndex;
    uint64_t mBreadcrumb;
};

/*
 * Command ScanNetworks
 */
class NetworkCommissioningScanNetworks : public ModelCommand {
public:
    NetworkCommissioningScanNetworks()
        : ModelCommand("scan-networks")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPNetworkCommissioningClusterScanNetworksParams alloc] init];
        params.ssid = [[NSData alloc] initWithBytes:mSsid.data() length:mSsid.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster scanNetworksWithParams:params
                      completionHandler:^(
                          CHIPNetworkCommissioningClusterScanNetworksResponseParams * _Nullable values, NSError * _Nullable error) {
                          NSLog(@"Values: %@", values);
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    chip::ByteSpan mSsid;
    uint64_t mBreadcrumb;
};

/*
 * Attribute MaxNetworks
 */
class ReadNetworkCommissioningMaxNetworks : public ModelCommand {
public:
    ReadNetworkCommissioningMaxNetworks()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-networks");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningMaxNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxNetworksWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.MaxNetworks response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning MaxNetworks Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningMaxNetworks : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningMaxNetworks()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-networks");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningMaxNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxNetworksWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"NetworkCommissioning.MaxNetworks response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Networks
 */
class ReadNetworkCommissioningNetworks : public ModelCommand {
public:
    ReadNetworkCommissioningNetworks()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "networks");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNetworksWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.Networks response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning Networks Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningNetworks : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningNetworks()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "networks");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNetworksWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"NetworkCommissioning.Networks response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ScanMaxTimeSeconds
 */
class ReadNetworkCommissioningScanMaxTimeSeconds : public ModelCommand {
public:
    ReadNetworkCommissioningScanMaxTimeSeconds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scan-max-time-seconds");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningScanMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeScanMaxTimeSecondsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ScanMaxTimeSeconds response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ScanMaxTimeSeconds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningScanMaxTimeSeconds : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningScanMaxTimeSeconds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scan-max-time-seconds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningScanMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeScanMaxTimeSecondsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"NetworkCommissioning.ScanMaxTimeSeconds response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ConnectMaxTimeSeconds
 */
class ReadNetworkCommissioningConnectMaxTimeSeconds : public ModelCommand {
public:
    ReadNetworkCommissioningConnectMaxTimeSeconds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "connect-max-time-seconds");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningConnectMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeConnectMaxTimeSecondsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ConnectMaxTimeSeconds response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ConnectMaxTimeSeconds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningConnectMaxTimeSeconds : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningConnectMaxTimeSeconds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "connect-max-time-seconds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningConnectMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeConnectMaxTimeSecondsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"NetworkCommissioning.ConnectMaxTimeSeconds response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InterfaceEnabled
 */
class ReadNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    ReadNetworkCommissioningInterfaceEnabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "interface-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInterfaceEnabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.InterfaceEnabled response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning InterfaceEnabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    WriteNetworkCommissioningInterfaceEnabled()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "interface-enabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) WriteAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeInterfaceEnabledWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           err = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogError(
                                               chipTool, "NetworkCommissioning InterfaceEnabled Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningInterfaceEnabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "interface-enabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInterfaceEnabledWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"NetworkCommissioning.InterfaceEnabled response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastNetworkingStatus
 */
class ReadNetworkCommissioningLastNetworkingStatus : public ModelCommand {
public:
    ReadNetworkCommissioningLastNetworkingStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-networking-status");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastNetworkingStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLastNetworkingStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastNetworkingStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastNetworkingStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningLastNetworkingStatus : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningLastNetworkingStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-networking-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningLastNetworkingStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLastNetworkingStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"NetworkCommissioning.LastNetworkingStatus response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastNetworkID
 */
class ReadNetworkCommissioningLastNetworkID : public ModelCommand {
public:
    ReadNetworkCommissioningLastNetworkID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-network-id");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastNetworkID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLastNetworkIDWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastNetworkID response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastNetworkID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningLastNetworkID : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningLastNetworkID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-network-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningLastNetworkID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLastNetworkIDWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"NetworkCommissioning.LastNetworkID response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastConnectErrorValue
 */
class ReadNetworkCommissioningLastConnectErrorValue : public ModelCommand {
public:
    ReadNetworkCommissioningLastConnectErrorValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-connect-error-value");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastConnectErrorValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLastConnectErrorValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastConnectErrorValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastConnectErrorValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningLastConnectErrorValue : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningLastConnectErrorValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-connect-error-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningLastConnectErrorValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLastConnectErrorValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"NetworkCommissioning.LastConnectErrorValue response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadNetworkCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReadNetworkCommissioningServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"NetworkCommissioning.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "NetworkCommissioning ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"NetworkCommissioning.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadNetworkCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReadNetworkCommissioningClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"NetworkCommissioning.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "NetworkCommissioning ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"NetworkCommissioning.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadNetworkCommissioningFeatureMap : public ModelCommand {
public:
    ReadNetworkCommissioningFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningFeatureMap : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"NetworkCommissioning.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadNetworkCommissioningClusterRevision : public ModelCommand {
public:
    ReadNetworkCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeNetworkCommissioningClusterRevision : public ModelCommand {
public:
    SubscribeAttributeNetworkCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeNetworkCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"NetworkCommissioning.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateProvider                                   | 0x0029 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * QueryImage                                                        |   0x00 |
| * ApplyUpdateRequest                                                |   0x02 |
| * NotifyUpdateApplied                                               |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ApplyUpdateRequest
 */
class OtaSoftwareUpdateProviderApplyUpdateRequest : public ModelCommand {
public:
    OtaSoftwareUpdateProviderApplyUpdateRequest()
        : ModelCommand("apply-update-request")
    {
        AddArgument("NewVersion", 0, UINT32_MAX, &mNewVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestParams alloc] init];
        params.updateToken = [[NSData alloc] initWithBytes:mUpdateToken.data() length:mUpdateToken.size()];
        params.newVersion = [NSNumber numberWithUnsignedInt:mNewVersion];
        [cluster applyUpdateRequestWithParams:params
                            completionHandler:^(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    chip::ByteSpan mUpdateToken;
    uint32_t mNewVersion;
};

/*
 * Command NotifyUpdateApplied
 */
class OtaSoftwareUpdateProviderNotifyUpdateApplied : public ModelCommand {
public:
    OtaSoftwareUpdateProviderNotifyUpdateApplied()
        : ModelCommand("notify-update-applied")
    {
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mSoftwareVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterNotifyUpdateAppliedParams alloc] init];
        params.updateToken = [[NSData alloc] initWithBytes:mUpdateToken.data() length:mUpdateToken.size()];
        params.softwareVersion = [NSNumber numberWithUnsignedInt:mSoftwareVersion];
        [cluster notifyUpdateAppliedWithParams:params
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    chip::ByteSpan mUpdateToken;
    uint32_t mSoftwareVersion;
};

/*
 * Command QueryImage
 */
class OtaSoftwareUpdateProviderQueryImage : public ModelCommand {
public:
    OtaSoftwareUpdateProviderQueryImage()
        : ModelCommand("query-image")
    {
        AddArgument("VendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("ProductId", 0, UINT16_MAX, &mProductId);
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mSoftwareVersion);
        AddArgument("HardwareVersion", 0, UINT16_MAX, &mHardwareVersion);
        AddArgument("Location", &mLocation);
        AddArgument("RequestorCanConsent", 0, 1, &mRequestorCanConsent);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterQueryImageParams alloc] init];
        params.vendorId = [NSNumber numberWithUnsignedShort:mVendorId];
        params.productId = [NSNumber numberWithUnsignedShort:mProductId];
        params.softwareVersion = [NSNumber numberWithUnsignedInt:mSoftwareVersion];
        // protocolsSupported Array parsing is not supported yet
        params.hardwareVersion = [NSNumber numberWithUnsignedShort:mHardwareVersion];
        params.location = [[NSString alloc] initWithBytes:mLocation.data() length:mLocation.size() encoding:NSUTF8StringEncoding];
        params.requestorCanConsent = [NSNumber numberWithBool:mRequestorCanConsent];
        params.metadataForProvider = [[NSData alloc] initWithBytes:mMetadataForProvider.data() length:mMetadataForProvider.size()];
        [cluster queryImageWithParams:params
                    completionHandler:^(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseParams * _Nullable values,
                        NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        err = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];
        return err;
    }

private:
    chip::VendorId mVendorId;
    uint16_t mProductId;
    uint32_t mSoftwareVersion;
    uint16_t mHardwareVersion;
    chip::ByteSpan mLocation;
    bool mRequestorCanConsent;
    chip::ByteSpan mMetadataForProvider;
};

/*
 * Attribute AttributeList
 */
class ReadOtaSoftwareUpdateProviderAttributeList : public ModelCommand {
public:
    ReadOtaSoftwareUpdateProviderAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateProvider.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateProvider AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateProviderAttributeList : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateProviderAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateProviderAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"OtaSoftwareUpdateProvider.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateProviderClusterRevision : public ModelCommand {
public:
    ReadOtaSoftwareUpdateProviderClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateProvider.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateProvider ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateProviderClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateProviderClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateProviderClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OtaSoftwareUpdateProvider.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateRequestor                                  | 0x002A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AnnounceOtaProvider                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DefaultOtaProviders                                               | 0x0000 |
| * UpdatePossible                                                    | 0x0001 |
| * UpdateState                                                       | 0x0002 |
| * UpdateStateProgress                                               | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateTransition                                                   | 0x0000 |
| * VersionApplied                                                    | 0x0001 |
| * DownloadError                                                     | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command AnnounceOtaProvider
 */
class OtaSoftwareUpdateRequestorAnnounceOtaProvider : public ModelCommand {
public:
    OtaSoftwareUpdateRequestorAnnounceOtaProvider()
        : ModelCommand("announce-ota-provider")
    {
        AddArgument("ProviderNodeId", 0, UINT64_MAX, &mProviderNodeId);
        AddArgument("VendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("AnnouncementReason", 0, UINT8_MAX, &mAnnouncementReason);
        AddArgument("Endpoint", 0, UINT16_MAX, &mEndpoint);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOtaSoftwareUpdateRequestorClusterAnnounceOtaProviderParams alloc] init];
        params.providerNodeId = [NSNumber numberWithUnsignedLongLong:mProviderNodeId];
        params.vendorId = [NSNumber numberWithUnsignedShort:mVendorId];
        params.announcementReason = [NSNumber numberWithUnsignedChar:mAnnouncementReason];
        params.metadataForNode = [[NSData alloc] initWithBytes:mMetadataForNode.data() length:mMetadataForNode.size()];
        params.endpoint = [NSNumber numberWithUnsignedShort:mEndpoint];
        [cluster announceOtaProviderWithParams:params
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    chip::NodeId mProviderNodeId;
    chip::VendorId mVendorId;
    uint8_t mAnnouncementReason;
    chip::ByteSpan mMetadataForNode;
    chip::EndpointId mEndpoint;
};

/*
 * Attribute DefaultOtaProviders
 */
class ReadOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorDefaultOtaProviders()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "default-ota-providers");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster
            readAttributeDefaultOtaProvidersWithParams:params
                                     completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                         NSLog(@"OtaSoftwareUpdateRequestor.DefaultOtaProviders response %@", [value description]);
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "OtaSoftwareUpdateRequestor DefaultOtaProviders Error: %s",
                                             chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorDefaultOtaProviders()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "default-ota-providers");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDefaultOtaProvidersWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OtaSoftwareUpdateRequestor.DefaultOtaProviders response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdatePossible
 */
class ReadOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdatePossible()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-possible");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdatePossible() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUpdatePossibleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdatePossible response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdatePossible Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorUpdatePossible()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-possible");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorUpdatePossible() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUpdatePossibleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"OtaSoftwareUpdateRequestor.UpdatePossible response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdateState
 */
class ReadOtaSoftwareUpdateRequestorUpdateState : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdateState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-state");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdateState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUpdateStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdateState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdateState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorUpdateState : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorUpdateState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorUpdateState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeUpdateStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"OtaSoftwareUpdateRequestor.UpdateState response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdateStateProgress
 */
class ReadOtaSoftwareUpdateRequestorUpdateStateProgress : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdateStateProgress()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-state-progress");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdateStateProgress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUpdateStateProgressWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdateStateProgress response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdateStateProgress Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorUpdateStateProgress : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorUpdateStateProgress()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-state-progress");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorUpdateStateProgress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUpdateStateProgressWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OtaSoftwareUpdateRequestor.UpdateStateProgress response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOtaSoftwareUpdateRequestorAttributeList : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorAttributeList : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"OtaSoftwareUpdateRequestor.AttributeList response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOtaSoftwareUpdateRequestorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOtaSoftwareUpdateRequestorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OtaSoftwareUpdateRequestor.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OccupancySensing                                            | 0x0406 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Occupancy                                                         | 0x0000 |
| * OccupancySensorType                                               | 0x0001 |
| * OccupancySensorTypeBitmap                                         | 0x0002 |
| * PirOccupiedToUnoccupiedDelay                                      | 0x0010 |
| * PirUnoccupiedToOccupiedDelay                                      | 0x0011 |
| * PirUnoccupiedToOccupiedThreshold                                  | 0x0012 |
| * UltrasonicOccupiedToUnoccupiedDelay                               | 0x0020 |
| * UltrasonicUnoccupiedToOccupiedDelay                               | 0x0021 |
| * UltrasonicUnoccupiedToOccupiedThreshold                           | 0x0022 |
| * PhysicalContactOccupiedToUnoccupiedDelay                          | 0x0030 |
| * PhysicalContactUnoccupiedToOccupiedDelay                          | 0x0031 |
| * PhysicalContactUnoccupiedToOccupiedThreshold                      | 0x0032 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Occupancy
 */
class ReadOccupancySensingOccupancy : public ModelCommand {
public:
    ReadOccupancySensingOccupancy()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOccupancyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.Occupancy response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing Occupancy Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingOccupancy : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingOccupancy()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingOccupancy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOccupancyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"OccupancySensing.Occupancy response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorType
 */
class ReadOccupancySensingOccupancySensorType : public ModelCommand {
public:
    ReadOccupancySensingOccupancySensorType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOccupancySensorTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.OccupancySensorType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing OccupancySensorType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingOccupancySensorType : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingOccupancySensorType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingOccupancySensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOccupancySensorTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OccupancySensing.OccupancySensorType response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorTypeBitmap
 */
class ReadOccupancySensingOccupancySensorTypeBitmap : public ModelCommand {
public:
    ReadOccupancySensingOccupancySensorTypeBitmap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorTypeBitmap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeOccupancySensorTypeBitmapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OccupancySensing.OccupancySensorTypeBitmap response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OccupancySensing OccupancySensorTypeBitmap Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingOccupancySensorTypeBitmap : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingOccupancySensorTypeBitmap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingOccupancySensorTypeBitmap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOccupancySensorTypeBitmapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"OccupancySensing.OccupancySensorTypeBitmap response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadOccupancySensingServerGeneratedCommandList : public ModelCommand {
public:
    ReadOccupancySensingServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OccupancySensing.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OccupancySensing ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"OccupancySensing.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadOccupancySensingClientGeneratedCommandList : public ModelCommand {
public:
    ReadOccupancySensingClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OccupancySensing.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OccupancySensing ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"OccupancySensing.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOccupancySensingAttributeList : public ModelCommand {
public:
    ReadOccupancySensingAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingAttributeList : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"OccupancySensing.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOccupancySensingClusterRevision : public ModelCommand {
public:
    ReadOccupancySensingClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOccupancySensingClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOccupancySensingClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOccupancySensingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OccupancySensing.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOff                                                       | 0x0006 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Off                                                               |   0x00 |
| * On                                                                |   0x01 |
| * Toggle                                                            |   0x02 |
| * OffWithEffect                                                     |   0x40 |
| * OnWithRecallGlobalScene                                           |   0x41 |
| * OnWithTimedOff                                                    |   0x42 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OnOff                                                             | 0x0000 |
| * GlobalSceneControl                                                | 0x4000 |
| * OnTime                                                            | 0x4001 |
| * OffWaitTime                                                       | 0x4002 |
| * StartUpOnOff                                                      | 0x4003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Off
 */
class OnOffOff : public ModelCommand {
public:
    OnOffOff()
        : ModelCommand("off")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster offWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command OffWithEffect
 */
class OnOffOffWithEffect : public ModelCommand {
public:
    OnOffOffWithEffect()
        : ModelCommand("off-with-effect")
    {
        AddArgument("EffectId", 0, UINT8_MAX, &mEffectId);
        AddArgument("EffectVariant", 0, UINT8_MAX, &mEffectVariant);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000040) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOnOffClusterOffWithEffectParams alloc] init];
        params.effectId = [NSNumber numberWithUnsignedChar:mEffectId];
        params.effectVariant = [NSNumber numberWithUnsignedChar:mEffectVariant];
        [cluster offWithEffectWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint8_t mEffectId;
    uint8_t mEffectVariant;
};

/*
 * Command On
 */
class OnOffOn : public ModelCommand {
public:
    OnOffOn()
        : ModelCommand("on")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster onWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command OnWithRecallGlobalScene
 */
class OnOffOnWithRecallGlobalScene : public ModelCommand {
public:
    OnOffOnWithRecallGlobalScene()
        : ModelCommand("on-with-recall-global-scene")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000041) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster onWithRecallGlobalSceneWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command OnWithTimedOff
 */
class OnOffOnWithTimedOff : public ModelCommand {
public:
    OnOffOnWithTimedOff()
        : ModelCommand("on-with-timed-off")
    {
        AddArgument("OnOffControl", 0, UINT8_MAX, &mOnOffControl);
        AddArgument("OnTime", 0, UINT16_MAX, &mOnTime);
        AddArgument("OffWaitTime", 0, UINT16_MAX, &mOffWaitTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000042) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOnOffClusterOnWithTimedOffParams alloc] init];
        params.onOffControl = [NSNumber numberWithUnsignedChar:mOnOffControl];
        params.onTime = [NSNumber numberWithUnsignedShort:mOnTime];
        params.offWaitTime = [NSNumber numberWithUnsignedShort:mOffWaitTime];
        [cluster onWithTimedOffWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            err = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];
        return err;
    }

private:
    uint8_t mOnOffControl;
    uint16_t mOnTime;
    uint16_t mOffWaitTime;
};

/*
 * Command Toggle
 */
class OnOffToggle : public ModelCommand {
public:
    OnOffToggle()
        : ModelCommand("toggle")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster toggleWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute OnOff
 */
class ReadOnOffOnOff : public ModelCommand {
public:
    ReadOnOffOnOff()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OnOff response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OnOff Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffOnOff : public ModelCommand {
public:
    SubscribeAttributeOnOffOnOff()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnOffWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"OnOff.OnOff response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GlobalSceneControl
 */
class ReadOnOffGlobalSceneControl : public ModelCommand {
public:
    ReadOnOffGlobalSceneControl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "global-scene-control");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffGlobalSceneControl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGlobalSceneControlWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.GlobalSceneControl response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff GlobalSceneControl Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffGlobalSceneControl : public ModelCommand {
public:
    SubscribeAttributeOnOffGlobalSceneControl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "global-scene-control");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffGlobalSceneControl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeGlobalSceneControlWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"OnOff.GlobalSceneControl response %@", [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTime
 */
class ReadOnOffOnTime : public ModelCommand {
public:
    ReadOnOffOnTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OnTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OnTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteOnOffOnTime : public ModelCommand {
public:
    WriteOnOffOnTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeOnTimeWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "OnOff OnTime Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeOnOffOnTime : public ModelCommand {
public:
    SubscribeAttributeOnOffOnTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOnTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"OnOff.OnTime response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffWaitTime
 */
class ReadOnOffOffWaitTime : public ModelCommand {
public:
    ReadOnOffOffWaitTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "off-wait-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OffWaitTime response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OffWaitTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteOnOffOffWaitTime : public ModelCommand {
public:
    WriteOnOffOffWaitTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeOffWaitTimeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "OnOff OffWaitTime Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeOnOffOffWaitTime : public ModelCommand {
public:
    SubscribeAttributeOnOffOffWaitTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOffWaitTimeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"OnOff.OffWaitTime response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpOnOff
 */
class ReadOnOffStartUpOnOff : public ModelCommand {
public:
    ReadOnOffStartUpOnOff()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartUpOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.StartUpOnOff response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff StartUpOnOff Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteOnOffStartUpOnOff : public ModelCommand {
public:
    WriteOnOffStartUpOnOff()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeStartUpOnOffWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogError(chipTool, "OnOff StartUpOnOff Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeOnOffStartUpOnOff : public ModelCommand {
public:
    SubscribeAttributeOnOffStartUpOnOff()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStartUpOnOffWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"OnOff.StartUpOnOff response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadOnOffServerGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OnOff.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OnOff ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOnOffServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOnOffServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"OnOff.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadOnOffClientGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OnOff.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OnOff ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOnOffClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOnOffClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"OnOff.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOnOffAttributeList : public ModelCommand {
public:
    ReadOnOffAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffAttributeList : public ModelCommand {
public:
    SubscribeAttributeOnOffAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"OnOff.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadOnOffFeatureMap : public ModelCommand {
public:
    ReadOnOffFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffFeatureMap : public ModelCommand {
public:
    SubscribeAttributeOnOffFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"OnOff.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffClusterRevision : public ModelCommand {
public:
    ReadOnOffClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOnOffClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OnOff.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOffSwitchConfiguration                                    | 0x0007 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SwitchType                                                        | 0x0000 |
| * SwitchActions                                                     | 0x0010 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute SwitchType
 */
class ReadOnOffSwitchConfigurationSwitchType : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationSwitchType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-type");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSwitchTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.SwitchType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationSwitchType : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationSwitchType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "switch-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationSwitchType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSwitchTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"OnOffSwitchConfiguration.SwitchType response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SwitchActions
 */
class ReadOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-actions");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSwitchActionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.SwitchActions response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchActions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    WriteOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) WriteAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeSwitchActionsWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchActions Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeSwitchActionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"OnOffSwitchConfiguration.SwitchActions response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadOnOffSwitchConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OnOffSwitchConfiguration.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OnOffSwitchConfiguration ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"OnOffSwitchConfiguration.ServerGeneratedCommandList response "
                                                                    @"%@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadOnOffSwitchConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OnOffSwitchConfiguration.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OnOffSwitchConfiguration ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"OnOffSwitchConfiguration.ClientGeneratedCommandList response "
                                                                    @"%@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOnOffSwitchConfigurationAttributeList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationAttributeList : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"OnOffSwitchConfiguration.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffSwitchConfigurationClusterRevision : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOnOffSwitchConfigurationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOnOffSwitchConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOnOffSwitchConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OnOffSwitchConfiguration.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OperationalCredentials                                      | 0x003E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AttestationRequest                                                |   0x00 |
| * CertificateChainRequest                                           |   0x02 |
| * CSRRequest                                                        |   0x04 |
| * AddNOC                                                            |   0x06 |
| * UpdateNOC                                                         |   0x07 |
| * UpdateFabricLabel                                                 |   0x09 |
| * RemoveFabric                                                      |   0x0A |
| * AddTrustedRootCertificate                                         |   0x0B |
| * RemoveTrustedRootCertificate                                      |   0x0C |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NOCs                                                              | 0x0000 |
| * Fabrics                                                           | 0x0001 |
| * SupportedFabrics                                                  | 0x0002 |
| * CommissionedFabrics                                               | 0x0003 |
| * TrustedRootCertificates                                           | 0x0004 |
| * CurrentFabricIndex                                                | 0x0005 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddNOC
 */
class OperationalCredentialsAddNOC : public ModelCommand {
public:
    OperationalCredentialsAddNOC()
        : ModelCommand("add-noc")
    {
        AddArgument("CaseAdminNode", 0, UINT64_MAX, &mCaseAdminNode);
        AddArgument("AdminVendorId", 0, UINT16_MAX, &mAdminVendorId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterAddNOCParams alloc] init];
        params.nocValue = [[NSData alloc] initWithBytes:mNOCValue.data() length:mNOCValue.size()];
        params.icacValue = [[NSData alloc] initWithBytes:mICACValue.data() length:mICACValue.size()];
        params.ipkValue = [[NSData alloc] initWithBytes:mIPKValue.data() length:mIPKValue.size()];
        params.caseAdminNode = [NSNumber numberWithUnsignedLongLong:mCaseAdminNode];
        params.adminVendorId = [NSNumber numberWithUnsignedShort:mAdminVendorId];
        [cluster
             addNOCWithParams:params
            completionHandler:^(CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                NSLog(@"Values: %@", values);
                err = [CHIPError errorToCHIPErrorCode:error];
                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }

private:
    chip::ByteSpan mNOCValue;
    chip::ByteSpan mICACValue;
    chip::ByteSpan mIPKValue;
    chip::NodeId mCaseAdminNode;
    uint16_t mAdminVendorId;
};

/*
 * Command AddTrustedRootCertificate
 */
class OperationalCredentialsAddTrustedRootCertificate : public ModelCommand {
public:
    OperationalCredentialsAddTrustedRootCertificate()
        : ModelCommand("add-trusted-root-certificate")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterAddTrustedRootCertificateParams alloc] init];
        params.rootCertificate = [[NSData alloc] initWithBytes:mRootCertificate.data() length:mRootCertificate.size()];
        [cluster addTrustedRootCertificateWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
    chip::ByteSpan mRootCertificate;
};

/*
 * Command AttestationRequest
 */
class OperationalCredentialsAttestationRequest : public ModelCommand {
public:
    OperationalCredentialsAttestationRequest()
        : ModelCommand("attestation-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterAttestationRequestParams alloc] init];
        params.attestationNonce = [[NSData alloc] initWithBytes:mAttestationNonce.data() length:mAttestationNonce.size()];
        [cluster attestationRequestWithParams:params
                            completionHandler:^(CHIPOperationalCredentialsClusterAttestationResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    chip::ByteSpan mAttestationNonce;
};

/*
 * Command CSRRequest
 */
class OperationalCredentialsCSRRequest : public ModelCommand {
public:
    OperationalCredentialsCSRRequest()
        : ModelCommand("csrrequest")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterCSRRequestParams alloc] init];
        params.csrNonce = [[NSData alloc] initWithBytes:mCSRNonce.data() length:mCSRNonce.size()];
        [cluster CSRRequestWithParams:params
                    completionHandler:^(
                        CHIPOperationalCredentialsClusterCSRResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        err = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];
        return err;
    }

private:
    chip::ByteSpan mCSRNonce;
};

/*
 * Command CertificateChainRequest
 */
class OperationalCredentialsCertificateChainRequest : public ModelCommand {
public:
    OperationalCredentialsCertificateChainRequest()
        : ModelCommand("certificate-chain-request")
    {
        AddArgument("CertificateType", 0, UINT8_MAX, &mCertificateType);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterCertificateChainRequestParams alloc] init];
        params.certificateType = [NSNumber numberWithUnsignedChar:mCertificateType];
        [cluster
            certificateChainRequestWithParams:params
                            completionHandler:^(CHIPOperationalCredentialsClusterCertificateChainResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint8_t mCertificateType;
};

/*
 * Command RemoveFabric
 */
class OperationalCredentialsRemoveFabric : public ModelCommand {
public:
    OperationalCredentialsRemoveFabric()
        : ModelCommand("remove-fabric")
    {
        AddArgument("FabricIndex", 0, UINT8_MAX, &mFabricIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterRemoveFabricParams alloc] init];
        params.fabricIndex = [NSNumber numberWithUnsignedChar:mFabricIndex];
        [cluster removeFabricWithParams:params
                      completionHandler:^(
                          CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                          NSLog(@"Values: %@", values);
                          err = [CHIPError errorToCHIPErrorCode:error];
                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];
        return err;
    }

private:
    chip::FabricIndex mFabricIndex;
};

/*
 * Command RemoveTrustedRootCertificate
 */
class OperationalCredentialsRemoveTrustedRootCertificate : public ModelCommand {
public:
    OperationalCredentialsRemoveTrustedRootCertificate()
        : ModelCommand("remove-trusted-root-certificate")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterRemoveTrustedRootCertificateParams alloc] init];
        params.trustedRootIdentifier = [[NSData alloc] initWithBytes:mTrustedRootIdentifier.data()
                                                              length:mTrustedRootIdentifier.size()];
        [cluster removeTrustedRootCertificateWithParams:params
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    chip::ByteSpan mTrustedRootIdentifier;
};

/*
 * Command UpdateFabricLabel
 */
class OperationalCredentialsUpdateFabricLabel : public ModelCommand {
public:
    OperationalCredentialsUpdateFabricLabel()
        : ModelCommand("update-fabric-label")
    {
        AddArgument("Label", &mLabel);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterUpdateFabricLabelParams alloc] init];
        params.label = [[NSString alloc] initWithBytes:mLabel.data() length:mLabel.size() encoding:NSUTF8StringEncoding];
        [cluster updateFabricLabelWithParams:params
                           completionHandler:^(
                               CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                               NSLog(@"Values: %@", values);
                               err = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return err;
    }

private:
    chip::ByteSpan mLabel;
};

/*
 * Command UpdateNOC
 */
class OperationalCredentialsUpdateNOC : public ModelCommand {
public:
    OperationalCredentialsUpdateNOC()
        : ModelCommand("update-noc")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPOperationalCredentialsClusterUpdateNOCParams alloc] init];
        params.nocValue = [[NSData alloc] initWithBytes:mNOCValue.data() length:mNOCValue.size()];
        params.icacValue = [[NSData alloc] initWithBytes:mICACValue.data() length:mICACValue.size()];
        [cluster updateNOCWithParams:params
                   completionHandler:^(
                       CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       err = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];
        return err;
    }

private:
    chip::ByteSpan mNOCValue;
    chip::ByteSpan mICACValue;
};

/*
 * Attribute NOCs
 */
class ReadOperationalCredentialsNOCs : public ModelCommand {
public:
    ReadOperationalCredentialsNOCs()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nocs");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsNOCs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeNOCsWithParams:params
                           completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                               NSLog(@"OperationalCredentials.NOCs response %@", [value description]);
                               err = [CHIPError errorToCHIPErrorCode:error];

                               ChipLogError(chipTool, "OperationalCredentials NOCs Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsNOCs : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsNOCs()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nocs");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsNOCs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNOCsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                params:params
                               subscriptionEstablished:NULL
                                         reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                             NSLog(@"OperationalCredentials.NOCs response %@", [value description]);
                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Fabrics
 */
class ReadOperationalCredentialsFabrics : public ModelCommand {
public:
    ReadOperationalCredentialsFabrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        CHIPReadParams * params = [[CHIPReadParams alloc] init];
        [cluster readAttributeFabricsWithParams:params
                              completionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                  NSLog(@"OperationalCredentials.Fabrics response %@", [value description]);
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "OperationalCredentials Fabrics Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsFabrics : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsFabrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFabricsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"OperationalCredentials.Fabrics response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedFabrics
 */
class ReadOperationalCredentialsSupportedFabrics : public ModelCommand {
public:
    ReadOperationalCredentialsSupportedFabrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsSupportedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportedFabricsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.SupportedFabrics response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials SupportedFabrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsSupportedFabrics : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsSupportedFabrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsSupportedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedFabricsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"OperationalCredentials.SupportedFabrics response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CommissionedFabrics
 */
class ReadOperationalCredentialsCommissionedFabrics : public ModelCommand {
public:
    ReadOperationalCredentialsCommissionedFabrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCommissionedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCommissionedFabricsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.CommissionedFabrics response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials CommissionedFabrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsCommissionedFabrics : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsCommissionedFabrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsCommissionedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCommissionedFabricsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"OperationalCredentials.CommissionedFabrics response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TrustedRootCertificates
 */
class ReadOperationalCredentialsTrustedRootCertificates : public ModelCommand {
public:
    ReadOperationalCredentialsTrustedRootCertificates()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsTrustedRootCertificates() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTrustedRootCertificatesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.TrustedRootCertificates response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials TrustedRootCertificates Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsTrustedRootCertificates : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsTrustedRootCertificates()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsTrustedRootCertificates() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTrustedRootCertificatesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"OperationalCredentials.TrustedRootCertificates response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFabricIndex
 */
class ReadOperationalCredentialsCurrentFabricIndex : public ModelCommand {
public:
    ReadOperationalCredentialsCurrentFabricIndex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCurrentFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentFabricIndexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.CurrentFabricIndex response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials CurrentFabricIndex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsCurrentFabricIndex : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsCurrentFabricIndex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-fabric-index");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsCurrentFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentFabricIndexWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"OperationalCredentials.CurrentFabricIndex response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadOperationalCredentialsServerGeneratedCommandList : public ModelCommand {
public:
    ReadOperationalCredentialsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OperationalCredentials.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OperationalCredentials ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(
                                                                  @"OperationalCredentials.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadOperationalCredentialsClientGeneratedCommandList : public ModelCommand {
public:
    ReadOperationalCredentialsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OperationalCredentials.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OperationalCredentials ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(
                                                                  @"OperationalCredentials.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOperationalCredentialsAttributeList : public ModelCommand {
public:
    ReadOperationalCredentialsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsAttributeList : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"OperationalCredentials.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOperationalCredentialsClusterRevision : public ModelCommand {
public:
    ReadOperationalCredentialsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeOperationalCredentialsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeOperationalCredentialsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeOperationalCredentialsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"OperationalCredentials.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSource                                                 | 0x002F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Status                                                            | 0x0000 |
| * Order                                                             | 0x0001 |
| * Description                                                       | 0x0002 |
| * WiredAssessedInputVoltage                                         | 0x0003 |
| * WiredAssessedInputFrequency                                       | 0x0004 |
| * WiredCurrentType                                                  | 0x0005 |
| * WiredAssessedCurrent                                              | 0x0006 |
| * WiredNominalVoltage                                               | 0x0007 |
| * WiredMaximumCurrent                                               | 0x0008 |
| * WiredPresent                                                      | 0x0009 |
| * ActiveWiredFaults                                                 | 0x000A |
| * BatteryVoltage                                                    | 0x000B |
| * BatteryPercentRemaining                                           | 0x000C |
| * BatteryTimeRemaining                                              | 0x000D |
| * BatteryChargeLevel                                                | 0x000E |
| * BatteryReplacementNeeded                                          | 0x000F |
| * BatteryReplaceability                                             | 0x0010 |
| * BatteryPresent                                                    | 0x0011 |
| * ActiveBatteryFaults                                               | 0x0012 |
| * BatteryReplacementDescription                                     | 0x0013 |
| * BatteryCommonDesignation                                          | 0x0014 |
| * BatteryANSIDesignation                                            | 0x0015 |
| * BatteryIECDesignation                                             | 0x0016 |
| * BatteryApprovedChemistry                                          | 0x0017 |
| * BatteryCapacity                                                   | 0x0018 |
| * BatteryQuantity                                                   | 0x0019 |
| * BatteryChargeState                                                | 0x001A |
| * BatteryTimeToFullCharge                                           | 0x001B |
| * BatteryFunctionalWhileCharging                                    | 0x001C |
| * BatteryChargingCurrent                                            | 0x001D |
| * ActiveBatteryChargeFaults                                         | 0x001E |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Status
 */
class ReadPowerSourceStatus : public ModelCommand {
public:
    ReadPowerSourceStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "status");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Status response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Status Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceStatus : public ModelCommand {
public:
    SubscribeAttributePowerSourceStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"PowerSource.Status response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Order
 */
class ReadPowerSourceOrder : public ModelCommand {
public:
    ReadPowerSourceOrder()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "order");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceOrder() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOrderWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Order response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Order Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceOrder : public ModelCommand {
public:
    SubscribeAttributePowerSourceOrder()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "order");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceOrder() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOrderWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PowerSource.Order response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadPowerSourceDescription : public ModelCommand {
public:
    ReadPowerSourceDescription()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDescriptionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Description response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Description Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceDescription : public ModelCommand {
public:
    SubscribeAttributePowerSourceDescription()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDescriptionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"PowerSource.Description response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryVoltage
 */
class ReadPowerSourceBatteryVoltage : public ModelCommand {
public:
    ReadPowerSourceBatteryVoltage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBatteryVoltageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryVoltage response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryVoltage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryVoltage : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryVoltage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBatteryVoltageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"PowerSource.BatteryVoltage response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryPercentRemaining
 */
class ReadPowerSourceBatteryPercentRemaining : public ModelCommand {
public:
    ReadPowerSourceBatteryPercentRemaining()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryPercentRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeBatteryPercentRemainingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSource.BatteryPercentRemaining response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSource BatteryPercentRemaining Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryPercentRemaining : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryPercentRemaining()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryPercentRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBatteryPercentRemainingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"PowerSource.BatteryPercentRemaining response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryTimeRemaining
 */
class ReadPowerSourceBatteryTimeRemaining : public ModelCommand {
public:
    ReadPowerSourceBatteryTimeRemaining()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-time-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryTimeRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBatteryTimeRemainingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryTimeRemaining response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryTimeRemaining Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryTimeRemaining : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryTimeRemaining()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-time-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryTimeRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBatteryTimeRemainingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PowerSource.BatteryTimeRemaining response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeLevel
 */
class ReadPowerSourceBatteryChargeLevel : public ModelCommand {
public:
    ReadPowerSourceBatteryChargeLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-level");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBatteryChargeLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryChargeLevel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryChargeLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryChargeLevel : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryChargeLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-charge-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryChargeLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBatteryChargeLevelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PowerSource.BatteryChargeLevel response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveBatteryFaults
 */
class ReadPowerSourceActiveBatteryFaults : public ModelCommand {
public:
    ReadPowerSourceActiveBatteryFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-battery-faults");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceActiveBatteryFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveBatteryFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.ActiveBatteryFaults response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource ActiveBatteryFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceActiveBatteryFaults : public ModelCommand {
public:
    SubscribeAttributePowerSourceActiveBatteryFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-battery-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceActiveBatteryFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActiveBatteryFaultsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"PowerSource.ActiveBatteryFaults response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeState
 */
class ReadPowerSourceBatteryChargeState : public ModelCommand {
public:
    ReadPowerSourceBatteryChargeState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-state");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBatteryChargeStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryChargeState response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryChargeState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceBatteryChargeState : public ModelCommand {
public:
    SubscribeAttributePowerSourceBatteryChargeState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-charge-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceBatteryChargeState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBatteryChargeStateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PowerSource.BatteryChargeState response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadPowerSourceServerGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSource.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSource ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributePowerSourceServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePowerSourceServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"PowerSource.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadPowerSourceClientGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSource.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSource ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributePowerSourceClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePowerSourceClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"PowerSource.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPowerSourceAttributeList : public ModelCommand {
public:
    ReadPowerSourceAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceAttributeList : public ModelCommand {
public:
    SubscribeAttributePowerSourceAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PowerSource.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadPowerSourceFeatureMap : public ModelCommand {
public:
    ReadPowerSourceFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceFeatureMap : public ModelCommand {
public:
    SubscribeAttributePowerSourceFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"PowerSource.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceClusterRevision : public ModelCommand {
public:
    ReadPowerSourceClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceClusterRevision : public ModelCommand {
public:
    SubscribeAttributePowerSourceClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PowerSource.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSourceConfiguration                                    | 0x002E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Sources                                                           | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Sources
 */
class ReadPowerSourceConfigurationSources : public ModelCommand {
public:
    ReadPowerSourceConfigurationSources()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "sources");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationSources() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSourcesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.Sources response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration Sources Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationSources : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationSources()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "sources");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationSources() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSourcesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PowerSourceConfiguration.Sources response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadPowerSourceConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceConfigurationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSourceConfiguration.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSourceConfiguration ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"PowerSourceConfiguration.ServerGeneratedCommandList response "
                                                                    @"%@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadPowerSourceConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceConfigurationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSourceConfiguration.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSourceConfiguration ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"PowerSourceConfiguration.ClientGeneratedCommandList response "
                                                                    @"%@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPowerSourceConfigurationAttributeList : public ModelCommand {
public:
    ReadPowerSourceConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationAttributeList : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"PowerSourceConfiguration.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceConfigurationClusterRevision : public ModelCommand {
public:
    ReadPowerSourceConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePowerSourceConfigurationClusterRevision : public ModelCommand {
public:
    SubscribeAttributePowerSourceConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePowerSourceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PowerSourceConfiguration.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PressureMeasurement                                         | 0x0403 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ScaledValue                                                       | 0x0010 |
| * MinScaledValue                                                    | 0x0011 |
| * MaxScaledValue                                                    | 0x0012 |
| * ScaledTolerance                                                   | 0x0013 |
| * Scale                                                             | 0x0014 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadPressureMeasurementMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PressureMeasurement.MeasuredValue response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadPressureMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"PressureMeasurement.MinMeasuredValue response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadPressureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"PressureMeasurement.MaxMeasuredValue response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPressureMeasurementAttributeList : public ModelCommand {
public:
    ReadPressureMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PressureMeasurement.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPressureMeasurementClusterRevision : public ModelCommand {
public:
    ReadPressureMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePressureMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributePressureMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePressureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"PressureMeasurement.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PumpConfigurationAndControl                                 | 0x0200 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxPressure                                                       | 0x0000 |
| * MaxSpeed                                                          | 0x0001 |
| * MaxFlow                                                           | 0x0002 |
| * MinConstPressure                                                  | 0x0003 |
| * MaxConstPressure                                                  | 0x0004 |
| * MinCompPressure                                                   | 0x0005 |
| * MaxCompPressure                                                   | 0x0006 |
| * MinConstSpeed                                                     | 0x0007 |
| * MaxConstSpeed                                                     | 0x0008 |
| * MinConstFlow                                                      | 0x0009 |
| * MaxConstFlow                                                      | 0x000A |
| * MinConstTemp                                                      | 0x000B |
| * MaxConstTemp                                                      | 0x000C |
| * PumpStatus                                                        | 0x0010 |
| * EffectiveOperationMode                                            | 0x0011 |
| * EffectiveControlMode                                              | 0x0012 |
| * Capacity                                                          | 0x0013 |
| * Speed                                                             | 0x0014 |
| * LifetimeRunningHours                                              | 0x0015 |
| * Power                                                             | 0x0016 |
| * LifetimeEnergyConsumed                                            | 0x0017 |
| * OperationMode                                                     | 0x0020 |
| * ControlMode                                                       | 0x0021 |
| * AlarmMask                                                         | 0x0022 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SupplyVoltageLow                                                  | 0x0000 |
| * SupplyVoltageHigh                                                 | 0x0001 |
| * PowerMissingPhase                                                 | 0x0002 |
| * SystemPressureLow                                                 | 0x0003 |
| * SystemPressureHigh                                                | 0x0004 |
| * DryRunning                                                        | 0x0005 |
| * MotorTemperatureHigh                                              | 0x0006 |
| * PumpMotorFatalFailure                                             | 0x0007 |
| * ElectronicTemperatureHigh                                         | 0x0008 |
| * PumpBlocked                                                       | 0x0009 |
| * SensorFailure                                                     | 0x000A |
| * ElectronicNonFatalFailure                                         | 0x000B |
| * ElectronicFatalFailure                                            | 0x000C |
| * GeneralFault                                                      | 0x000D |
| * Leakage                                                           | 0x000E |
| * AirDetection                                                      | 0x000F |
| * TurbineOperation                                                  | 0x0010 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MaxPressure
 */
class ReadPumpConfigurationAndControlMaxPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"PumpConfigurationAndControl.MaxPressure response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxSpeed
 */
class ReadPumpConfigurationAndControlMaxSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxSpeed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxSpeed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"PumpConfigurationAndControl.MaxSpeed response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFlow
 */
class ReadPumpConfigurationAndControlMaxFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxFlow response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxFlow : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxFlowWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MaxFlow response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstPressure
 */
class ReadPumpConfigurationAndControlMinConstPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinConstPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinConstPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinConstPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"PumpConfigurationAndControl.MinConstPressure response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstPressure
 */
class ReadPumpConfigurationAndControlMaxConstPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxConstPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxConstPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxConstPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"PumpConfigurationAndControl.MaxConstPressure response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCompPressure
 */
class ReadPumpConfigurationAndControlMinCompPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinCompPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinCompPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinCompPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinCompPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinCompPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinCompPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PumpConfigurationAndControl.MinCompPressure response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCompPressure
 */
class ReadPumpConfigurationAndControlMaxCompPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxCompPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxCompPressure response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxCompPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxCompPressure : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxCompPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxCompPressureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PumpConfigurationAndControl.MaxCompPressure response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstSpeed
 */
class ReadPumpConfigurationAndControlMinConstSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstSpeed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinConstSpeed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinConstSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinConstSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PumpConfigurationAndControl.MinConstSpeed response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstSpeed
 */
class ReadPumpConfigurationAndControlMaxConstSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstSpeed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxConstSpeed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxConstSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxConstSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PumpConfigurationAndControl.MaxConstSpeed response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstFlow
 */
class ReadPumpConfigurationAndControlMinConstFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstFlow response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinConstFlow : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinConstFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinConstFlowWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MinConstFlow response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstFlow
 */
class ReadPumpConfigurationAndControlMaxConstFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstFlow response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxConstFlow : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxConstFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxConstFlowWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MaxConstFlow response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstTemp
 */
class ReadPumpConfigurationAndControlMinConstTemp : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstTemp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstTemp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstTemp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMinConstTemp : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMinConstTemp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMinConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinConstTempWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MinConstTemp response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstTemp
 */
class ReadPumpConfigurationAndControlMaxConstTemp : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstTemp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstTemp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstTemp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlMaxConstTemp : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlMaxConstTemp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlMaxConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxConstTempWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"PumpConfigurationAndControl.MaxConstTemp response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PumpStatus
 */
class ReadPumpConfigurationAndControlPumpStatus : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPumpStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pump-status");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePumpStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.PumpStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl PumpStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlPumpStatus : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlPumpStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pump-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlPumpStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributePumpStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PumpConfigurationAndControl.PumpStatus response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveOperationMode
 */
class ReadPumpConfigurationAndControlEffectiveOperationMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlEffectiveOperationMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEffectiveOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.EffectiveOperationMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl EffectiveOperationMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlEffectiveOperationMode : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlEffectiveOperationMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "effective-operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlEffectiveOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeEffectiveOperationModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"PumpConfigurationAndControl.EffectiveOperationMode response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveControlMode
 */
class ReadPumpConfigurationAndControlEffectiveControlMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlEffectiveControlMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEffectiveControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.EffectiveControlMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl EffectiveControlMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlEffectiveControlMode : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlEffectiveControlMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "effective-control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlEffectiveControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEffectiveControlModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"PumpConfigurationAndControl.EffectiveControlMode response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Capacity
 */
class ReadPumpConfigurationAndControlCapacity : public ModelCommand {
public:
    ReadPumpConfigurationAndControlCapacity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "capacity");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlCapacity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCapacityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Capacity response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Capacity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlCapacity : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlCapacity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "capacity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlCapacity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCapacityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"PumpConfigurationAndControl.Capacity response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Speed
 */
class ReadPumpConfigurationAndControlSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Speed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Speed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlSpeed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSpeedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PumpConfigurationAndControl.Speed response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeRunningHours
 */
class ReadPumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    ReadPumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLifetimeRunningHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.LifetimeRunningHours response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeRunningHours Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WritePumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    WritePumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeLifetimeRunningHoursWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               err = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeRunningHours Error: %s",
                                                   chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributePumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLifetimeRunningHoursWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"PumpConfigurationAndControl.LifetimeRunningHours response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Power
 */
class ReadPumpConfigurationAndControlPower : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "power");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Power response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Power Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlPower : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlPower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlPower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePowerWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PumpConfigurationAndControl.Power response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeEnergyConsumed
 */
class ReadPumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLifetimeEnergyConsumedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.LifetimeEnergyConsumed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeEnergyConsumed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WritePumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    WritePumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster
            writeAttributeLifetimeEnergyConsumedWithValue:value
                                        completionHandler:^(NSError * _Nullable error) {
                                            err = [CHIPError errorToCHIPErrorCode:error];
                                            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeEnergyConsumed Error: %s",
                                                chip::ErrorStr(err));
                                            SetCommandExitStatus(err);
                                        }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributePumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeLifetimeEnergyConsumedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"PumpConfigurationAndControl.LifetimeEnergyConsumed response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationMode
 */
class ReadPumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlOperationMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.OperationMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl OperationMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WritePumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    WritePumpConfigurationAndControlOperationMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000020) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeOperationModeWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        err = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(
                                            chipTool, "PumpConfigurationAndControl OperationMode Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributePumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlOperationMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOperationModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PumpConfigurationAndControl.OperationMode response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlMode
 */
class ReadPumpConfigurationAndControlControlMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlControlMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.ControlMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl ControlMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WritePumpConfigurationAndControlControlMode : public ModelCommand {
public:
    WritePumpConfigurationAndControlControlMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeControlModeWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "PumpConfigurationAndControl ControlMode Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributePumpConfigurationAndControlControlMode : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlControlMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeControlModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"PumpConfigurationAndControl.ControlMode response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AlarmMask
 */
class ReadPumpConfigurationAndControlAlarmMask : public ModelCommand {
public:
    ReadPumpConfigurationAndControlAlarmMask()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "alarm-mask");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAlarmMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAlarmMaskWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.AlarmMask response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl AlarmMask Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlAlarmMask : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlAlarmMask()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "alarm-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlAlarmMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAlarmMaskWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"PumpConfigurationAndControl.AlarmMask response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadPumpConfigurationAndControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PumpConfigurationAndControl.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PumpConfigurationAndControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"PumpConfigurationAndControl.ServerGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadPumpConfigurationAndControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PumpConfigurationAndControl.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PumpConfigurationAndControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"PumpConfigurationAndControl.ClientGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPumpConfigurationAndControlAttributeList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlAttributeList : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"PumpConfigurationAndControl.AttributeList response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadPumpConfigurationAndControlFeatureMap : public ModelCommand {
public:
    ReadPumpConfigurationAndControlFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlFeatureMap : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"PumpConfigurationAndControl.FeatureMap response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPumpConfigurationAndControlClusterRevision : public ModelCommand {
public:
    ReadPumpConfigurationAndControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributePumpConfigurationAndControlClusterRevision : public ModelCommand {
public:
    SubscribeAttributePumpConfigurationAndControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributePumpConfigurationAndControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"PumpConfigurationAndControl.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster RelativeHumidityMeasurement                                 | 0x0405 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadRelativeHumidityMeasurementMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"RelativeHumidityMeasurement.MeasuredValue response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"RelativeHumidityMeasurement.MinMeasuredValue response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"RelativeHumidityMeasurement.MaxMeasuredValue response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadRelativeHumidityMeasurementTolerance : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.Tolerance response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementTolerance : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeToleranceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"RelativeHumidityMeasurement.Tolerance response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadRelativeHumidityMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"RelativeHumidityMeasurement.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "RelativeHumidityMeasurement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"RelativeHumidityMeasurement.ServerGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadRelativeHumidityMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"RelativeHumidityMeasurement.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "RelativeHumidityMeasurement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"RelativeHumidityMeasurement.ClientGeneratedCommandList "
                                                                    @"response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadRelativeHumidityMeasurementAttributeList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"RelativeHumidityMeasurement.AttributeList response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadRelativeHumidityMeasurementClusterRevision : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeRelativeHumidityMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeRelativeHumidityMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeRelativeHumidityMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"RelativeHumidityMeasurement.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Scenes                                                      | 0x0005 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddScene                                                          |   0x00 |
| * ViewScene                                                         |   0x01 |
| * RemoveScene                                                       |   0x02 |
| * RemoveAllScenes                                                   |   0x03 |
| * StoreScene                                                        |   0x04 |
| * RecallScene                                                       |   0x05 |
| * GetSceneMembership                                                |   0x06 |
| * EnhancedAddScene                                                  |   0x40 |
| * EnhancedViewScene                                                 |   0x41 |
| * CopyScene                                                         |   0x42 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SceneCount                                                        | 0x0000 |
| * CurrentScene                                                      | 0x0001 |
| * CurrentGroup                                                      | 0x0002 |
| * SceneValid                                                        | 0x0003 |
| * NameSupport                                                       | 0x0004 |
| * LastConfiguredBy                                                  | 0x0005 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddScene
 */
class ScenesAddScene : public ModelCommand {
public:
    ScenesAddScene()
        : ModelCommand("add-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("SceneName", &mSceneName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterAddSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.sceneName = [[NSString alloc] initWithBytes:mSceneName.data()
                                                    length:mSceneName.size()
                                                  encoding:NSUTF8StringEncoding];
        // extensionFieldSets Array parsing is not supported yet
        [cluster addSceneWithParams:params
                  completionHandler:^(CHIPScenesClusterAddSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                      NSLog(@"Values: %@", values);
                      err = [CHIPError errorToCHIPErrorCode:error];
                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];
        return err;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
    uint16_t mTransitionTime;
    chip::ByteSpan mSceneName;
};

/*
 * Command GetSceneMembership
 */
class ScenesGetSceneMembership : public ModelCommand {
public:
    ScenesGetSceneMembership()
        : ModelCommand("get-scene-membership")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterGetSceneMembershipParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster getSceneMembershipWithParams:params
                            completionHandler:^(
                                CHIPScenesClusterGetSceneMembershipResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint16_t mGroupId;
};

/*
 * Command RecallScene
 */
class ScenesRecallScene : public ModelCommand {
public:
    ScenesRecallScene()
        : ModelCommand("recall-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterRecallSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster recallSceneWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
    uint16_t mTransitionTime;
};

/*
 * Command RemoveAllScenes
 */
class ScenesRemoveAllScenes : public ModelCommand {
public:
    ScenesRemoveAllScenes()
        : ModelCommand("remove-all-scenes")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterRemoveAllScenesParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster removeAllScenesWithParams:params
                         completionHandler:^(
                             CHIPScenesClusterRemoveAllScenesResponseParams * _Nullable values, NSError * _Nullable error) {
                             NSLog(@"Values: %@", values);
                             err = [CHIPError errorToCHIPErrorCode:error];
                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];
        return err;
    }

private:
    uint16_t mGroupId;
};

/*
 * Command RemoveScene
 */
class ScenesRemoveScene : public ModelCommand {
public:
    ScenesRemoveScene()
        : ModelCommand("remove-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterRemoveSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster removeSceneWithParams:params
                     completionHandler:^(CHIPScenesClusterRemoveSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         err = [CHIPError errorToCHIPErrorCode:error];
                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];
        return err;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Command StoreScene
 */
class ScenesStoreScene : public ModelCommand {
public:
    ScenesStoreScene()
        : ModelCommand("store-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterStoreSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster storeSceneWithParams:params
                    completionHandler:^(CHIPScenesClusterStoreSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        err = [CHIPError errorToCHIPErrorCode:error];
                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];
        return err;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Command ViewScene
 */
class ScenesViewScene : public ModelCommand {
public:
    ScenesViewScene()
        : ModelCommand("view-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPScenesClusterViewSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster viewSceneWithParams:params
                   completionHandler:^(CHIPScenesClusterViewSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       err = [CHIPError errorToCHIPErrorCode:error];
                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];
        return err;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Attribute SceneCount
 */
class ReadScenesSceneCount : public ModelCommand {
public:
    ReadScenesSceneCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-count");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSceneCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.SceneCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes SceneCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesSceneCount : public ModelCommand {
public:
    SubscribeAttributeScenesSceneCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scene-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesSceneCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSceneCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Scenes.SceneCount response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentScene
 */
class ReadScenesCurrentScene : public ModelCommand {
public:
    ReadScenesCurrentScene()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-scene");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentScene() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentSceneWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.CurrentScene response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes CurrentScene Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesCurrentScene : public ModelCommand {
public:
    SubscribeAttributeScenesCurrentScene()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-scene");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesCurrentScene() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentSceneWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Scenes.CurrentScene response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentGroup
 */
class ReadScenesCurrentGroup : public ModelCommand {
public:
    ReadScenesCurrentGroup()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-group");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentGroup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentGroupWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.CurrentGroup response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes CurrentGroup Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesCurrentGroup : public ModelCommand {
public:
    SubscribeAttributeScenesCurrentGroup()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-group");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesCurrentGroup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentGroupWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"Scenes.CurrentGroup response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SceneValid
 */
class ReadScenesSceneValid : public ModelCommand {
public:
    ReadScenesSceneValid()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-valid");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneValid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSceneValidWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.SceneValid response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes SceneValid Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesSceneValid : public ModelCommand {
public:
    SubscribeAttributeScenesSceneValid()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scene-valid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesSceneValid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSceneValidWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Scenes.SceneValid response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NameSupport
 */
class ReadScenesNameSupport : public ModelCommand {
public:
    ReadScenesNameSupport()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadScenesNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNameSupportWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.NameSupport response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes NameSupport Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesNameSupport : public ModelCommand {
public:
    SubscribeAttributeScenesNameSupport()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNameSupportWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Scenes.NameSupport response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadScenesServerGeneratedCommandList : public ModelCommand {
public:
    ReadScenesServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Scenes.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Scenes ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeScenesServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeScenesServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Scenes.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadScenesClientGeneratedCommandList : public ModelCommand {
public:
    ReadScenesClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Scenes.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Scenes ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeScenesClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeScenesClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Scenes.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadScenesAttributeList : public ModelCommand {
public:
    ReadScenesAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesAttributeList : public ModelCommand {
public:
    SubscribeAttributeScenesAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Scenes.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadScenesClusterRevision : public ModelCommand {
public:
    ReadScenesClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadScenesClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeScenesClusterRevision : public ModelCommand {
public:
    SubscribeAttributeScenesClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeScenesClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Scenes.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster SoftwareDiagnostics                                         | 0x0034 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetWatermarks                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ThreadMetrics                                                     | 0x0000 |
| * CurrentHeapFree                                                   | 0x0001 |
| * CurrentHeapUsed                                                   | 0x0002 |
| * CurrentHeapHighWatermark                                          | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SoftwareFault                                                     | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetWatermarks
 */
class SoftwareDiagnosticsResetWatermarks : public ModelCommand {
public:
    SoftwareDiagnosticsResetWatermarks()
        : ModelCommand("reset-watermarks")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster resetWatermarksWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute ThreadMetrics
 */
class ReadSoftwareDiagnosticsThreadMetrics : public ModelCommand {
public:
    ReadSoftwareDiagnosticsThreadMetrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "thread-metrics");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsThreadMetrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeThreadMetricsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.ThreadMetrics response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics ThreadMetrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsThreadMetrics : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsThreadMetrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "thread-metrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsThreadMetrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeThreadMetricsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"SoftwareDiagnostics.ThreadMetrics response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapFree
 */
class ReadSoftwareDiagnosticsCurrentHeapFree : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapFree()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-free");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapFree() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentHeapFreeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.CurrentHeapFree response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapFree Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsCurrentHeapFree : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsCurrentHeapFree()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-free");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsCurrentHeapFree() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentHeapFreeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"SoftwareDiagnostics.CurrentHeapFree response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapUsed
 */
class ReadSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapUsed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-used");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapUsed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentHeapUsedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.CurrentHeapUsed response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapUsed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsCurrentHeapUsed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-used");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsCurrentHeapUsed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentHeapUsedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"SoftwareDiagnostics.CurrentHeapUsed response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapHighWatermark
 */
class ReadSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapHighWatermark()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapHighWatermark() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeCurrentHeapHighWatermarkWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"SoftwareDiagnostics.CurrentHeapHighWatermark response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapHighWatermark Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsCurrentHeapHighWatermark()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsCurrentHeapHighWatermark() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentHeapHighWatermarkWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"SoftwareDiagnostics.CurrentHeapHighWatermark response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadSoftwareDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"SoftwareDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "SoftwareDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"SoftwareDiagnostics.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadSoftwareDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"SoftwareDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "SoftwareDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"SoftwareDiagnostics.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadSoftwareDiagnosticsAttributeList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"SoftwareDiagnostics.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadSoftwareDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadSoftwareDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsFeatureMap : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"SoftwareDiagnostics.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSoftwareDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadSoftwareDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSoftwareDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeSoftwareDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSoftwareDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"SoftwareDiagnostics.ClusterRevision response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Switch                                                      | 0x003B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NumberOfPositions                                                 | 0x0000 |
| * CurrentPosition                                                   | 0x0001 |
| * MultiPressMax                                                     | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SwitchLatched                                                     | 0x0000 |
| * InitialPress                                                      | 0x0001 |
| * LongPress                                                         | 0x0002 |
| * ShortRelease                                                      | 0x0003 |
| * LongRelease                                                       | 0x0004 |
| * MultiPressOngoing                                                 | 0x0005 |
| * MultiPressComplete                                                | 0x0006 |
\*----------------------------------------------------------------------------*/

/*
 * Attribute NumberOfPositions
 */
class ReadSwitchNumberOfPositions : public ModelCommand {
public:
    ReadSwitchNumberOfPositions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-positions");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchNumberOfPositions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNumberOfPositionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.NumberOfPositions response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch NumberOfPositions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchNumberOfPositions : public ModelCommand {
public:
    SubscribeAttributeSwitchNumberOfPositions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-positions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchNumberOfPositions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNumberOfPositionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"Switch.NumberOfPositions response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPosition
 */
class ReadSwitchCurrentPosition : public ModelCommand {
public:
    ReadSwitchCurrentPosition()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchCurrentPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.CurrentPosition response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch CurrentPosition Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchCurrentPosition : public ModelCommand {
public:
    SubscribeAttributeSwitchCurrentPosition()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchCurrentPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentPositionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Switch.CurrentPosition response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MultiPressMax
 */
class ReadSwitchMultiPressMax : public ModelCommand {
public:
    ReadSwitchMultiPressMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "multi-press-max");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMultiPressMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.MultiPressMax response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch MultiPressMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchMultiPressMax : public ModelCommand {
public:
    SubscribeAttributeSwitchMultiPressMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "multi-press-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchMultiPressMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMultiPressMaxWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Switch.MultiPressMax response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadSwitchServerGeneratedCommandList : public ModelCommand {
public:
    ReadSwitchServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Switch.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Switch ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeSwitchServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeSwitchServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Switch.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadSwitchClientGeneratedCommandList : public ModelCommand {
public:
    ReadSwitchClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Switch.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Switch ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeSwitchClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeSwitchClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Switch.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadSwitchAttributeList : public ModelCommand {
public:
    ReadSwitchAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchAttributeList : public ModelCommand {
public:
    SubscribeAttributeSwitchAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Switch.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadSwitchFeatureMap : public ModelCommand {
public:
    ReadSwitchFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchFeatureMap : public ModelCommand {
public:
    SubscribeAttributeSwitchFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Switch.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSwitchClusterRevision : public ModelCommand {
public:
    ReadSwitchClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeSwitchClusterRevision : public ModelCommand {
public:
    SubscribeAttributeSwitchClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeSwitchClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Switch.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TargetNavigator                                             | 0x0505 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * NavigateTarget                                                    |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TargetList                                                        | 0x0000 |
| * CurrentTarget                                                     | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command NavigateTarget
 */
class TargetNavigatorNavigateTarget : public ModelCommand {
public:
    TargetNavigatorNavigateTarget()
        : ModelCommand("navigate-target")
    {
        AddArgument("Target", 0, UINT8_MAX, &mTarget);
        AddArgument("Data", &mData);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTargetNavigatorClusterNavigateTargetParams alloc] init];
        params.target = [NSNumber numberWithUnsignedChar:mTarget];
        params.data = [[NSString alloc] initWithBytes:mData.data() length:mData.size() encoding:NSUTF8StringEncoding];
        [cluster navigateTargetWithParams:params
                        completionHandler:^(
                            CHIPTargetNavigatorClusterNavigateTargetResponseParams * _Nullable values, NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            err = [CHIPError errorToCHIPErrorCode:error];
                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];
        return err;
    }

private:
    uint8_t mTarget;
    chip::ByteSpan mData;
};

/*
 * Attribute TargetList
 */
class ReadTargetNavigatorTargetList : public ModelCommand {
public:
    ReadTargetNavigatorTargetList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorTargetList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTargetListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.TargetList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator TargetList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorTargetList : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorTargetList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorTargetList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTargetListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"TargetNavigator.TargetList response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentTarget
 */
class ReadTargetNavigatorCurrentTarget : public ModelCommand {
public:
    ReadTargetNavigatorCurrentTarget()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-target");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorCurrentTarget() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentTargetWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.CurrentTarget response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator CurrentTarget Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorCurrentTarget : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorCurrentTarget()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-target");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorCurrentTarget() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentTargetWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TargetNavigator.CurrentTarget response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadTargetNavigatorServerGeneratedCommandList : public ModelCommand {
public:
    ReadTargetNavigatorServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TargetNavigator.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TargetNavigator ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TargetNavigator.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadTargetNavigatorClientGeneratedCommandList : public ModelCommand {
public:
    ReadTargetNavigatorClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TargetNavigator.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TargetNavigator ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TargetNavigator.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTargetNavigatorAttributeList : public ModelCommand {
public:
    ReadTargetNavigatorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorAttributeList : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TargetNavigator.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTargetNavigatorClusterRevision : public ModelCommand {
public:
    ReadTargetNavigatorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTargetNavigatorClusterRevision : public ModelCommand {
public:
    SubscribeAttributeTargetNavigatorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTargetNavigatorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TargetNavigator.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TemperatureMeasurement                                      | 0x0402 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadTemperatureMeasurementMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TemperatureMeasurement.MeasuredValue response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadTemperatureMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MinMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementMinMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMinMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TemperatureMeasurement.MinMeasuredValue response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadTemperatureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MaxMeasuredValue response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMaxMeasuredValueWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TemperatureMeasurement.MaxMeasuredValue response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadTemperatureMeasurementTolerance : public ModelCommand {
public:
    ReadTemperatureMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.Tolerance response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementTolerance : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeToleranceWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"TemperatureMeasurement.Tolerance response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTemperatureMeasurementAttributeList : public ModelCommand {
public:
    ReadTemperatureMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementAttributeList : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TemperatureMeasurement.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTemperatureMeasurementClusterRevision : public ModelCommand {
public:
    ReadTemperatureMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTemperatureMeasurementClusterRevision : public ModelCommand {
public:
    SubscribeAttributeTemperatureMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTemperatureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TemperatureMeasurement.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TestCluster                                                 | 0x050F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Test                                                              |   0x00 |
| * TestNotHandled                                                    |   0x01 |
| * TestSpecific                                                      |   0x02 |
| * TestUnknownCommand                                                |   0x03 |
| * TestAddArguments                                                  |   0x04 |
| * TestSimpleArgumentRequest                                         |   0x05 |
| * TestStructArrayArgumentRequest                                    |   0x06 |
| * TestStructArgumentRequest                                         |   0x07 |
| * TestNestedStructArgumentRequest                                   |   0x08 |
| * TestListStructArgumentRequest                                     |   0x09 |
| * TestListInt8UArgumentRequest                                      |   0x0A |
| * TestNestedStructListArgumentRequest                               |   0x0B |
| * TestListNestedStructListArgumentRequest                           |   0x0C |
| * TestListInt8UReverseRequest                                       |   0x0D |
| * TestEnumsRequest                                                  |   0x0E |
| * TestNullableOptionalRequest                                       |   0x0F |
| * TestComplexNullableOptionalRequest                                |   0x10 |
| * SimpleStructEchoRequest                                           |   0x11 |
| * TimedInvokeRequest                                                |   0x12 |
| * TestSimpleOptionalArgumentRequest                                 |   0x13 |
| * TestEmitTestEventRequest                                          |   0x14 |
| * TestEmitTestFabricScopedEventRequest                              |   0x15 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Boolean                                                           | 0x0000 |
| * Bitmap8                                                           | 0x0001 |
| * Bitmap16                                                          | 0x0002 |
| * Bitmap32                                                          | 0x0003 |
| * Bitmap64                                                          | 0x0004 |
| * Int8u                                                             | 0x0005 |
| * Int16u                                                            | 0x0006 |
| * Int24u                                                            | 0x0007 |
| * Int32u                                                            | 0x0008 |
| * Int40u                                                            | 0x0009 |
| * Int48u                                                            | 0x000A |
| * Int56u                                                            | 0x000B |
| * Int64u                                                            | 0x000C |
| * Int8s                                                             | 0x000D |
| * Int16s                                                            | 0x000E |
| * Int24s                                                            | 0x000F |
| * Int32s                                                            | 0x0010 |
| * Int40s                                                            | 0x0011 |
| * Int48s                                                            | 0x0012 |
| * Int56s                                                            | 0x0013 |
| * Int64s                                                            | 0x0014 |
| * Enum8                                                             | 0x0015 |
| * Enum16                                                            | 0x0016 |
| * FloatSingle                                                       | 0x0017 |
| * FloatDouble                                                       | 0x0018 |
| * OctetString                                                       | 0x0019 |
| * ListInt8u                                                         | 0x001A |
| * ListOctetString                                                   | 0x001B |
| * ListStructOctetString                                             | 0x001C |
| * LongOctetString                                                   | 0x001D |
| * CharString                                                        | 0x001E |
| * LongCharString                                                    | 0x001F |
| * EpochUs                                                           | 0x0020 |
| * EpochS                                                            | 0x0021 |
| * VendorId                                                          | 0x0022 |
| * ListNullablesAndOptionalsStruct                                   | 0x0023 |
| * EnumAttr                                                          | 0x0024 |
| * StructAttr                                                        | 0x0025 |
| * RangeRestrictedInt8u                                              | 0x0026 |
| * RangeRestrictedInt8s                                              | 0x0027 |
| * RangeRestrictedInt16u                                             | 0x0028 |
| * RangeRestrictedInt16s                                             | 0x0029 |
| * ListLongOctetString                                               | 0x002A |
| * ListFabricScoped                                                  | 0x002B |
| * TimedWriteBoolean                                                 | 0x0030 |
| * GeneralErrorBoolean                                               | 0x0031 |
| * ClusterErrorBoolean                                               | 0x0032 |
| * Unsupported                                                       | 0x00FF |
| * NullableBoolean                                                   | 0x8000 |
| * NullableBitmap8                                                   | 0x8001 |
| * NullableBitmap16                                                  | 0x8002 |
| * NullableBitmap32                                                  | 0x8003 |
| * NullableBitmap64                                                  | 0x8004 |
| * NullableInt8u                                                     | 0x8005 |
| * NullableInt16u                                                    | 0x8006 |
| * NullableInt24u                                                    | 0x8007 |
| * NullableInt32u                                                    | 0x8008 |
| * NullableInt40u                                                    | 0x8009 |
| * NullableInt48u                                                    | 0x800A |
| * NullableInt56u                                                    | 0x800B |
| * NullableInt64u                                                    | 0x800C |
| * NullableInt8s                                                     | 0x800D |
| * NullableInt16s                                                    | 0x800E |
| * NullableInt24s                                                    | 0x800F |
| * NullableInt32s                                                    | 0x8010 |
| * NullableInt40s                                                    | 0x8011 |
| * NullableInt48s                                                    | 0x8012 |
| * NullableInt56s                                                    | 0x8013 |
| * NullableInt64s                                                    | 0x8014 |
| * NullableEnum8                                                     | 0x8015 |
| * NullableEnum16                                                    | 0x8016 |
| * NullableFloatSingle                                               | 0x8017 |
| * NullableFloatDouble                                               | 0x8018 |
| * NullableOctetString                                               | 0x8019 |
| * NullableCharString                                                | 0x801E |
| * NullableEnumAttr                                                  | 0x8024 |
| * NullableStruct                                                    | 0x8025 |
| * NullableRangeRestrictedInt8u                                      | 0x8026 |
| * NullableRangeRestrictedInt8s                                      | 0x8027 |
| * NullableRangeRestrictedInt16u                                     | 0x8028 |
| * NullableRangeRestrictedInt16s                                     | 0x8029 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * TestEvent                                                         | 0x0001 |
| * TestFabricScopedEvent                                             | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command SimpleStructEchoRequest
 */
class TestClusterSimpleStructEchoRequest : public ModelCommand {
public:
    TestClusterSimpleStructEchoRequest()
        : ModelCommand("simple-struct-echo-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterSimpleStructEchoRequestParams alloc] init];
        // arg1 Struct parsing is not supported yet
        [cluster simpleStructEchoRequestWithParams:params
                                 completionHandler:^(CHIPTestClusterClusterSimpleStructResponseParams * _Nullable values,
                                     NSError * _Nullable error) {
                                     NSLog(@"Values: %@", values);
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
};

/*
 * Command Test
 */
class TestClusterTest : public ModelCommand {
public:
    TestClusterTest()
        : ModelCommand("test")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster testWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command TestAddArguments
 */
class TestClusterTestAddArguments : public ModelCommand {
public:
    TestClusterTestAddArguments()
        : ModelCommand("test-add-arguments")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestAddArgumentsParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];
        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];
        [cluster testAddArgumentsWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable values, NSError * _Nullable error) {
                              NSLog(@"Values: %@", values);
                              err = [CHIPError errorToCHIPErrorCode:error];
                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];
        return err;
    }

private:
    uint8_t mArg1;
    uint8_t mArg2;
};

/*
 * Command TestEmitTestEventRequest
 */
class TestClusterTestEmitTestEventRequest : public ModelCommand {
public:
    TestClusterTestEmitTestEventRequest()
        : ModelCommand("test-emit-test-event-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        AddArgument("Arg3", 0, 1, &mArg3);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestEmitTestEventRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];
        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];
        params.arg3 = [NSNumber numberWithBool:mArg3];
        [cluster testEmitTestEventRequestWithParams:params
                                  completionHandler:^(CHIPTestClusterClusterTestEmitTestEventResponseParams * _Nullable values,
                                      NSError * _Nullable error) {
                                      NSLog(@"Values: %@", values);
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    uint8_t mArg1;
    uint8_t mArg2;
    bool mArg3;
};

/*
 * Command TestEnumsRequest
 */
class TestClusterTestEnumsRequest : public ModelCommand {
public:
    TestClusterTestEnumsRequest()
        : ModelCommand("test-enums-request")
    {
        AddArgument("Arg1", 0, UINT16_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestEnumsRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedShort:mArg1];
        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];
        [cluster testEnumsRequestWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestEnumsResponseParams * _Nullable values, NSError * _Nullable error) {
                              NSLog(@"Values: %@", values);
                              err = [CHIPError errorToCHIPErrorCode:error];
                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];
        return err;
    }

private:
    chip::VendorId mArg1;
    uint8_t mArg2;
};

/*
 * Command TestListInt8UArgumentRequest
 */
class TestClusterTestListInt8UArgumentRequest : public ModelCommand {
public:
    TestClusterTestListInt8UArgumentRequest()
        : ModelCommand("test-list-int8uargument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UArgumentRequestParams alloc] init];
        // arg1 Array parsing is not supported yet
        [cluster testListInt8UArgumentRequestWithParams:params
                                      completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                          NSError * _Nullable error) {
                                          NSLog(@"Values: %@", values);
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
};

/*
 * Command TestListInt8UReverseRequest
 */
class TestClusterTestListInt8UReverseRequest : public ModelCommand {
public:
    TestClusterTestListInt8UReverseRequest()
        : ModelCommand("test-list-int8ureverse-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UReverseRequestParams alloc] init];
        // arg1 Array parsing is not supported yet
        [cluster
            testListInt8UReverseRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestListInt8UReverseResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    err = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }

private:
};

/*
 * Command TestListNestedStructListArgumentRequest
 */
class TestClusterTestListNestedStructListArgumentRequest : public ModelCommand {
public:
    TestClusterTestListNestedStructListArgumentRequest()
        : ModelCommand("test-list-nested-struct-list-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestListNestedStructListArgumentRequestParams alloc] init];
        // arg1 Array parsing is not supported yet
        [cluster testListNestedStructListArgumentRequestWithParams:params
                                                 completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                     NSError * _Nullable error) {
                                                     NSLog(@"Values: %@", values);
                                                     err = [CHIPError errorToCHIPErrorCode:error];
                                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                                     SetCommandExitStatus(err);
                                                 }];
        return err;
    }

private:
};

/*
 * Command TestListStructArgumentRequest
 */
class TestClusterTestListStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestListStructArgumentRequest()
        : ModelCommand("test-list-struct-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestListStructArgumentRequestParams alloc] init];
        // arg1 Array parsing is not supported yet
        [cluster testListStructArgumentRequestWithParams:params
                                       completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                           NSError * _Nullable error) {
                                           NSLog(@"Values: %@", values);
                                           err = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }

private:
};

/*
 * Command TestNestedStructArgumentRequest
 */
class TestClusterTestNestedStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestNestedStructArgumentRequest()
        : ModelCommand("test-nested-struct-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructArgumentRequestParams alloc] init];
        // arg1 Struct parsing is not supported yet
        [cluster testNestedStructArgumentRequestWithParams:params
                                         completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                             NSError * _Nullable error) {
                                             NSLog(@"Values: %@", values);
                                             err = [CHIPError errorToCHIPErrorCode:error];
                                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                             SetCommandExitStatus(err);
                                         }];
        return err;
    }

private:
};

/*
 * Command TestNestedStructListArgumentRequest
 */
class TestClusterTestNestedStructListArgumentRequest : public ModelCommand {
public:
    TestClusterTestNestedStructListArgumentRequest()
        : ModelCommand("test-nested-struct-list-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructListArgumentRequestParams alloc] init];
        // arg1 Struct parsing is not supported yet
        [cluster testNestedStructListArgumentRequestWithParams:params
                                             completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                 NSError * _Nullable error) {
                                                 NSLog(@"Values: %@", values);
                                                 err = [CHIPError errorToCHIPErrorCode:error];
                                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                                 SetCommandExitStatus(err);
                                             }];
        return err;
    }

private:
};

/*
 * Command TestNotHandled
 */
class TestClusterTestNotHandled : public ModelCommand {
public:
    TestClusterTestNotHandled()
        : ModelCommand("test-not-handled")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster testNotHandledWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command TestNullableOptionalRequest
 */
class TestClusterTestNullableOptionalRequest : public ModelCommand {
public:
    TestClusterTestNullableOptionalRequest()
        : ModelCommand("test-nullable-optional-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestNullableOptionalRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];
        [cluster
            testNullableOptionalRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestNullableOptionalResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    err = [CHIPError errorToCHIPErrorCode:error];
                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return err;
    }

private:
    uint8_t mArg1;
};

/*
 * Command TestSimpleOptionalArgumentRequest
 */
class TestClusterTestSimpleOptionalArgumentRequest : public ModelCommand {
public:
    TestClusterTestSimpleOptionalArgumentRequest()
        : ModelCommand("test-simple-optional-argument-request")
    {
        AddArgument("Arg1", 0, 1, &mArg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestSimpleOptionalArgumentRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithBool:mArg1];
        [cluster testSimpleOptionalArgumentRequestWithParams:params
                                           completionHandler:^(NSError * _Nullable error) {
                                               err = [CHIPError errorToCHIPErrorCode:error];
                                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return err;
    }

private:
    bool mArg1;
};

/*
 * Command TestSpecific
 */
class TestClusterTestSpecific : public ModelCommand {
public:
    TestClusterTestSpecific()
        : ModelCommand("test-specific")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster testSpecificWithCompletionHandler:^(
            CHIPTestClusterClusterTestSpecificResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command TestStructArgumentRequest
 */
class TestClusterTestStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestStructArgumentRequest()
        : ModelCommand("test-struct-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPTestClusterClusterTestStructArgumentRequestParams alloc] init];
        // arg1 Struct parsing is not supported yet
        [cluster testStructArgumentRequestWithParams:params
                                   completionHandler:^(
                                       CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable error) {
                                       NSLog(@"Values: %@", values);
                                       err = [CHIPError errorToCHIPErrorCode:error];
                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return err;
    }

private:
};

/*
 * Command TestUnknownCommand
 */
class TestClusterTestUnknownCommand : public ModelCommand {
public:
    TestClusterTestUnknownCommand()
        : ModelCommand("test-unknown-command")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster testUnknownCommandWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command TimedInvokeRequest
 */
class TestClusterTimedInvokeRequest : public ModelCommand {
public:
    TestClusterTimedInvokeRequest()
        : ModelCommand("timed-invoke-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster timedInvokeRequestWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute Boolean
 */
class ReadTestClusterBoolean : public ModelCommand {
public:
    ReadTestClusterBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Boolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Boolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBoolean : public ModelCommand {
public:
    WriteTestClusterBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeBooleanWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "TestCluster Boolean Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"TestCluster.Boolean response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap8
 */
class ReadTestClusterBitmap8 : public ModelCommand {
public:
    ReadTestClusterBitmap8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap8 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBitmap8 : public ModelCommand {
public:
    WriteTestClusterBitmap8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeBitmap8WithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "TestCluster Bitmap8 Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterBitmap8 : public ModelCommand {
public:
    SubscribeAttributeTestClusterBitmap8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBitmap8WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"TestCluster.Bitmap8 response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap16
 */
class ReadTestClusterBitmap16 : public ModelCommand {
public:
    ReadTestClusterBitmap16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap16 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBitmap16 : public ModelCommand {
public:
    WriteTestClusterBitmap16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeBitmap16WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster Bitmap16 Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterBitmap16 : public ModelCommand {
public:
    SubscribeAttributeTestClusterBitmap16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBitmap16WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.Bitmap16 response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap32
 */
class ReadTestClusterBitmap32 : public ModelCommand {
public:
    ReadTestClusterBitmap32()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap32 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap32 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBitmap32 : public ModelCommand {
public:
    WriteTestClusterBitmap32()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeBitmap32WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster Bitmap32 Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterBitmap32 : public ModelCommand {
public:
    SubscribeAttributeTestClusterBitmap32()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBitmap32WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.Bitmap32 response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap64
 */
class ReadTestClusterBitmap64 : public ModelCommand {
public:
    ReadTestClusterBitmap64()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap64 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap64 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterBitmap64 : public ModelCommand {
public:
    WriteTestClusterBitmap64()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeBitmap64WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster Bitmap64 Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterBitmap64 : public ModelCommand {
public:
    SubscribeAttributeTestClusterBitmap64()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBitmap64WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.Bitmap64 response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8u
 */
class ReadTestClusterInt8u : public ModelCommand {
public:
    ReadTestClusterInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt8u : public ModelCommand {
public:
    WriteTestClusterInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeInt8uWithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogError(chipTool, "TestCluster Int8u Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"TestCluster.Int8u response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16u
 */
class ReadTestClusterInt16u : public ModelCommand {
public:
    ReadTestClusterInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int16u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt16u : public ModelCommand {
public:
    WriteTestClusterInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeInt16uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int16u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterInt16u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt16uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int16u response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int24u
 */
class ReadTestClusterInt24u : public ModelCommand {
public:
    ReadTestClusterInt24u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int24u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt24uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int24u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int24u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt24u : public ModelCommand {
public:
    WriteTestClusterInt24u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int24u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeInt24uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int24u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterInt24u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt24u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int24u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt24uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int24u response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32u
 */
class ReadTestClusterInt32u : public ModelCommand {
public:
    ReadTestClusterInt32u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int32u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int32u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt32u : public ModelCommand {
public:
    WriteTestClusterInt32u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeInt32uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int32u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterInt32u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt32u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt32uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int32u response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int40u
 */
class ReadTestClusterInt40u : public ModelCommand {
public:
    ReadTestClusterInt40u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int40u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt40uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int40u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int40u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt40u : public ModelCommand {
public:
    WriteTestClusterInt40u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int40u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeInt40uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int40u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterInt40u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt40u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int40u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt40uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int40u response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int48u
 */
class ReadTestClusterInt48u : public ModelCommand {
public:
    ReadTestClusterInt48u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int48u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt48uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int48u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int48u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt48u : public ModelCommand {
public:
    WriteTestClusterInt48u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int48u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeInt48uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int48u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterInt48u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt48u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int48u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt48uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int48u response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int56u
 */
class ReadTestClusterInt56u : public ModelCommand {
public:
    ReadTestClusterInt56u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int56u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt56uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int56u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int56u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt56u : public ModelCommand {
public:
    WriteTestClusterInt56u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int56u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeInt56uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int56u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterInt56u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt56u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int56u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt56uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int56u response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64u
 */
class ReadTestClusterInt64u : public ModelCommand {
public:
    ReadTestClusterInt64u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int64u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int64u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt64u : public ModelCommand {
public:
    WriteTestClusterInt64u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeInt64uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int64u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterInt64u : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt64u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt64uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int64u response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8s
 */
class ReadTestClusterInt8s : public ModelCommand {
public:
    ReadTestClusterInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int8s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt8s : public ModelCommand {
public:
    WriteTestClusterInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];

        [cluster writeAttributeInt8sWithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogError(chipTool, "TestCluster Int8s Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeTestClusterInt8s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt8sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"TestCluster.Int8s response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16s
 */
class ReadTestClusterInt16s : public ModelCommand {
public:
    ReadTestClusterInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int16s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt16s : public ModelCommand {
public:
    WriteTestClusterInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeInt16sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int16s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeTestClusterInt16s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt16sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int16s response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int24s
 */
class ReadTestClusterInt24s : public ModelCommand {
public:
    ReadTestClusterInt24s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int24s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt24sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int24s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int24s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt24s : public ModelCommand {
public:
    WriteTestClusterInt24s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int24s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithInt:mValue];

        [cluster writeAttributeInt24sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int24s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    int32_t mValue;
};

class SubscribeAttributeTestClusterInt24s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt24s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int24s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt24sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int24s response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32s
 */
class ReadTestClusterInt32s : public ModelCommand {
public:
    ReadTestClusterInt32s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int32s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int32s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt32s : public ModelCommand {
public:
    WriteTestClusterInt32s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithInt:mValue];

        [cluster writeAttributeInt32sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int32s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    int32_t mValue;
};

class SubscribeAttributeTestClusterInt32s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt32s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt32sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int32s response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int40s
 */
class ReadTestClusterInt40s : public ModelCommand {
public:
    ReadTestClusterInt40s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int40s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt40sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int40s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int40s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt40s : public ModelCommand {
public:
    WriteTestClusterInt40s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int40s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeInt40sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int40s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterInt40s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt40s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int40s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt40sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int40s response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int48s
 */
class ReadTestClusterInt48s : public ModelCommand {
public:
    ReadTestClusterInt48s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int48s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt48sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int48s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int48s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt48s : public ModelCommand {
public:
    WriteTestClusterInt48s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int48s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeInt48sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int48s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterInt48s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt48s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int48s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt48sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int48s response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int56s
 */
class ReadTestClusterInt56s : public ModelCommand {
public:
    ReadTestClusterInt56s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int56s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt56sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int56s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int56s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt56s : public ModelCommand {
public:
    WriteTestClusterInt56s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int56s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeInt56sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int56s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterInt56s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt56s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int56s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt56sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int56s response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64s
 */
class ReadTestClusterInt64s : public ModelCommand {
public:
    ReadTestClusterInt64s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int64s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int64s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterInt64s : public ModelCommand {
public:
    WriteTestClusterInt64s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeInt64sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Int64s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterInt64s : public ModelCommand {
public:
    SubscribeAttributeTestClusterInt64s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInt64sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Int64s response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum8
 */
class ReadTestClusterEnum8 : public ModelCommand {
public:
    ReadTestClusterEnum8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Enum8 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Enum8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEnum8 : public ModelCommand {
public:
    WriteTestClusterEnum8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeEnum8WithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogError(chipTool, "TestCluster Enum8 Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterEnum8 : public ModelCommand {
public:
    SubscribeAttributeTestClusterEnum8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnum8WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"TestCluster.Enum8 response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum16
 */
class ReadTestClusterEnum16 : public ModelCommand {
public:
    ReadTestClusterEnum16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Enum16 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Enum16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEnum16 : public ModelCommand {
public:
    WriteTestClusterEnum16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeEnum16WithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster Enum16 Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterEnum16 : public ModelCommand {
public:
    SubscribeAttributeTestClusterEnum16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnum16WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.Enum16 response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FloatSingle
 */
class ReadTestClusterFloatSingle : public ModelCommand {
public:
    ReadTestClusterFloatSingle()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "float-single");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.FloatSingle response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster FloatSingle Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterFloatSingle : public ModelCommand {
public:
    WriteTestClusterFloatSingle()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "float-single");
        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithFloat:mValue];

        [cluster writeAttributeFloatSingleWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster FloatSingle Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    float mValue;
};

class SubscribeAttributeTestClusterFloatSingle : public ModelCommand {
public:
    SubscribeAttributeTestClusterFloatSingle()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "float-single");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFloatSingleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"TestCluster.FloatSingle response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FloatDouble
 */
class ReadTestClusterFloatDouble : public ModelCommand {
public:
    ReadTestClusterFloatDouble()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "float-double");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.FloatDouble response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster FloatDouble Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterFloatDouble : public ModelCommand {
public:
    WriteTestClusterFloatDouble()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "float-double");
        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000018) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithDouble:mValue];

        [cluster writeAttributeFloatDoubleWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster FloatDouble Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    double mValue;
};

class SubscribeAttributeTestClusterFloatDouble : public ModelCommand {
public:
    SubscribeAttributeTestClusterFloatDouble()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "float-double");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000018) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFloatDoubleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"TestCluster.FloatDouble response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OctetString
 */
class ReadTestClusterOctetString : public ModelCommand {
public:
    ReadTestClusterOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.OctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster OctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterOctetString : public ModelCommand {
public:
    WriteTestClusterOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSData * _Nonnull value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];

        [cluster writeAttributeOctetStringWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster OctetString Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"TestCluster.OctetString response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListInt8u
 */
class ReadTestClusterListInt8u : public ModelCommand {
public:
    ReadTestClusterListInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListInt8uWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListInt8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterListInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterListInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeListInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"TestCluster.ListInt8u response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListOctetString
 */
class ReadTestClusterListOctetString : public ModelCommand {
public:
    ReadTestClusterListOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterListOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterListOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeListOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.ListOctetString response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListStructOctetString
 */
class ReadTestClusterListStructOctetString : public ModelCommand {
public:
    ReadTestClusterListStructOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListStructOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListStructOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListStructOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterListStructOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterListStructOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeListStructOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TestCluster.ListStructOctetString response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongOctetString
 */
class ReadTestClusterLongOctetString : public ModelCommand {
public:
    ReadTestClusterLongOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLongOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.LongOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster LongOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterLongOctetString : public ModelCommand {
public:
    WriteTestClusterLongOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSData * _Nonnull value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];

        [cluster writeAttributeLongOctetStringWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "TestCluster LongOctetString Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterLongOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterLongOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLongOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.LongOctetString response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CharString
 */
class ReadTestClusterCharString : public ModelCommand {
public:
    ReadTestClusterCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.CharString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster CharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterCharString : public ModelCommand {
public:
    WriteTestClusterCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeCharStringWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TestCluster CharString Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterCharString : public ModelCommand {
public:
    SubscribeAttributeTestClusterCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCharStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"TestCluster.CharString response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongCharString
 */
class ReadTestClusterLongCharString : public ModelCommand {
public:
    ReadTestClusterLongCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "long-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLongCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.LongCharString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster LongCharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterLongCharString : public ModelCommand {
public:
    WriteTestClusterLongCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLongCharStringWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster LongCharString Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterLongCharString : public ModelCommand {
public:
    SubscribeAttributeTestClusterLongCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLongCharStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.LongCharString response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochUs
 */
class ReadTestClusterEpochUs : public ModelCommand {
public:
    ReadTestClusterEpochUs()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-us");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EpochUs response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EpochUs Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEpochUs : public ModelCommand {
public:
    WriteTestClusterEpochUs()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000020) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeEpochUsWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  err = [CHIPError errorToCHIPErrorCode:error];
                                  ChipLogError(chipTool, "TestCluster EpochUs Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterEpochUs : public ModelCommand {
public:
    SubscribeAttributeTestClusterEpochUs()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEpochUsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"TestCluster.EpochUs response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochS
 */
class ReadTestClusterEpochS : public ModelCommand {
public:
    ReadTestClusterEpochS()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EpochS response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EpochS Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEpochS : public ModelCommand {
public:
    WriteTestClusterEpochS()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeEpochSWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 err = [CHIPError errorToCHIPErrorCode:error];
                                 ChipLogError(chipTool, "TestCluster EpochS Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterEpochS : public ModelCommand {
public:
    SubscribeAttributeTestClusterEpochS()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEpochSWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                  params:params
                                 subscriptionEstablished:NULL
                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                               NSLog(@"TestCluster.EpochS response %@", [value description]);
                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorId
 */
class ReadTestClusterVendorId : public ModelCommand {
public:
    ReadTestClusterVendorId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.VendorId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster VendorId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterVendorId : public ModelCommand {
public:
    WriteTestClusterVendorId()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000022) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeVendorIdWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster VendorId Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    chip::VendorId mValue;
};

class SubscribeAttributeTestClusterVendorId : public ModelCommand {
public:
    SubscribeAttributeTestClusterVendorId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeVendorIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.VendorId response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListNullablesAndOptionalsStruct
 */
class ReadTestClusterListNullablesAndOptionalsStruct : public ModelCommand {
public:
    ReadTestClusterListNullablesAndOptionalsStruct()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListNullablesAndOptionalsStructWithCompletionHandler:^(
            NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListNullablesAndOptionalsStruct response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListNullablesAndOptionalsStruct Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterListNullablesAndOptionalsStruct : public ModelCommand {
public:
    SubscribeAttributeTestClusterListNullablesAndOptionalsStruct()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000023) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeListNullablesAndOptionalsStructWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                      params:params
                                                     subscriptionEstablished:NULL
                                                               reportHandler:^(
                                                                   NSArray * _Nullable value, NSError * _Nullable error) {
                                                                   NSLog(@"TestCluster.ListNullablesAndOptionalsStruct response %@",
                                                                       [value description]);
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnumAttr
 */
class ReadTestClusterEnumAttr : public ModelCommand {
public:
    ReadTestClusterEnumAttr()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EnumAttr response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EnumAttr Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterEnumAttr : public ModelCommand {
public:
    WriteTestClusterEnumAttr()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum-attr");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000024) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeEnumAttrWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   err = [CHIPError errorToCHIPErrorCode:error];
                                   ChipLogError(chipTool, "TestCluster EnumAttr Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterEnumAttr : public ModelCommand {
public:
    SubscribeAttributeTestClusterEnumAttr()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000024) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEnumAttrWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"TestCluster.EnumAttr response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StructAttr
 */
class ReadTestClusterStructAttr : public ModelCommand {
public:
    ReadTestClusterStructAttr()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "struct-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterStructAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStructAttrWithCompletionHandler:^(
            CHIPTestClusterClusterSimpleStruct * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.StructAttr response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster StructAttr Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterStructAttr : public ModelCommand {
public:
    WriteTestClusterStructAttr()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "struct-attr");
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterStructAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000025) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        CHIPTestClusterClusterSimpleStruct * value = [[CHIPTestClusterClusterSimpleStruct alloc] init];

        [cluster writeAttributeStructAttrWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TestCluster StructAttr Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
};

/*
 * Attribute RangeRestrictedInt8u
 */
class ReadTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000026) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster
            writeAttributeRangeRestrictedInt8uWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "TestCluster RangeRestrictedInt8u Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterRangeRestrictedInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000026) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRangeRestrictedInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.RangeRestrictedInt8u response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt8s
 */
class ReadTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000027) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt8s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000027) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];

        [cluster
            writeAttributeRangeRestrictedInt8sWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "TestCluster RangeRestrictedInt8s Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    SubscribeAttributeTestClusterRangeRestrictedInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000027) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRangeRestrictedInt8sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.RangeRestrictedInt8s response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt16u
 */
class ReadTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt16u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000028) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeRangeRestrictedInt16uWithValue:value
                                            completionHandler:^(NSError * _Nullable error) {
                                                err = [CHIPError errorToCHIPErrorCode:error];
                                                ChipLogError(
                                                    chipTool, "TestCluster RangeRestrictedInt16u Error: %s", chip::ErrorStr(err));
                                                SetCommandExitStatus(err);
                                            }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    SubscribeAttributeTestClusterRangeRestrictedInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000028) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRangeRestrictedInt16uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TestCluster.RangeRestrictedInt16u response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt16s
 */
class ReadTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt16s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000029) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeRangeRestrictedInt16sWithValue:value
                                            completionHandler:^(NSError * _Nullable error) {
                                                err = [CHIPError errorToCHIPErrorCode:error];
                                                ChipLogError(
                                                    chipTool, "TestCluster RangeRestrictedInt16s Error: %s", chip::ErrorStr(err));
                                                SetCommandExitStatus(err);
                                            }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    SubscribeAttributeTestClusterRangeRestrictedInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000029) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRangeRestrictedInt16sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TestCluster.RangeRestrictedInt16s response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListLongOctetString
 */
class ReadTestClusterListLongOctetString : public ModelCommand {
public:
    ReadTestClusterListLongOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeListLongOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListLongOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListLongOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterListLongOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterListLongOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-long-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterListLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeListLongOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.ListLongOctetString response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TimedWriteBoolean
 */
class ReadTestClusterTimedWriteBoolean : public ModelCommand {
public:
    ReadTestClusterTimedWriteBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "timed-write-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTimedWriteBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.TimedWriteBoolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster TimedWriteBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterTimedWriteBoolean : public ModelCommand {
public:
    WriteTestClusterTimedWriteBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "timed-write-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000030) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeTimedWriteBooleanWithValue:value
                                        completionHandler:^(NSError * _Nullable error) {
                                            err = [CHIPError errorToCHIPErrorCode:error];
                                            ChipLogError(chipTool, "TestCluster TimedWriteBoolean Error: %s", chip::ErrorStr(err));
                                            SetCommandExitStatus(err);
                                        }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterTimedWriteBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterTimedWriteBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "timed-write-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000030) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTimedWriteBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"TestCluster.TimedWriteBoolean response %@", [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneralErrorBoolean
 */
class ReadTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    ReadTestClusterGeneralErrorBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "general-error-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeGeneralErrorBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.GeneralErrorBoolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster GeneralErrorBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    WriteTestClusterGeneralErrorBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "general-error-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000031) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster
            writeAttributeGeneralErrorBooleanWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster GeneralErrorBoolean Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterGeneralErrorBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "general-error-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000031) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeGeneralErrorBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.GeneralErrorBoolean response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterErrorBoolean
 */
class ReadTestClusterClusterErrorBoolean : public ModelCommand {
public:
    ReadTestClusterClusterErrorBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterErrorBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ClusterErrorBoolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ClusterErrorBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterClusterErrorBoolean : public ModelCommand {
public:
    WriteTestClusterClusterErrorBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000032) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster
            writeAttributeClusterErrorBooleanWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster ClusterErrorBoolean Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterClusterErrorBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterClusterErrorBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000032) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClusterErrorBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.ClusterErrorBoolean response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Unsupported
 */
class ReadTestClusterUnsupported : public ModelCommand {
public:
    ReadTestClusterUnsupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "unsupported");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x000000FF) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeUnsupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Unsupported response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Unsupported Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterUnsupported : public ModelCommand {
public:
    WriteTestClusterUnsupported()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x000000FF) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeUnsupportedWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      err = [CHIPError errorToCHIPErrorCode:error];
                                      ChipLogError(chipTool, "TestCluster Unsupported Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterUnsupported : public ModelCommand {
public:
    SubscribeAttributeTestClusterUnsupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x000000FF) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeUnsupportedWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"TestCluster.Unsupported response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBoolean
 */
class ReadTestClusterNullableBoolean : public ModelCommand {
public:
    ReadTestClusterNullableBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBoolean response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBoolean : public ModelCommand {
public:
    WriteTestClusterNullableBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithBool:mValue];

        [cluster writeAttributeNullableBooleanWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "TestCluster NullableBoolean Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    bool mValue;
};

class SubscribeAttributeTestClusterNullableBoolean : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBooleanWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.NullableBoolean response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap8
 */
class ReadTestClusterNullableBitmap8 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap8 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBitmap8 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeNullableBitmap8WithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "TestCluster NullableBitmap8 Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableBitmap8 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBitmap8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBitmap8WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.NullableBitmap8 response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap16
 */
class ReadTestClusterNullableBitmap16 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap16 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBitmap16 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeNullableBitmap16WithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           err = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogError(chipTool, "TestCluster NullableBitmap16 Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterNullableBitmap16 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBitmap16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBitmap16WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.NullableBitmap16 response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap32
 */
class ReadTestClusterNullableBitmap32 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap32()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap32 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap32 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBitmap32 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap32()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeNullableBitmap32WithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           err = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogError(chipTool, "TestCluster NullableBitmap32 Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterNullableBitmap32 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBitmap32()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBitmap32WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.NullableBitmap32 response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap64
 */
class ReadTestClusterNullableBitmap64 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap64()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap64 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap64 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableBitmap64 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap64()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableBitmap64WithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           err = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogError(chipTool, "TestCluster NullableBitmap64 Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableBitmap64 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableBitmap64()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableBitmap64WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.NullableBitmap64 response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8u
 */
class ReadTestClusterNullableInt8u : public ModelCommand {
public:
    ReadTestClusterNullableInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt8u : public ModelCommand {
public:
    WriteTestClusterNullableInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeNullableInt8uWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        err = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "TestCluster NullableInt8u Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.NullableInt8u response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16u
 */
class ReadTestClusterNullableInt16u : public ModelCommand {
public:
    ReadTestClusterNullableInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt16u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt16u : public ModelCommand {
public:
    WriteTestClusterNullableInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeNullableInt16uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt16u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterNullableInt16u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt16uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt16u response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt24u
 */
class ReadTestClusterNullableInt24u : public ModelCommand {
public:
    ReadTestClusterNullableInt24u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int24u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt24uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt24u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt24u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt24u : public ModelCommand {
public:
    WriteTestClusterNullableInt24u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int24u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeNullableInt24uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt24u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterNullableInt24u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt24u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int24u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt24uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt24u response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32u
 */
class ReadTestClusterNullableInt32u : public ModelCommand {
public:
    ReadTestClusterNullableInt32u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt32u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt32u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt32u : public ModelCommand {
public:
    WriteTestClusterNullableInt32u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];

        [cluster writeAttributeNullableInt32uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt32u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint32_t mValue;
};

class SubscribeAttributeTestClusterNullableInt32u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt32u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt32uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt32u response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt40u
 */
class ReadTestClusterNullableInt40u : public ModelCommand {
public:
    ReadTestClusterNullableInt40u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int40u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt40uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt40u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt40u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt40u : public ModelCommand {
public:
    WriteTestClusterNullableInt40u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int40u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableInt40uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt40u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt40u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt40u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int40u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt40uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt40u response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt48u
 */
class ReadTestClusterNullableInt48u : public ModelCommand {
public:
    ReadTestClusterNullableInt48u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int48u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt48uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt48u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt48u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt48u : public ModelCommand {
public:
    WriteTestClusterNullableInt48u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int48u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableInt48uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt48u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt48u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt48u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int48u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt48uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt48u response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt56u
 */
class ReadTestClusterNullableInt56u : public ModelCommand {
public:
    ReadTestClusterNullableInt56u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int56u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt56uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt56u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt56u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt56u : public ModelCommand {
public:
    WriteTestClusterNullableInt56u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int56u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableInt56uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt56u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt56u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt56u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int56u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt56uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt56u response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64u
 */
class ReadTestClusterNullableInt64u : public ModelCommand {
public:
    ReadTestClusterNullableInt64u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt64u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt64u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt64u : public ModelCommand {
public:
    WriteTestClusterNullableInt64u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];

        [cluster writeAttributeNullableInt64uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt64u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt64u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt64u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt64uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt64u response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8s
 */
class ReadTestClusterNullableInt8s : public ModelCommand {
public:
    ReadTestClusterNullableInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt8s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt8s : public ModelCommand {
public:
    WriteTestClusterNullableInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithChar:mValue];

        [cluster writeAttributeNullableInt8sWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        err = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "TestCluster NullableInt8s Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return err;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeTestClusterNullableInt8s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt8sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.NullableInt8s response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16s
 */
class ReadTestClusterNullableInt16s : public ModelCommand {
public:
    ReadTestClusterNullableInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt16s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt16s : public ModelCommand {
public:
    WriteTestClusterNullableInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeNullableInt16sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt16s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeTestClusterNullableInt16s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt16sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt16s response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt24s
 */
class ReadTestClusterNullableInt24s : public ModelCommand {
public:
    ReadTestClusterNullableInt24s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int24s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt24sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt24s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt24s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt24s : public ModelCommand {
public:
    WriteTestClusterNullableInt24s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int24s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithInt:mValue];

        [cluster writeAttributeNullableInt24sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt24s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    int32_t mValue;
};

class SubscribeAttributeTestClusterNullableInt24s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt24s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int24s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt24sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt24s response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32s
 */
class ReadTestClusterNullableInt32s : public ModelCommand {
public:
    ReadTestClusterNullableInt32s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt32s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt32s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt32s : public ModelCommand {
public:
    WriteTestClusterNullableInt32s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithInt:mValue];

        [cluster writeAttributeNullableInt32sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt32s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    int32_t mValue;
};

class SubscribeAttributeTestClusterNullableInt32s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt32s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt32sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt32s response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt40s
 */
class ReadTestClusterNullableInt40s : public ModelCommand {
public:
    ReadTestClusterNullableInt40s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int40s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt40sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt40s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt40s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt40s : public ModelCommand {
public:
    WriteTestClusterNullableInt40s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int40s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeNullableInt40sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt40s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt40s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt40s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int40s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt40sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt40s response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt48s
 */
class ReadTestClusterNullableInt48s : public ModelCommand {
public:
    ReadTestClusterNullableInt48s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int48s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt48sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt48s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt48s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt48s : public ModelCommand {
public:
    WriteTestClusterNullableInt48s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int48s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeNullableInt48sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt48s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt48s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt48s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int48s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt48sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt48s response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt56s
 */
class ReadTestClusterNullableInt56s : public ModelCommand {
public:
    ReadTestClusterNullableInt56s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int56s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt56sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt56s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt56s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt56s : public ModelCommand {
public:
    WriteTestClusterNullableInt56s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int56s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeNullableInt56sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt56s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt56s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt56s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int56s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt56sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt56s response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64s
 */
class ReadTestClusterNullableInt64s : public ModelCommand {
public:
    ReadTestClusterNullableInt64s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt64s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt64s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableInt64s : public ModelCommand {
public:
    WriteTestClusterNullableInt64s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];

        [cluster writeAttributeNullableInt64sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableInt64s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    int64_t mValue;
};

class SubscribeAttributeTestClusterNullableInt64s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableInt64s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableInt64sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableInt64s response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum8
 */
class ReadTestClusterNullableEnum8 : public ModelCommand {
public:
    ReadTestClusterNullableEnum8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnum8 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnum8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableEnum8 : public ModelCommand {
public:
    WriteTestClusterNullableEnum8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeNullableEnum8WithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        err = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "TestCluster NullableEnum8 Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableEnum8 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableEnum8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableEnum8WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.NullableEnum8 response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum16
 */
class ReadTestClusterNullableEnum16 : public ModelCommand {
public:
    ReadTestClusterNullableEnum16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnum16 response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnum16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableEnum16 : public ModelCommand {
public:
    WriteTestClusterNullableEnum16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster writeAttributeNullableEnum16WithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableEnum16 Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterNullableEnum16 : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableEnum16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableEnum16WithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableEnum16 response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableFloatSingle
 */
class ReadTestClusterNullableFloatSingle : public ModelCommand {
public:
    ReadTestClusterNullableFloatSingle()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-float-single");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableFloatSingle response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableFloatSingle Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableFloatSingle : public ModelCommand {
public:
    WriteTestClusterNullableFloatSingle()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-float-single");
        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithFloat:mValue];

        [cluster
            writeAttributeNullableFloatSingleWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableFloatSingle Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    float mValue;
};

class SubscribeAttributeTestClusterNullableFloatSingle : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableFloatSingle()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-float-single");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableFloatSingleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableFloatSingle response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableFloatDouble
 */
class ReadTestClusterNullableFloatDouble : public ModelCommand {
public:
    ReadTestClusterNullableFloatDouble()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-float-double");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableFloatDouble response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableFloatDouble Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableFloatDouble : public ModelCommand {
public:
    WriteTestClusterNullableFloatDouble()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-float-double");
        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008018) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithDouble:mValue];

        [cluster
            writeAttributeNullableFloatDoubleWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableFloatDouble Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    double mValue;
};

class SubscribeAttributeTestClusterNullableFloatDouble : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableFloatDouble()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-float-double");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008018) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableFloatDoubleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableFloatDouble response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableOctetString
 */
class ReadTestClusterNullableOctetString : public ModelCommand {
public:
    ReadTestClusterNullableOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableOctetString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableOctetString : public ModelCommand {
public:
    WriteTestClusterNullableOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSData * _Nullable value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];

        [cluster
            writeAttributeNullableOctetStringWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableOctetString Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterNullableOctetString : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableOctetStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"TestCluster.NullableOctetString response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableCharString
 */
class ReadTestClusterNullableCharString : public ModelCommand {
public:
    ReadTestClusterNullableCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000801E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableCharString response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableCharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableCharString : public ModelCommand {
public:
    WriteTestClusterNullableCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000801E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSString * _Nullable value = [[NSString alloc] initWithBytes:mValue.data()
                                                              length:mValue.size()
                                                            encoding:NSUTF8StringEncoding];

        [cluster
            writeAttributeNullableCharStringWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        err = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "TestCluster NullableCharString Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return err;
    }

private:
    chip::ByteSpan mValue;
};

class SubscribeAttributeTestClusterNullableCharString : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000801E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableCharStringWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.NullableCharString response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnumAttr
 */
class ReadTestClusterNullableEnumAttr : public ModelCommand {
public:
    ReadTestClusterNullableEnumAttr()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnumAttr response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnumAttr Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableEnumAttr : public ModelCommand {
public:
    WriteTestClusterNullableEnumAttr()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008024) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeNullableEnumAttrWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           err = [CHIPError errorToCHIPErrorCode:error];
                                           ChipLogError(chipTool, "TestCluster NullableEnumAttr Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableEnumAttr : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableEnumAttr()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008024) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNullableEnumAttrWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"TestCluster.NullableEnumAttr response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableStruct
 */
class ReadTestClusterNullableStruct : public ModelCommand {
public:
    ReadTestClusterNullableStruct()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-struct");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008025) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableStructWithCompletionHandler:^(
            CHIPTestClusterClusterSimpleStruct * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableStruct response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableStruct Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableStruct : public ModelCommand {
public:
    WriteTestClusterNullableStruct()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-struct");
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008025) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        CHIPTestClusterClusterSimpleStruct * value = [[CHIPTestClusterClusterSimpleStruct alloc] init];

        [cluster writeAttributeNullableStructWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "TestCluster NullableStruct Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
};

/*
 * Attribute NullableRangeRestrictedInt8u
 */
class ReadTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt8u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008026) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:value
                                                   completionHandler:^(NSError * _Nullable error) {
                                                       err = [CHIPError errorToCHIPErrorCode:error];
                                                       ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8u Error: %s",
                                                           chip::ErrorStr(err));
                                                       SetCommandExitStatus(err);
                                                   }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008026) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableRangeRestrictedInt8uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"TestCluster.NullableRangeRestrictedInt8u response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt8s
 */
class ReadTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008027) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt8s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008027) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithChar:mValue];

        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:value
                                                   completionHandler:^(NSError * _Nullable error) {
                                                       err = [CHIPError errorToCHIPErrorCode:error];
                                                       ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8s Error: %s",
                                                           chip::ErrorStr(err));
                                                       SetCommandExitStatus(err);
                                                   }];
        return err;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008027) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableRangeRestrictedInt8sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"TestCluster.NullableRangeRestrictedInt8s response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt16u
 */
class ReadTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008028) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt16u response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008028) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];

        [cluster
            writeAttributeNullableRangeRestrictedInt16uWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   err = [CHIPError errorToCHIPErrorCode:error];
                                                   ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16u Error: %s",
                                                       chip::ErrorStr(err));
                                                   SetCommandExitStatus(err);
                                               }];
        return err;
    }

private:
    uint16_t mValue;
};

class SubscribeAttributeTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008028) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableRangeRestrictedInt16uWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:NULL
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"TestCluster.NullableRangeRestrictedInt16u response %@",
                                                                     [value description]);
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt16s
 */
class ReadTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt16s response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008029) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nullable value = [NSNumber numberWithShort:mValue];

        [cluster
            writeAttributeNullableRangeRestrictedInt16sWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   err = [CHIPError errorToCHIPErrorCode:error];
                                                   ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16s Error: %s",
                                                       chip::ErrorStr(err));
                                                   SetCommandExitStatus(err);
                                               }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    SubscribeAttributeTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008029) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNullableRangeRestrictedInt16sWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:NULL
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"TestCluster.NullableRangeRestrictedInt16s response %@",
                                                                     [value description]);
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadTestClusterServerGeneratedCommandList : public ModelCommand {
public:
    ReadTestClusterServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TestCluster.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TestCluster ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeTestClusterServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTestClusterServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TestCluster.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadTestClusterClientGeneratedCommandList : public ModelCommand {
public:
    ReadTestClusterClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TestCluster.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TestCluster ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeTestClusterClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTestClusterClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"TestCluster.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTestClusterAttributeList : public ModelCommand {
public:
    ReadTestClusterAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterAttributeList : public ModelCommand {
public:
    SubscribeAttributeTestClusterAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"TestCluster.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTestClusterClusterRevision : public ModelCommand {
public:
    ReadTestClusterClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTestClusterClusterRevision : public ModelCommand {
public:
    SubscribeAttributeTestClusterClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTestClusterClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TestCluster.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Thermostat                                                  | 0x0201 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SetpointRaiseLower                                                |   0x00 |
| * SetWeeklySchedule                                                 |   0x01 |
| * GetWeeklySchedule                                                 |   0x02 |
| * ClearWeeklySchedule                                               |   0x03 |
| * GetRelayStatusLog                                                 |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LocalTemperature                                                  | 0x0000 |
| * OutdoorTemperature                                                | 0x0001 |
| * Occupancy                                                         | 0x0002 |
| * AbsMinHeatSetpointLimit                                           | 0x0003 |
| * AbsMaxHeatSetpointLimit                                           | 0x0004 |
| * AbsMinCoolSetpointLimit                                           | 0x0005 |
| * AbsMaxCoolSetpointLimit                                           | 0x0006 |
| * PiCoolingDemand                                                   | 0x0007 |
| * PiHeatingDemand                                                   | 0x0008 |
| * HvacSystemTypeConfiguration                                       | 0x0009 |
| * LocalTemperatureCalibration                                       | 0x0010 |
| * OccupiedCoolingSetpoint                                           | 0x0011 |
| * OccupiedHeatingSetpoint                                           | 0x0012 |
| * UnoccupiedCoolingSetpoint                                         | 0x0013 |
| * UnoccupiedHeatingSetpoint                                         | 0x0014 |
| * MinHeatSetpointLimit                                              | 0x0015 |
| * MaxHeatSetpointLimit                                              | 0x0016 |
| * MinCoolSetpointLimit                                              | 0x0017 |
| * MaxCoolSetpointLimit                                              | 0x0018 |
| * MinSetpointDeadBand                                               | 0x0019 |
| * RemoteSensing                                                     | 0x001A |
| * ControlSequenceOfOperation                                        | 0x001B |
| * SystemMode                                                        | 0x001C |
| * AlarmMask                                                         | 0x001D |
| * ThermostatRunningMode                                             | 0x001E |
| * StartOfWeek                                                       | 0x0020 |
| * NumberOfWeeklyTransitions                                         | 0x0021 |
| * NumberOfDailyTransitions                                          | 0x0022 |
| * TemperatureSetpointHold                                           | 0x0023 |
| * TemperatureSetpointHoldDuration                                   | 0x0024 |
| * ThermostatProgrammingOperationMode                                | 0x0025 |
| * ThermostatRunningState                                            | 0x0029 |
| * SetpointChangeSource                                              | 0x0030 |
| * SetpointChangeAmount                                              | 0x0031 |
| * SetpointChangeSourceTimestamp                                     | 0x0032 |
| * AcType                                                            | 0x0040 |
| * AcCapacity                                                        | 0x0041 |
| * AcRefrigerantType                                                 | 0x0042 |
| * AcCompressor                                                      | 0x0043 |
| * AcErrorCode                                                       | 0x0044 |
| * AcLouverPosition                                                  | 0x0045 |
| * AcCoilTemperature                                                 | 0x0046 |
| * AcCapacityFormat                                                  | 0x0047 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearWeeklySchedule
 */
class ThermostatClearWeeklySchedule : public ModelCommand {
public:
    ThermostatClearWeeklySchedule()
        : ModelCommand("clear-weekly-schedule")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster clearWeeklyScheduleWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command GetRelayStatusLog
 */
class ThermostatGetRelayStatusLog : public ModelCommand {
public:
    ThermostatGetRelayStatusLog()
        : ModelCommand("get-relay-status-log")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster getRelayStatusLogWithCompletionHandler:^(
            CHIPThermostatClusterGetRelayStatusLogResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command GetWeeklySchedule
 */
class ThermostatGetWeeklySchedule : public ModelCommand {
public:
    ThermostatGetWeeklySchedule()
        : ModelCommand("get-weekly-schedule")
    {
        AddArgument("DaysToReturn", 0, UINT8_MAX, &mDaysToReturn);
        AddArgument("ModeToReturn", 0, UINT8_MAX, &mModeToReturn);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPThermostatClusterGetWeeklyScheduleParams alloc] init];
        params.daysToReturn = [NSNumber numberWithUnsignedChar:mDaysToReturn];
        params.modeToReturn = [NSNumber numberWithUnsignedChar:mModeToReturn];
        [cluster getWeeklyScheduleWithParams:params
                           completionHandler:^(
                               CHIPThermostatClusterGetWeeklyScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                               NSLog(@"Values: %@", values);
                               err = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return err;
    }

private:
    uint8_t mDaysToReturn;
    uint8_t mModeToReturn;
};

/*
 * Command SetWeeklySchedule
 */
class ThermostatSetWeeklySchedule : public ModelCommand {
public:
    ThermostatSetWeeklySchedule()
        : ModelCommand("set-weekly-schedule")
    {
        AddArgument("NumberOfTransitionsForSequence", 0, UINT8_MAX, &mNumberOfTransitionsForSequence);
        AddArgument("DayOfWeekForSequence", 0, UINT8_MAX, &mDayOfWeekForSequence);
        AddArgument("ModeForSequence", 0, UINT8_MAX, &mModeForSequence);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPThermostatClusterSetWeeklyScheduleParams alloc] init];
        params.numberOfTransitionsForSequence = [NSNumber numberWithUnsignedChar:mNumberOfTransitionsForSequence];
        params.dayOfWeekForSequence = [NSNumber numberWithUnsignedChar:mDayOfWeekForSequence];
        params.modeForSequence = [NSNumber numberWithUnsignedChar:mModeForSequence];
        // payload Array parsing is not supported yet
        [cluster setWeeklyScheduleWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               err = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return err;
    }

private:
    uint8_t mNumberOfTransitionsForSequence;
    uint8_t mDayOfWeekForSequence;
    uint8_t mModeForSequence;
};

/*
 * Command SetpointRaiseLower
 */
class ThermostatSetpointRaiseLower : public ModelCommand {
public:
    ThermostatSetpointRaiseLower()
        : ModelCommand("setpoint-raise-lower")
    {
        AddArgument("Mode", 0, UINT8_MAX, &mMode);
        AddArgument("Amount", INT8_MIN, INT8_MAX, &mAmount);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPThermostatClusterSetpointRaiseLowerParams alloc] init];
        params.mode = [NSNumber numberWithUnsignedChar:mMode];
        params.amount = [NSNumber numberWithChar:mAmount];
        [cluster setpointRaiseLowerWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    uint8_t mMode;
    int8_t mAmount;
};

/*
 * Attribute LocalTemperature
 */
class ReadThermostatLocalTemperature : public ModelCommand {
public:
    ReadThermostatLocalTemperature()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "local-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatLocalTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLocalTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.LocalTemperature response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat LocalTemperature Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatLocalTemperature : public ModelCommand {
public:
    SubscribeAttributeThermostatLocalTemperature()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "local-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatLocalTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLocalTemperatureWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"Thermostat.LocalTemperature response %@", [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinHeatSetpointLimit
 */
class ReadThermostatAbsMinHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMinHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeAbsMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMinHeatSetpointLimit response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMinHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatAbsMinHeatSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatAbsMinHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAbsMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAbsMinHeatSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.AbsMinHeatSetpointLimit response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxHeatSetpointLimit
 */
class ReadThermostatAbsMaxHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMaxHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeAbsMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMaxHeatSetpointLimit response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMaxHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatAbsMaxHeatSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatAbsMaxHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAbsMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAbsMaxHeatSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.AbsMaxHeatSetpointLimit response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinCoolSetpointLimit
 */
class ReadThermostatAbsMinCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMinCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeAbsMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMinCoolSetpointLimit response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMinCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatAbsMinCoolSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatAbsMinCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAbsMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAbsMinCoolSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.AbsMinCoolSetpointLimit response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxCoolSetpointLimit
 */
class ReadThermostatAbsMaxCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMaxCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeAbsMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMaxCoolSetpointLimit response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMaxCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatAbsMaxCoolSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatAbsMaxCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAbsMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAbsMaxCoolSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.AbsMaxCoolSetpointLimit response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedCoolingSetpoint
 */
class ReadThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    ReadThermostatOccupiedCoolingSetpoint()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeOccupiedCoolingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.OccupiedCoolingSetpoint response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat OccupiedCoolingSetpoint Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    WriteThermostatOccupiedCoolingSetpoint()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeOccupiedCoolingSetpointWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  err = [CHIPError errorToCHIPErrorCode:error];
                                                  ChipLogError(chipTool, "Thermostat OccupiedCoolingSetpoint Error: %s",
                                                      chip::ErrorStr(err));
                                                  SetCommandExitStatus(err);
                                              }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    SubscribeAttributeThermostatOccupiedCoolingSetpoint()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOccupiedCoolingSetpointWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.OccupiedCoolingSetpoint response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedHeatingSetpoint
 */
class ReadThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    ReadThermostatOccupiedHeatingSetpoint()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeOccupiedHeatingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.OccupiedHeatingSetpoint response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat OccupiedHeatingSetpoint Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    WriteThermostatOccupiedHeatingSetpoint()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster writeAttributeOccupiedHeatingSetpointWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  err = [CHIPError errorToCHIPErrorCode:error];
                                                  ChipLogError(chipTool, "Thermostat OccupiedHeatingSetpoint Error: %s",
                                                      chip::ErrorStr(err));
                                                  SetCommandExitStatus(err);
                                              }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    SubscribeAttributeThermostatOccupiedHeatingSetpoint()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOccupiedHeatingSetpointWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"Thermostat.OccupiedHeatingSetpoint response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinHeatSetpointLimit
 */
class ReadThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatMinHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinHeatSetpointLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinHeatSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    WriteThermostatMinHeatSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster
            writeAttributeMinHeatSetpointLimitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "Thermostat MinHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatMinHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinHeatSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.MinHeatSetpointLimit response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxHeatSetpointLimit
 */
class ReadThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatMaxHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MaxHeatSetpointLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MaxHeatSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    WriteThermostatMaxHeatSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster
            writeAttributeMaxHeatSetpointLimitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "Thermostat MaxHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatMaxHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxHeatSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.MaxHeatSetpointLimit response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCoolSetpointLimit
 */
class ReadThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatMinCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinCoolSetpointLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinCoolSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    WriteThermostatMinCoolSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster
            writeAttributeMinCoolSetpointLimitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "Thermostat MinCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatMinCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinCoolSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.MinCoolSetpointLimit response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCoolSetpointLimit
 */
class ReadThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatMaxCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MaxCoolSetpointLimit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MaxCoolSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    WriteThermostatMaxCoolSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000018) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];

        [cluster
            writeAttributeMaxCoolSetpointLimitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "Thermostat MaxCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    int16_t mValue;
};

class SubscribeAttributeThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    SubscribeAttributeThermostatMaxCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000018) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMaxCoolSetpointLimitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.MaxCoolSetpointLimit response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinSetpointDeadBand
 */
class ReadThermostatMinSetpointDeadBand : public ModelCommand {
public:
    ReadThermostatMinSetpointDeadBand()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMinSetpointDeadBandWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinSetpointDeadBand response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinSetpointDeadBand Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatMinSetpointDeadBand : public ModelCommand {
public:
    WriteThermostatMinSetpointDeadBand()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];

        [cluster
            writeAttributeMinSetpointDeadBandWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         err = [CHIPError errorToCHIPErrorCode:error];
                                         ChipLogError(chipTool, "Thermostat MinSetpointDeadBand Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return err;
    }

private:
    int8_t mValue;
};

class SubscribeAttributeThermostatMinSetpointDeadBand : public ModelCommand {
public:
    SubscribeAttributeThermostatMinSetpointDeadBand()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeMinSetpointDeadBandWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"Thermostat.MinSetpointDeadBand response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlSequenceOfOperation
 */
class ReadThermostatControlSequenceOfOperation : public ModelCommand {
public:
    ReadThermostatControlSequenceOfOperation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeControlSequenceOfOperationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.ControlSequenceOfOperation response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat ControlSequenceOfOperation Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class WriteThermostatControlSequenceOfOperation : public ModelCommand {
public:
    WriteThermostatControlSequenceOfOperation()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeControlSequenceOfOperationWithValue:value
                                                 completionHandler:^(NSError * _Nullable error) {
                                                     err = [CHIPError errorToCHIPErrorCode:error];
                                                     ChipLogError(chipTool, "Thermostat ControlSequenceOfOperation Error: %s",
                                                         chip::ErrorStr(err));
                                                     SetCommandExitStatus(err);
                                                 }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatControlSequenceOfOperation : public ModelCommand {
public:
    SubscribeAttributeThermostatControlSequenceOfOperation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeControlSequenceOfOperationWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"Thermostat.ControlSequenceOfOperation response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SystemMode
 */
class ReadThermostatSystemMode : public ModelCommand {
public:
    ReadThermostatSystemMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "system-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSystemModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.SystemMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat SystemMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatSystemMode : public ModelCommand {
public:
    WriteThermostatSystemMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeSystemModeWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "Thermostat SystemMode Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatSystemMode : public ModelCommand {
public:
    SubscribeAttributeThermostatSystemMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSystemModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Thermostat.SystemMode response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartOfWeek
 */
class ReadThermostatStartOfWeek : public ModelCommand {
public:
    ReadThermostatStartOfWeek()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-of-week");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatStartOfWeek() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStartOfWeekWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.StartOfWeek response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat StartOfWeek Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatStartOfWeek : public ModelCommand {
public:
    SubscribeAttributeThermostatStartOfWeek()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-of-week");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatStartOfWeek() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStartOfWeekWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"Thermostat.StartOfWeek response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfWeeklyTransitions
 */
class ReadThermostatNumberOfWeeklyTransitions : public ModelCommand {
public:
    ReadThermostatNumberOfWeeklyTransitions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfWeeklyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfWeeklyTransitionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.NumberOfWeeklyTransitions response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat NumberOfWeeklyTransitions Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatNumberOfWeeklyTransitions : public ModelCommand {
public:
    SubscribeAttributeThermostatNumberOfWeeklyTransitions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatNumberOfWeeklyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfWeeklyTransitionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"Thermostat.NumberOfWeeklyTransitions response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfDailyTransitions
 */
class ReadThermostatNumberOfDailyTransitions : public ModelCommand {
public:
    ReadThermostatNumberOfDailyTransitions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfDailyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeNumberOfDailyTransitionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.NumberOfDailyTransitions response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat NumberOfDailyTransitions Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatNumberOfDailyTransitions : public ModelCommand {
public:
    SubscribeAttributeThermostatNumberOfDailyTransitions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatNumberOfDailyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeNumberOfDailyTransitionsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"Thermostat.NumberOfDailyTransitions response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThermostatAttributeList : public ModelCommand {
public:
    ReadThermostatAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatAttributeList : public ModelCommand {
public:
    SubscribeAttributeThermostatAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"Thermostat.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadThermostatFeatureMap : public ModelCommand {
public:
    ReadThermostatFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatFeatureMap : public ModelCommand {
public:
    SubscribeAttributeThermostatFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"Thermostat.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatClusterRevision : public ModelCommand {
public:
    ReadThermostatClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatClusterRevision : public ModelCommand {
public:
    SubscribeAttributeThermostatClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"Thermostat.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThermostatUserInterfaceConfiguration                        | 0x0204 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TemperatureDisplayMode                                            | 0x0000 |
| * KeypadLockout                                                     | 0x0001 |
| * ScheduleProgrammingVisibility                                     | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute TemperatureDisplayMode
 */
class ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "temperature-display-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTemperatureDisplayModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.TemperatureDisplayMode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration TemperatureDisplayMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeTemperatureDisplayModeWithValue:value
                                             completionHandler:^(NSError * _Nullable error) {
                                                 err = [CHIPError errorToCHIPErrorCode:error];
                                                 ChipLogError(chipTool,
                                                     "ThermostatUserInterfaceConfiguration TemperatureDisplayMode Error: %s",
                                                     chip::ErrorStr(err));
                                                 SetCommandExitStatus(err);
                                             }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTemperatureDisplayModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ThermostatUserInterfaceConfiguration.TemperatureDisplayMode "
                                                                     @"response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute KeypadLockout
 */
class ReadThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "keypad-lockout");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeKeypadLockoutWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.KeypadLockout response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration KeypadLockout Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeKeypadLockoutWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        err = [CHIPError errorToCHIPErrorCode:error];
                                        ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration KeypadLockout Error: %s",
                                            chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeKeypadLockoutWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ThermostatUserInterfaceConfiguration.KeypadLockout response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ScheduleProgrammingVisibility
 */
class ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeScheduleProgrammingVisibilityWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.ScheduleProgrammingVisibility response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(
                chipTool, "ThermostatUserInterfaceConfiguration ScheduleProgrammingVisibility Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeScheduleProgrammingVisibilityWithValue:value
                                                    completionHandler:^(NSError * _Nullable error) {
                                                        err = [CHIPError errorToCHIPErrorCode:error];
                                                        ChipLogError(chipTool,
                                                            "ThermostatUserInterfaceConfiguration ScheduleProgrammingVisibility "
                                                            "Error: %s",
                                                            chip::ErrorStr(err));
                                                        SetCommandExitStatus(err);
                                                    }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeScheduleProgrammingVisibilityWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                         params:params
                                                        subscriptionEstablished:NULL
                                                                  reportHandler:^(
                                                                      NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                      NSLog(@"ThermostatUserInterfaceConfiguration."
                                                                            @"ScheduleProgrammingVisibility response %@",
                                                                          [value description]);
                                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadThermostatUserInterfaceConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThermostatUserInterfaceConfiguration.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(
                    chipTool, "ThermostatUserInterfaceConfiguration ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatUserInterfaceConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ThermostatUserInterfaceConfiguration."
                                                                    @"ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadThermostatUserInterfaceConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThermostatUserInterfaceConfiguration.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(
                    chipTool, "ThermostatUserInterfaceConfiguration ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThermostatUserInterfaceConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ThermostatUserInterfaceConfiguration."
                                                                    @"ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThermostatUserInterfaceConfigurationAttributeList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatUserInterfaceConfigurationAttributeList : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"ThermostatUserInterfaceConfiguration.AttributeList response %@",
                                                          [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeThermostatUserInterfaceConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThermostatUserInterfaceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThermostatUserInterfaceConfiguration.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThreadNetworkDiagnostics                                    | 0x0035 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Channel                                                           | 0x0000 |
| * RoutingRole                                                       | 0x0001 |
| * NetworkName                                                       | 0x0002 |
| * PanId                                                             | 0x0003 |
| * ExtendedPanId                                                     | 0x0004 |
| * MeshLocalPrefix                                                   | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * NeighborTableList                                                 | 0x0007 |
| * RouteTableList                                                    | 0x0008 |
| * PartitionId                                                       | 0x0009 |
| * Weighting                                                         | 0x000A |
| * DataVersion                                                       | 0x000B |
| * StableDataVersion                                                 | 0x000C |
| * LeaderRouterId                                                    | 0x000D |
| * DetachedRoleCount                                                 | 0x000E |
| * ChildRoleCount                                                    | 0x000F |
| * RouterRoleCount                                                   | 0x0010 |
| * LeaderRoleCount                                                   | 0x0011 |
| * AttachAttemptCount                                                | 0x0012 |
| * PartitionIdChangeCount                                            | 0x0013 |
| * BetterPartitionAttachAttemptCount                                 | 0x0014 |
| * ParentChangeCount                                                 | 0x0015 |
| * TxTotalCount                                                      | 0x0016 |
| * TxUnicastCount                                                    | 0x0017 |
| * TxBroadcastCount                                                  | 0x0018 |
| * TxAckRequestedCount                                               | 0x0019 |
| * TxAckedCount                                                      | 0x001A |
| * TxNoAckRequestedCount                                             | 0x001B |
| * TxDataCount                                                       | 0x001C |
| * TxDataPollCount                                                   | 0x001D |
| * TxBeaconCount                                                     | 0x001E |
| * TxBeaconRequestCount                                              | 0x001F |
| * TxOtherCount                                                      | 0x0020 |
| * TxRetryCount                                                      | 0x0021 |
| * TxDirectMaxRetryExpiryCount                                       | 0x0022 |
| * TxIndirectMaxRetryExpiryCount                                     | 0x0023 |
| * TxErrCcaCount                                                     | 0x0024 |
| * TxErrAbortCount                                                   | 0x0025 |
| * TxErrBusyChannelCount                                             | 0x0026 |
| * RxTotalCount                                                      | 0x0027 |
| * RxUnicastCount                                                    | 0x0028 |
| * RxBroadcastCount                                                  | 0x0029 |
| * RxDataCount                                                       | 0x002A |
| * RxDataPollCount                                                   | 0x002B |
| * RxBeaconCount                                                     | 0x002C |
| * RxBeaconRequestCount                                              | 0x002D |
| * RxOtherCount                                                      | 0x002E |
| * RxAddressFilteredCount                                            | 0x002F |
| * RxDestAddrFilteredCount                                           | 0x0030 |
| * RxDuplicatedCount                                                 | 0x0031 |
| * RxErrNoFrameCount                                                 | 0x0032 |
| * RxErrUnknownNeighborCount                                         | 0x0033 |
| * RxErrInvalidSrcAddrCount                                          | 0x0034 |
| * RxErrSecCount                                                     | 0x0035 |
| * RxErrFcsCount                                                     | 0x0036 |
| * RxErrOtherCount                                                   | 0x0037 |
| * ActiveTimestamp                                                   | 0x0038 |
| * PendingTimestamp                                                  | 0x0039 |
| * Delay                                                             | 0x003A |
| * SecurityPolicy                                                    | 0x003B |
| * ChannelMask                                                       | 0x003C |
| * OperationalDatasetComponents                                      | 0x003D |
| * ActiveNetworkFaultsList                                           | 0x003E |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * ConnectionStatus                                                  | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class ThreadNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    ThreadNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute Channel
 */
class ReadThreadNetworkDiagnosticsChannel : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChannel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChannelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Channel response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Channel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsChannel : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsChannel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeChannelWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.Channel response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RoutingRole
 */
class ReadThreadNetworkDiagnosticsRoutingRole : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRoutingRole()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "routing-role");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRoutingRole() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRoutingRoleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RoutingRole response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RoutingRole Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRoutingRole : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRoutingRole()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "routing-role");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRoutingRole() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRoutingRoleWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.RoutingRole response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NetworkName
 */
class ReadThreadNetworkDiagnosticsNetworkName : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsNetworkName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "network-name");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNetworkName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNetworkNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.NetworkName response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics NetworkName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsNetworkName : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsNetworkName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "network-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsNetworkName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNetworkNameWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.NetworkName response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PanId
 */
class ReadThreadNetworkDiagnosticsPanId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPanId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePanIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PanId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PanId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsPanId : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsPanId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePanIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"ThreadNetworkDiagnostics.PanId response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ExtendedPanId
 */
class ReadThreadNetworkDiagnosticsExtendedPanId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsExtendedPanId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "extended-pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsExtendedPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeExtendedPanIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ExtendedPanId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ExtendedPanId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsExtendedPanId : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsExtendedPanId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "extended-pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsExtendedPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeExtendedPanIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.ExtendedPanId response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeshLocalPrefix
 */
class ReadThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsMeshLocalPrefix()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsMeshLocalPrefix() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMeshLocalPrefixWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.MeshLocalPrefix response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics MeshLocalPrefix Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsMeshLocalPrefix()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsMeshLocalPrefix() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMeshLocalPrefixWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.MeshLocalPrefix response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadThreadNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.OverrunCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOverrunCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.OverrunCount response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NeighborTableList
 */
class ReadThreadNetworkDiagnosticsNeighborTableList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsNeighborTableList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "neighbor-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNeighborTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeNeighborTableListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.NeighborTableList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics NeighborTableList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsNeighborTableList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsNeighborTableList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "neighbor-table-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsNeighborTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeNeighborTableListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.NeighborTableList response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouteTableList
 */
class ReadThreadNetworkDiagnosticsRouteTableList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRouteTableList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "route-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouteTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRouteTableListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RouteTableList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RouteTableList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRouteTableList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRouteTableList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "route-table-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRouteTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRouteTableListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.RouteTableList response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionId
 */
class ReadThreadNetworkDiagnosticsPartitionId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPartitionId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartitionIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PartitionId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PartitionId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsPartitionId : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsPartitionId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "partition-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsPartitionId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartitionIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.PartitionId response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Weighting
 */
class ReadThreadNetworkDiagnosticsWeighting : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsWeighting()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "weighting");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsWeighting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWeightingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Weighting response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Weighting Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsWeighting : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsWeighting()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "weighting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsWeighting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWeightingWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"ThreadNetworkDiagnostics.Weighting response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DataVersion
 */
class ReadThreadNetworkDiagnosticsDataVersion : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDataVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDataVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.DataVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics DataVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsDataVersion : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsDataVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDataVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.DataVersion response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StableDataVersion
 */
class ReadThreadNetworkDiagnosticsStableDataVersion : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsStableDataVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "stable-data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsStableDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeStableDataVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.StableDataVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics StableDataVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsStableDataVersion : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsStableDataVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "stable-data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsStableDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeStableDataVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.StableDataVersion response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRouterId
 */
class ReadThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsLeaderRouterId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-router-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRouterId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLeaderRouterIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.LeaderRouterId response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics LeaderRouterId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsLeaderRouterId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "leader-router-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsLeaderRouterId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLeaderRouterIdWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.LeaderRouterId response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DetachedRoleCount
 */
class ReadThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDetachedRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "detached-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDetachedRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDetachedRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.DetachedRoleCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics DetachedRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsDetachedRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "detached-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsDetachedRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDetachedRoleCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.DetachedRoleCount response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChildRoleCount
 */
class ReadThreadNetworkDiagnosticsChildRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChildRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "child-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChildRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChildRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ChildRoleCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ChildRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsChildRoleCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsChildRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "child-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsChildRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeChildRoleCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.ChildRoleCount response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouterRoleCount
 */
class ReadThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRouterRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "router-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouterRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRouterRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RouterRoleCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RouterRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRouterRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "router-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRouterRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRouterRoleCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.RouterRoleCount response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRoleCount
 */
class ReadThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsLeaderRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLeaderRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.LeaderRoleCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics LeaderRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsLeaderRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "leader-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsLeaderRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLeaderRoleCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.LeaderRoleCount response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsAttachAttemptCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttachAttemptCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.AttachAttemptCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics AttachAttemptCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsAttachAttemptCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttachAttemptCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"ThreadNetworkDiagnostics.AttachAttemptCount response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionIdChangeCount
 */
class ReadThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPartitionIdChangeCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionIdChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePartitionIdChangeCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PartitionIdChangeCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PartitionIdChangeCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsPartitionIdChangeCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "partition-id-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsPartitionIdChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePartitionIdChangeCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ThreadNetworkDiagnostics.PartitionIdChangeCount response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BetterPartitionAttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBetterPartitionAttachAttemptCountWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.BetterPartitionAttachAttemptCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics BetterPartitionAttachAttemptCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBetterPartitionAttachAttemptCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                        params:params
                                                       subscriptionEstablished:NULL
                                                                 reportHandler:^(
                                                                     NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                     NSLog(@"ThreadNetworkDiagnostics."
                                                                           @"BetterPartitionAttachAttemptCount response %@",
                                                                         [value description]);
                                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ParentChangeCount
 */
class ReadThreadNetworkDiagnosticsParentChangeCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsParentChangeCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "parent-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsParentChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeParentChangeCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ParentChangeCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ParentChangeCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsParentChangeCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsParentChangeCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "parent-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsParentChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeParentChangeCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.ParentChangeCount response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxTotalCount
 */
class ReadThreadNetworkDiagnosticsTxTotalCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxTotalCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxTotalCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxTotalCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxTotalCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxTotalCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxTotalCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxTotalCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.TxTotalCount response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxUnicastCount
 */
class ReadThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxUnicastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxUnicastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxUnicastCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxUnicastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxUnicastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxUnicastCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.TxUnicastCount response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBroadcastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxBroadcastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBroadcastCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBroadcastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxBroadcastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000018) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxBroadcastCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ThreadNetworkDiagnostics.TxBroadcastCount response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxAckRequestedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxAckRequestedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxAckRequestedCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxAckRequestedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxAckRequestedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxAckRequestedCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ThreadNetworkDiagnostics.TxAckRequestedCount response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckedCount
 */
class ReadThreadNetworkDiagnosticsTxAckedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxAckedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-acked-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxAckedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxAckedCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxAckedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxAckedCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxAckedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-acked-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxAckedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxAckedCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.TxAckedCount response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxNoAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxNoAckRequestedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxNoAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxNoAckRequestedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxNoAckRequestedCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxNoAckRequestedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxNoAckRequestedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxNoAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxNoAckRequestedCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ThreadNetworkDiagnostics.TxNoAckRequestedCount response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataCount
 */
class ReadThreadNetworkDiagnosticsTxDataCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDataCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxDataCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxDataCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDataCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxDataCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxDataCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxDataCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.TxDataCount response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataPollCount
 */
class ReadThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDataPollCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxDataPollCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxDataPollCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDataPollCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxDataPollCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxDataPollCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.TxDataPollCount response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBeaconCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxBeaconCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBeaconCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBeaconCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxBeaconCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxBeaconCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.TxBeaconCount response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBeaconRequestCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxBeaconRequestCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBeaconRequestCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBeaconRequestCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxBeaconRequestCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxBeaconRequestCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ThreadNetworkDiagnostics.TxBeaconRequestCount response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxOtherCount
 */
class ReadThreadNetworkDiagnosticsTxOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxOtherCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxOtherCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxOtherCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.TxOtherCount response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxRetryCount
 */
class ReadThreadNetworkDiagnosticsTxRetryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxRetryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-retry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxRetryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxRetryCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxRetryCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxRetryCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxRetryCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxRetryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-retry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxRetryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxRetryCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.TxRetryCount response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeTxDirectMaxRetryExpiryCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.TxDirectMaxRetryExpiryCount response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDirectMaxRetryExpiryCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxDirectMaxRetryExpiryCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ThreadNetworkDiagnostics.TxDirectMaxRetryExpiryCount "
                                                                     @"response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxIndirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxIndirectMaxRetryExpiryCountWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxIndirectMaxRetryExpiryCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxIndirectMaxRetryExpiryCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000023) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxIndirectMaxRetryExpiryCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                         params:params
                                                        subscriptionEstablished:NULL
                                                                  reportHandler:^(
                                                                      NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                      NSLog(@"ThreadNetworkDiagnostics."
                                                                            @"TxIndirectMaxRetryExpiryCount response %@",
                                                                          [value description]);
                                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCcaCount
 */
class ReadThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrCcaCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrCcaCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxErrCcaCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrCcaCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrCcaCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxErrCcaCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxErrCcaCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000024) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTxErrCcaCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.TxErrCcaCount response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrAbortCount
 */
class ReadThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrAbortCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrAbortCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxErrAbortCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrAbortCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrAbortCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxErrAbortCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxErrAbortCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000025) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxErrAbortCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.TxErrAbortCount response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrBusyChannelCount
 */
class ReadThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrBusyChannelCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrBusyChannelCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTxErrBusyChannelCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrBusyChannelCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrBusyChannelCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsTxErrBusyChannelCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsTxErrBusyChannelCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000026) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTxErrBusyChannelCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ThreadNetworkDiagnostics.TxErrBusyChannelCount response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxTotalCount
 */
class ReadThreadNetworkDiagnosticsRxTotalCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxTotalCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000027) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxTotalCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxTotalCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxTotalCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxTotalCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxTotalCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000027) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxTotalCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.RxTotalCount response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxUnicastCount
 */
class ReadThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxUnicastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxUnicastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxUnicastCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxUnicastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxUnicastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000028) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxUnicastCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.RxUnicastCount response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBroadcastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxBroadcastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBroadcastCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBroadcastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxBroadcastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000029) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxBroadcastCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ThreadNetworkDiagnostics.RxBroadcastCount response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataCount
 */
class ReadThreadNetworkDiagnosticsRxDataCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDataCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxDataCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDataCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDataCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxDataCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxDataCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxDataCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.RxDataCount response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataPollCount
 */
class ReadThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDataPollCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxDataPollCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDataPollCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDataPollCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxDataPollCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxDataPollCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.RxDataPollCount response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBeaconCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxBeaconCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBeaconCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBeaconCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxBeaconCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxBeaconCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.RxBeaconCount response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBeaconRequestCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxBeaconRequestCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBeaconRequestCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBeaconRequestCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxBeaconRequestCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxBeaconRequestCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"ThreadNetworkDiagnostics.RxBeaconRequestCount response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxOtherCount
 */
class ReadThreadNetworkDiagnosticsRxOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxOtherCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxOtherCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxOtherCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                   params:params
                                  subscriptionEstablished:NULL
                                            reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                NSLog(@"ThreadNetworkDiagnostics.RxOtherCount response %@", [value description]);
                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxAddressFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxAddressFilteredCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxAddressFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxAddressFilteredCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxAddressFilteredCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxAddressFilteredCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxAddressFilteredCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxAddressFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxAddressFilteredCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"ThreadNetworkDiagnostics.RxAddressFilteredCount response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDestAddrFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeRxDestAddrFilteredCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxDestAddrFilteredCount response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDestAddrFilteredCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxDestAddrFilteredCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxDestAddrFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000030) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxDestAddrFilteredCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"ThreadNetworkDiagnostics.RxDestAddrFilteredCount response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDuplicatedCount
 */
class ReadThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDuplicatedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDuplicatedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxDuplicatedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDuplicatedCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDuplicatedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxDuplicatedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxDuplicatedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000031) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxDuplicatedCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.RxDuplicatedCount response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrNoFrameCount
 */
class ReadThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrNoFrameCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrNoFrameCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxErrNoFrameCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrNoFrameCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrNoFrameCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrNoFrameCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrNoFrameCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000032) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxErrNoFrameCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                        maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                             params:params
                                            subscriptionEstablished:NULL
                                                      reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                          NSLog(@"ThreadNetworkDiagnostics.RxErrNoFrameCount response %@",
                                                              [value description]);
                                                          SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                      }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrUnknownNeighborCount
 */
class ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000033) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeRxErrUnknownNeighborCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxErrUnknownNeighborCount response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrUnknownNeighborCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrUnknownNeighborCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrUnknownNeighborCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000033) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxErrUnknownNeighborCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(
                                                                 @"ThreadNetworkDiagnostics.RxErrUnknownNeighborCount response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrInvalidSrcAddrCount
 */
class ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000034) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeRxErrInvalidSrcAddrCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxErrInvalidSrcAddrCount response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrInvalidSrcAddrCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000034) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxErrInvalidSrcAddrCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"ThreadNetworkDiagnostics.RxErrInvalidSrcAddrCount response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrSecCount
 */
class ReadThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrSecCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrSecCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000035) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxErrSecCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrSecCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrSecCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrSecCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrSecCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000035) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxErrSecCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.RxErrSecCount response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrFcsCount
 */
class ReadThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrFcsCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrFcsCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000036) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxErrFcsCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrFcsCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrFcsCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrFcsCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrFcsCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000036) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeRxErrFcsCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.RxErrFcsCount response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrOtherCount
 */
class ReadThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000037) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRxErrOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrOtherCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsRxErrOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsRxErrOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000037) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRxErrOtherCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.RxErrOtherCount response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveTimestamp
 */
class ReadThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsActiveTimestamp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000038) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveTimestampWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ActiveTimestamp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ActiveTimestamp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsActiveTimestamp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsActiveTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000038) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveTimestampWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.ActiveTimestamp response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PendingTimestamp
 */
class ReadThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPendingTimestamp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pending-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPendingTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000039) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePendingTimestampWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PendingTimestamp response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PendingTimestamp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsPendingTimestamp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pending-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsPendingTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000039) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePendingTimestampWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                       maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                            params:params
                                           subscriptionEstablished:NULL
                                                     reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                         NSLog(@"ThreadNetworkDiagnostics.PendingTimestamp response %@",
                                                             [value description]);
                                                         SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                     }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Delay
 */
class ReadThreadNetworkDiagnosticsDelay : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDelay()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "delay");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDelay() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeDelayWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Delay response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Delay Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsDelay : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsDelay()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "delay");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsDelay() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeDelayWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"ThreadNetworkDiagnostics.Delay response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityPolicy
 */
class ReadThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsSecurityPolicy()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "security-policy");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsSecurityPolicy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSecurityPolicyWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.SecurityPolicy response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics SecurityPolicy Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsSecurityPolicy()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "security-policy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsSecurityPolicy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSecurityPolicyWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"ThreadNetworkDiagnostics.SecurityPolicy response %@",
                                                           [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelMask
 */
class ReadThreadNetworkDiagnosticsChannelMask : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChannelMask()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-mask");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannelMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChannelMaskWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ChannelMask response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ChannelMask Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsChannelMask : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsChannelMask()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsChannelMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeChannelMaskWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"ThreadNetworkDiagnostics.ChannelMask response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalDatasetComponents
 */
class ReadThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsOperationalDatasetComponents()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-dataset-components");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOperationalDatasetComponents() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeOperationalDatasetComponentsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.OperationalDatasetComponents response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics OperationalDatasetComponents Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsOperationalDatasetComponents()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operational-dataset-components");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsOperationalDatasetComponents() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOperationalDatasetComponentsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                              maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                   params:params
                                                  subscriptionEstablished:NULL
                                                            reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                                NSLog(@"ThreadNetworkDiagnostics.OperationalDatasetComponents "
                                                                      @"response %@",
                                                                    [value description]);
                                                                SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                            }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveNetworkFaultsList
 */
class ReadThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsActiveNetworkFaultsList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveNetworkFaultsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveNetworkFaultsListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ActiveNetworkFaultsList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ActiveNetworkFaultsList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsActiveNetworkFaultsList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-network-faults-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsActiveNetworkFaultsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeActiveNetworkFaultsListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"ThreadNetworkDiagnostics.ActiveNetworkFaultsList response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadThreadNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ThreadNetworkDiagnostics.ServerGeneratedCommandList response "
                                                                    @"%@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadThreadNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"ThreadNetworkDiagnostics.ClientGeneratedCommandList response "
                                                                    @"%@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThreadNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"ThreadNetworkDiagnostics.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadThreadNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"ThreadNetworkDiagnostics.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThreadNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeThreadNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeThreadNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeThreadNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"ThreadNetworkDiagnostics.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TimeFormatLocalization                                      | 0x002C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * HourFormat                                                        | 0x0000 |
| * ActiveCalendarType                                                | 0x0001 |
| * SupportedCalendarTypes                                            | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute HourFormat
 */
class ReadTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    ReadTimeFormatLocalizationHourFormat()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hour-format");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeHourFormatWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.HourFormat response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization HourFormat Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    WriteTimeFormatLocalizationHourFormat()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "hour-format");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeHourFormatWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     err = [CHIPError errorToCHIPErrorCode:error];
                                     ChipLogError(chipTool, "TimeFormatLocalization HourFormat Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationHourFormat()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hour-format");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeHourFormatWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"TimeFormatLocalization.HourFormat response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveCalendarType
 */
class ReadTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    ReadTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-calendar-type");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeActiveCalendarTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.ActiveCalendarType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization ActiveCalendarType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    WriteTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "active-calendar-type");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeActiveCalendarTypeWithValue:value
                                         completionHandler:^(NSError * _Nullable error) {
                                             err = [CHIPError errorToCHIPErrorCode:error];
                                             ChipLogError(chipTool, "TimeFormatLocalization ActiveCalendarType Error: %s",
                                                 chip::ErrorStr(err));
                                             SetCommandExitStatus(err);
                                         }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-calendar-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeActiveCalendarTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                         maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                              params:params
                                             subscriptionEstablished:NULL
                                                       reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                           NSLog(@"TimeFormatLocalization.ActiveCalendarType response %@",
                                                               [value description]);
                                                           SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                       }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedCalendarTypes
 */
class ReadTimeFormatLocalizationSupportedCalendarTypes : public ModelCommand {
public:
    ReadTimeFormatLocalizationSupportedCalendarTypes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-calendar-types");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationSupportedCalendarTypes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSupportedCalendarTypesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.SupportedCalendarTypes response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization SupportedCalendarTypes Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTimeFormatLocalizationSupportedCalendarTypes : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationSupportedCalendarTypes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-calendar-types");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationSupportedCalendarTypes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSupportedCalendarTypesWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"TimeFormatLocalization.SupportedCalendarTypes response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadTimeFormatLocalizationServerGeneratedCommandList : public ModelCommand {
public:
    ReadTimeFormatLocalizationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TimeFormatLocalization.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TimeFormatLocalization ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeTimeFormatLocalizationServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(
                                                                  @"TimeFormatLocalization.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadTimeFormatLocalizationClientGeneratedCommandList : public ModelCommand {
public:
    ReadTimeFormatLocalizationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TimeFormatLocalization.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TimeFormatLocalization ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeTimeFormatLocalizationClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(
                                                                  @"TimeFormatLocalization.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTimeFormatLocalizationClusterRevision : public ModelCommand {
public:
    ReadTimeFormatLocalizationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeTimeFormatLocalizationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeTimeFormatLocalizationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeTimeFormatLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"TimeFormatLocalization.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster UnitLocalization                                            | 0x002D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TemperatureUnit                                                   | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute TemperatureUnit
 */
class ReadUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    ReadUnitLocalizationTemperatureUnit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "temperature-unit");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTemperatureUnitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.TemperatureUnit response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization TemperatureUnit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    WriteUnitLocalizationTemperatureUnit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "temperature-unit");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeTemperatureUnitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          err = [CHIPError errorToCHIPErrorCode:error];
                                          ChipLogError(chipTool, "UnitLocalization TemperatureUnit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    SubscribeAttributeUnitLocalizationTemperatureUnit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "temperature-unit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTemperatureUnitWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"UnitLocalization.TemperatureUnit response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadUnitLocalizationAttributeList : public ModelCommand {
public:
    ReadUnitLocalizationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUnitLocalizationAttributeList : public ModelCommand {
public:
    SubscribeAttributeUnitLocalizationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUnitLocalizationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"UnitLocalization.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadUnitLocalizationFeatureMap : public ModelCommand {
public:
    ReadUnitLocalizationFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUnitLocalizationFeatureMap : public ModelCommand {
public:
    SubscribeAttributeUnitLocalizationFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUnitLocalizationFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"UnitLocalization.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadUnitLocalizationClusterRevision : public ModelCommand {
public:
    ReadUnitLocalizationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUnitLocalizationClusterRevision : public ModelCommand {
public:
    SubscribeAttributeUnitLocalizationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUnitLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"UnitLocalization.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster UserLabel                                                   | 0x0041 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute LabelList
 */
class ReadUserLabelLabelList : public ModelCommand {
public:
    ReadUserLabelLabelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeLabelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UserLabel.LabelList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UserLabel LabelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUserLabelLabelList : public ModelCommand {
public:
    SubscribeAttributeUserLabelLabelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "label-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUserLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeLabelListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"UserLabel.LabelList response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadUserLabelServerGeneratedCommandList : public ModelCommand {
public:
    ReadUserLabelServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"UserLabel.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "UserLabel ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeUserLabelServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeUserLabelServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUserLabelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"UserLabel.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadUserLabelClientGeneratedCommandList : public ModelCommand {
public:
    ReadUserLabelClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"UserLabel.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "UserLabel ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeUserLabelClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeUserLabelClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUserLabelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"UserLabel.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadUserLabelClusterRevision : public ModelCommand {
public:
    ReadUserLabelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UserLabel.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UserLabel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeUserLabelClusterRevision : public ModelCommand {
public:
    SubscribeAttributeUserLabelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeUserLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"UserLabel.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WakeOnLan                                                   | 0x0503 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MACAddress                                                        | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MACAddress
 */
class ReadWakeOnLanMACAddress : public ModelCommand {
public:
    ReadWakeOnLanMACAddress()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "macaddress");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanMACAddress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeMACAddressWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.MACAddress response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan MACAddress Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanMACAddress : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanMACAddress()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "macaddress");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanMACAddress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeMACAddressWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"WakeOnLan.MACAddress response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadWakeOnLanServerGeneratedCommandList : public ModelCommand {
public:
    ReadWakeOnLanServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WakeOnLan.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WakeOnLan ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"WakeOnLan.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadWakeOnLanClientGeneratedCommandList : public ModelCommand {
public:
    ReadWakeOnLanClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WakeOnLan.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WakeOnLan ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"WakeOnLan.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWakeOnLanAttributeList : public ModelCommand {
public:
    ReadWakeOnLanAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanAttributeList : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"WakeOnLan.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWakeOnLanClusterRevision : public ModelCommand {
public:
    ReadWakeOnLanClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWakeOnLanClusterRevision : public ModelCommand {
public:
    SubscribeAttributeWakeOnLanClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWakeOnLanClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WakeOnLan.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WiFiNetworkDiagnostics                                      | 0x0036 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Bssid                                                             | 0x0000 |
| * SecurityType                                                      | 0x0001 |
| * WiFiVersion                                                       | 0x0002 |
| * ChannelNumber                                                     | 0x0003 |
| * Rssi                                                              | 0x0004 |
| * BeaconLostCount                                                   | 0x0005 |
| * BeaconRxCount                                                     | 0x0006 |
| * PacketMulticastRxCount                                            | 0x0007 |
| * PacketMulticastTxCount                                            | 0x0008 |
| * PacketUnicastRxCount                                              | 0x0009 |
| * PacketUnicastTxCount                                              | 0x000A |
| * CurrentMaxRate                                                    | 0x000B |
| * OverrunCount                                                      | 0x000C |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * Disconnection                                                     | 0x0000 |
| * AssociationFailure                                                | 0x0001 |
| * ConnectionStatus                                                  | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class WiFiNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    WiFiNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute Bssid
 */
class ReadWiFiNetworkDiagnosticsBssid : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBssid()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bssid");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBssid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBssidWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.Bssid response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics Bssid Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsBssid : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsBssid()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bssid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsBssid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBssidWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                 params:params
                                subscriptionEstablished:NULL
                                          reportHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
                                              NSLog(@"WiFiNetworkDiagnostics.Bssid response %@", [value description]);
                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityType
 */
class ReadWiFiNetworkDiagnosticsSecurityType : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsSecurityType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "security-type");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsSecurityType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSecurityTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.SecurityType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics SecurityType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsSecurityType : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsSecurityType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "security-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsSecurityType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSecurityTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WiFiNetworkDiagnostics.SecurityType response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WiFiVersion
 */
class ReadWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsWiFiVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wi-fi-version");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsWiFiVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeWiFiVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.WiFiVersion response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics WiFiVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsWiFiVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wi-fi-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsWiFiVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeWiFiVersionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                       params:params
                                      subscriptionEstablished:NULL
                                                reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                    NSLog(@"WiFiNetworkDiagnostics.WiFiVersion response %@", [value description]);
                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelNumber
 */
class ReadWiFiNetworkDiagnosticsChannelNumber : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsChannelNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-number");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsChannelNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeChannelNumberWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.ChannelNumber response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics ChannelNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsChannelNumber : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsChannelNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsChannelNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeChannelNumberWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"WiFiNetworkDiagnostics.ChannelNumber response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Rssi
 */
class ReadWiFiNetworkDiagnosticsRssi : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsRssi()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rssi");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsRssi() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeRssiWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.Rssi response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics Rssi Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsRssi : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsRssi()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rssi");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsRssi() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeRssiWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                params:params
                               subscriptionEstablished:NULL
                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                             NSLog(@"WiFiNetworkDiagnostics.Rssi response %@", [value description]);
                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconLostCount
 */
class ReadWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBeaconLostCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-lost-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconLostCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBeaconLostCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.BeaconLostCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics BeaconLostCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsBeaconLostCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "beacon-lost-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsBeaconLostCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeBeaconLostCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WiFiNetworkDiagnostics.BeaconLostCount response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconRxCount
 */
class ReadWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBeaconRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeBeaconRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.BeaconRxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics BeaconRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsBeaconRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "beacon-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsBeaconRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeBeaconRxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"WiFiNetworkDiagnostics.BeaconRxCount response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketMulticastRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketMulticastRxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketMulticastRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketMulticastRxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"WiFiNetworkDiagnostics.PacketMulticastRxCount response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketMulticastTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketMulticastTxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketMulticastTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketMulticastTxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"WiFiNetworkDiagnostics.PacketMulticastTxCount response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketUnicastRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketUnicastRxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketUnicastRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketUnicastRxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"WiFiNetworkDiagnostics.PacketUnicastRxCount response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributePacketUnicastTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketUnicastTxCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketUnicastTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributePacketUnicastTxCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                params:params
                                               subscriptionEstablished:NULL
                                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                             NSLog(@"WiFiNetworkDiagnostics.PacketUnicastTxCount response %@",
                                                                 [value description]);
                                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMaxRate
 */
class ReadWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsCurrentMaxRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-max-rate");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsCurrentMaxRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentMaxRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.CurrentMaxRate response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics CurrentMaxRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsCurrentMaxRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-max-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsCurrentMaxRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentMaxRateWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                     params:params
                                    subscriptionEstablished:NULL
                                              reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                  NSLog(@"WiFiNetworkDiagnostics.CurrentMaxRate response %@", [value description]);
                                                  SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                              }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadWiFiNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.OverrunCount response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeOverrunCountWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WiFiNetworkDiagnostics.OverrunCount response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadWiFiNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WiFiNetworkDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WiFiNetworkDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(
                                                                  @"WiFiNetworkDiagnostics.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadWiFiNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WiFiNetworkDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WiFiNetworkDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(
                                                                  @"WiFiNetworkDiagnostics.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWiFiNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                    params:params
                                   subscriptionEstablished:NULL
                                             reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                 NSLog(@"WiFiNetworkDiagnostics.AttributeList response %@", [value description]);
                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadWiFiNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"WiFiNetworkDiagnostics.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWiFiNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWiFiNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    SubscribeAttributeWiFiNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWiFiNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WiFiNetworkDiagnostics.ClusterRevision response %@",
                                                            [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WindowCovering                                              | 0x0102 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * UpOrOpen                                                          |   0x00 |
| * DownOrClose                                                       |   0x01 |
| * StopMotion                                                        |   0x02 |
| * GoToLiftValue                                                     |   0x04 |
| * GoToLiftPercentage                                                |   0x05 |
| * GoToTiltValue                                                     |   0x07 |
| * GoToTiltPercentage                                                |   0x08 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Type                                                              | 0x0000 |
| * PhysicalClosedLimitLift                                           | 0x0001 |
| * PhysicalClosedLimitTilt                                           | 0x0002 |
| * CurrentPositionLift                                               | 0x0003 |
| * CurrentPositionTilt                                               | 0x0004 |
| * NumberOfActuationsLift                                            | 0x0005 |
| * NumberOfActuationsTilt                                            | 0x0006 |
| * ConfigStatus                                                      | 0x0007 |
| * CurrentPositionLiftPercentage                                     | 0x0008 |
| * CurrentPositionTiltPercentage                                     | 0x0009 |
| * OperationalStatus                                                 | 0x000A |
| * TargetPositionLiftPercent100ths                                   | 0x000B |
| * TargetPositionTiltPercent100ths                                   | 0x000C |
| * EndProductType                                                    | 0x000D |
| * CurrentPositionLiftPercent100ths                                  | 0x000E |
| * CurrentPositionTiltPercent100ths                                  | 0x000F |
| * InstalledOpenLimitLift                                            | 0x0010 |
| * InstalledClosedLimitLift                                          | 0x0011 |
| * InstalledOpenLimitTilt                                            | 0x0012 |
| * InstalledClosedLimitTilt                                          | 0x0013 |
| * Mode                                                              | 0x0017 |
| * SafetyStatus                                                      | 0x001A |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command DownOrClose
 */
class WindowCoveringDownOrClose : public ModelCommand {
public:
    WindowCoveringDownOrClose()
        : ModelCommand("down-or-close")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster downOrCloseWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command GoToLiftPercentage
 */
class WindowCoveringGoToLiftPercentage : public ModelCommand {
public:
    WindowCoveringGoToLiftPercentage()
        : ModelCommand("go-to-lift-percentage")
    {
        AddArgument("LiftPercentageValue", 0, UINT8_MAX, &mLiftPercentageValue);
        AddArgument("LiftPercent100thsValue", 0, UINT16_MAX, &mLiftPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftPercentageParams alloc] init];
        params.liftPercentageValue = [NSNumber numberWithUnsignedChar:mLiftPercentageValue];
        params.liftPercent100thsValue = [NSNumber numberWithUnsignedShort:mLiftPercent100thsValue];
        [cluster goToLiftPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    chip::Percent mLiftPercentageValue;
    chip::Percent100ths mLiftPercent100thsValue;
};

/*
 * Command GoToLiftValue
 */
class WindowCoveringGoToLiftValue : public ModelCommand {
public:
    WindowCoveringGoToLiftValue()
        : ModelCommand("go-to-lift-value")
    {
        AddArgument("LiftValue", 0, UINT16_MAX, &mLiftValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftValueParams alloc] init];
        params.liftValue = [NSNumber numberWithUnsignedShort:mLiftValue];
        [cluster goToLiftValueWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint16_t mLiftValue;
};

/*
 * Command GoToTiltPercentage
 */
class WindowCoveringGoToTiltPercentage : public ModelCommand {
public:
    WindowCoveringGoToTiltPercentage()
        : ModelCommand("go-to-tilt-percentage")
    {
        AddArgument("TiltPercentageValue", 0, UINT8_MAX, &mTiltPercentageValue);
        AddArgument("TiltPercent100thsValue", 0, UINT16_MAX, &mTiltPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltPercentageParams alloc] init];
        params.tiltPercentageValue = [NSNumber numberWithUnsignedChar:mTiltPercentageValue];
        params.tiltPercent100thsValue = [NSNumber numberWithUnsignedShort:mTiltPercent100thsValue];
        [cluster goToTiltPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                err = [CHIPError errorToCHIPErrorCode:error];
                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return err;
    }

private:
    chip::Percent mTiltPercentageValue;
    chip::Percent100ths mTiltPercent100thsValue;
};

/*
 * Command GoToTiltValue
 */
class WindowCoveringGoToTiltValue : public ModelCommand {
public:
    WindowCoveringGoToTiltValue()
        : ModelCommand("go-to-tilt-value")
    {
        AddArgument("TiltValue", 0, UINT16_MAX, &mTiltValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltValueParams alloc] init];
        params.tiltValue = [NSNumber numberWithUnsignedShort:mTiltValue];
        [cluster goToTiltValueWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           err = [CHIPError errorToCHIPErrorCode:error];
                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];
        return err;
    }

private:
    uint16_t mTiltValue;
};

/*
 * Command StopMotion
 */
class WindowCoveringStopMotion : public ModelCommand {
public:
    WindowCoveringStopMotion()
        : ModelCommand("stop-motion")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster stopMotionWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Command UpOrOpen
 */
class WindowCoveringUpOrOpen : public ModelCommand {
public:
    WindowCoveringUpOrOpen()
        : ModelCommand("up-or-open")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster upOrOpenWithCompletionHandler:^(NSError * _Nullable error) {
            err = [CHIPError errorToCHIPErrorCode:error];
            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }

private:
};

/*
 * Attribute Type
 */
class ReadWindowCoveringType : public ModelCommand {
public:
    ReadWindowCoveringType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.Type response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering Type Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringType : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                params:params
                               subscriptionEstablished:NULL
                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                             NSLog(@"WindowCovering.Type response %@", [value description]);
                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLift
 */
class ReadWindowCoveringCurrentPositionLift : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLift response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLift Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionLift : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentPositionLiftWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.CurrentPositionLift response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTilt
 */
class ReadWindowCoveringCurrentPositionTilt : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTilt response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTilt Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionTilt : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeCurrentPositionTiltWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.CurrentPositionTilt response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ConfigStatus
 */
class ReadWindowCoveringConfigStatus : public ModelCommand {
public:
    ReadWindowCoveringConfigStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "config-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringConfigStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeConfigStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.ConfigStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering ConfigStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringConfigStatus : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringConfigStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "config-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringConfigStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeConfigStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WindowCovering.ConfigStatus response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercentage
 */
class ReadWindowCoveringCurrentPositionLiftPercentage : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLiftPercentage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionLiftPercentageWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLiftPercentage response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLiftPercentage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionLiftPercentage : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionLiftPercentage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionLiftPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentPositionLiftPercentageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:NULL
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"WindowCovering.CurrentPositionLiftPercentage response %@",
                                                                     [value description]);
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercentage
 */
class ReadWindowCoveringCurrentPositionTiltPercentage : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTiltPercentage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionTiltPercentageWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTiltPercentage response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTiltPercentage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionTiltPercentage : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionTiltPercentage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionTiltPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentPositionTiltPercentageWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                               maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                    params:params
                                                   subscriptionEstablished:NULL
                                                             reportHandler:^(
                                                                 NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                 NSLog(@"WindowCovering.CurrentPositionTiltPercentage response %@",
                                                                     [value description]);
                                                                 SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                             }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalStatus
 */
class ReadWindowCoveringOperationalStatus : public ModelCommand {
public:
    ReadWindowCoveringOperationalStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringOperationalStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeOperationalStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.OperationalStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering OperationalStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringOperationalStatus : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringOperationalStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operational-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringOperationalStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeOperationalStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WindowCovering.OperationalStatus response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionLiftPercent100ths
 */
class ReadWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringTargetPositionLiftPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTargetPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.TargetPositionLiftPercent100ths response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering TargetPositionLiftPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringTargetPositionLiftPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringTargetPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTargetPositionLiftPercent100thsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                      params:params
                                                     subscriptionEstablished:NULL
                                                               reportHandler:^(
                                                                   NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                   NSLog(@"WindowCovering.TargetPositionLiftPercent100ths response "
                                                                         @"%@",
                                                                       [value description]);
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionTiltPercent100ths
 */
class ReadWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringTargetPositionTiltPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeTargetPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.TargetPositionTiltPercent100ths response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering TargetPositionTiltPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringTargetPositionTiltPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringTargetPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeTargetPositionTiltPercent100thsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                      params:params
                                                     subscriptionEstablished:NULL
                                                               reportHandler:^(
                                                                   NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                   NSLog(@"WindowCovering.TargetPositionTiltPercent100ths response "
                                                                         @"%@",
                                                                       [value description]);
                                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndProductType
 */
class ReadWindowCoveringEndProductType : public ModelCommand {
public:
    ReadWindowCoveringEndProductType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "end-product-type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringEndProductType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeEndProductTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.EndProductType response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering EndProductType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringEndProductType : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringEndProductType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "end-product-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringEndProductType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeEndProductTypeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                     maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                          params:params
                                         subscriptionEstablished:NULL
                                                   reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                       NSLog(@"WindowCovering.EndProductType response %@", [value description]);
                                                       SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                   }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercent100ths
 */
class ReadWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLiftPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLiftPercent100ths response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLiftPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionLiftPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentPositionLiftPercent100thsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                       params:params
                                                      subscriptionEstablished:NULL
                                                                reportHandler:^(
                                                                    NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                    NSLog(@"WindowCovering.CurrentPositionLiftPercent100ths "
                                                                          @"response %@",
                                                                        [value description]);
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercent100ths
 */
class ReadWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTiltPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTiltPercent100ths response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTiltPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringCurrentPositionTiltPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringCurrentPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeCurrentPositionTiltPercent100thsWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                                  maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                       params:params
                                                      subscriptionEstablished:NULL
                                                                reportHandler:^(
                                                                    NSNumber * _Nullable value, NSError * _Nullable error) {
                                                                    NSLog(@"WindowCovering.CurrentPositionTiltPercent100ths "
                                                                          @"response %@",
                                                                        [value description]);
                                                                    SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                                }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitLift
 */
class ReadWindowCoveringInstalledOpenLimitLift : public ModelCommand {
public:
    ReadWindowCoveringInstalledOpenLimitLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInstalledOpenLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.InstalledOpenLimitLift response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering InstalledOpenLimitLift Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringInstalledOpenLimitLift : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringInstalledOpenLimitLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringInstalledOpenLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInstalledOpenLimitLiftWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"WindowCovering.InstalledOpenLimitLift response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitLift
 */
class ReadWindowCoveringInstalledClosedLimitLift : public ModelCommand {
public:
    ReadWindowCoveringInstalledClosedLimitLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeInstalledClosedLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.InstalledClosedLimitLift response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering InstalledClosedLimitLift Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringInstalledClosedLimitLift : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringInstalledClosedLimitLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringInstalledClosedLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeInstalledClosedLimitLiftWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.InstalledClosedLimitLift response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitTilt
 */
class ReadWindowCoveringInstalledOpenLimitTilt : public ModelCommand {
public:
    ReadWindowCoveringInstalledOpenLimitTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeInstalledOpenLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.InstalledOpenLimitTilt response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering InstalledOpenLimitTilt Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringInstalledOpenLimitTilt : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringInstalledOpenLimitTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringInstalledOpenLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeInstalledOpenLimitTiltWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                             maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                  params:params
                                                 subscriptionEstablished:NULL
                                                           reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                               NSLog(@"WindowCovering.InstalledOpenLimitTilt response %@",
                                                                   [value description]);
                                                               SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                           }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitTilt
 */
class ReadWindowCoveringInstalledClosedLimitTilt : public ModelCommand {
public:
    ReadWindowCoveringInstalledClosedLimitTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeInstalledClosedLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.InstalledClosedLimitTilt response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering InstalledClosedLimitTilt Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringInstalledClosedLimitTilt : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringInstalledClosedLimitTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringInstalledClosedLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeInstalledClosedLimitTiltWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                          maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                               params:params
                                              subscriptionEstablished:NULL
                                                        reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                            NSLog(@"WindowCovering.InstalledClosedLimitTilt response %@",
                                                                [value description]);
                                                            SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                        }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Mode
 */
class ReadWindowCoveringMode : public ModelCommand {
public:
    ReadWindowCoveringMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "mode");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.Mode response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering Mode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class WriteWindowCoveringMode : public ModelCommand {
public:
    WriteWindowCoveringMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) WriteAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];

        [cluster writeAttributeModeWithValue:value
                           completionHandler:^(NSError * _Nullable error) {
                               err = [CHIPError errorToCHIPErrorCode:error];
                               ChipLogError(chipTool, "WindowCovering Mode Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return err;
    }

private:
    uint8_t mValue;
};

class SubscribeAttributeWindowCoveringMode : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeModeWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                           maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                params:params
                               subscriptionEstablished:NULL
                                         reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                             NSLog(@"WindowCovering.Mode response %@", [value description]);
                                             SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                         }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SafetyStatus
 */
class ReadWindowCoveringSafetyStatus : public ModelCommand {
public:
    ReadWindowCoveringSafetyStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeSafetyStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.SafetyStatus response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering SafetyStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringSafetyStatus : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringSafetyStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeSafetyStatusWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                   maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                        params:params
                                       subscriptionEstablished:NULL
                                                 reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                     NSLog(@"WindowCovering.SafetyStatus response %@", [value description]);
                                                     SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                 }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadWindowCoveringServerGeneratedCommandList : public ModelCommand {
public:
    ReadWindowCoveringServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.ServerGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringServerGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeServerGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"WindowCovering.ServerGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadWindowCoveringClientGeneratedCommandList : public ModelCommand {
public:
    ReadWindowCoveringClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.ClientGeneratedCommandList response %@", [value description]);
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringClientGeneratedCommandList : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster
            subscribeAttributeClientGeneratedCommandListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                            maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                                 params:params
                                                subscriptionEstablished:NULL
                                                          reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                              NSLog(@"WindowCovering.ClientGeneratedCommandList response %@",
                                                                  [value description]);
                                                              SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                          }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWindowCoveringAttributeList : public ModelCommand {
public:
    ReadWindowCoveringAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.AttributeList response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringAttributeList : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeAttributeListWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                    maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                         params:params
                                        subscriptionEstablished:NULL
                                                  reportHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                                                      NSLog(@"WindowCovering.AttributeList response %@", [value description]);
                                                      SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                  }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadWindowCoveringFeatureMap : public ModelCommand {
public:
    ReadWindowCoveringFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.FeatureMap response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringFeatureMap : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeFeatureMapWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                 maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                      params:params
                                     subscriptionEstablished:NULL
                                               reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                   NSLog(@"WindowCovering.FeatureMap response %@", [value description]);
                                                   SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                               }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWindowCoveringClusterRevision : public ModelCommand {
public:
    ReadWindowCoveringClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIP_ERROR __block err = CHIP_NO_ERROR;
        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.ClusterRevision response %@", [value description]);
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return err;
    }
};

class SubscribeAttributeWindowCoveringClusterRevision : public ModelCommand {
public:
    SubscribeAttributeWindowCoveringClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~SubscribeAttributeWindowCoveringClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);
        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];
        CHIPSubscribeParams * params = [[CHIPSubscribeParams alloc] init];
        [cluster subscribeAttributeClusterRevisionWithMinInterval:[NSNumber numberWithUnsignedInt:mMinInterval]
                                                      maxInterval:[NSNumber numberWithUnsignedInt:mMaxInterval]
                                                           params:params
                                          subscriptionEstablished:NULL
                                                    reportHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                                                        NSLog(@"WindowCovering.ClusterRevision response %@", [value description]);
                                                        SetCommandExitStatus([CHIPError errorToCHIPErrorCode:error]);
                                                    }];

        return CHIP_NO_ERROR;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Register all Clusters commands                                               |
\*----------------------------------------------------------------------------*/
void registerClusterAccessControl(Commands & commands)
{
    const char * clusterName = "AccessControl";

    commands_list clusterCommands = {
        make_unique<ReadAccessControlAcl>(), //
        make_unique<SubscribeAttributeAccessControlAcl>(), //
        make_unique<ReadAccessControlExtension>(), //
        make_unique<SubscribeAttributeAccessControlExtension>(), //
        make_unique<ReadAccessControlServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAccessControlServerGeneratedCommandList>(), //
        make_unique<ReadAccessControlClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAccessControlClientGeneratedCommandList>(), //
        make_unique<ReadAccessControlAttributeList>(), //
        make_unique<SubscribeAttributeAccessControlAttributeList>(), //
        make_unique<ReadAccessControlClusterRevision>(), //
        make_unique<SubscribeAttributeAccessControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAccountLogin(Commands & commands)
{
    const char * clusterName = "AccountLogin";

    commands_list clusterCommands = {
        make_unique<AccountLoginGetSetupPIN>(), //
        make_unique<AccountLoginLogin>(), //
        make_unique<AccountLoginLogout>(), //
        make_unique<ReadAccountLoginServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAccountLoginServerGeneratedCommandList>(), //
        make_unique<ReadAccountLoginClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAccountLoginClientGeneratedCommandList>(), //
        make_unique<ReadAccountLoginAttributeList>(), //
        make_unique<SubscribeAttributeAccountLoginAttributeList>(), //
        make_unique<ReadAccountLoginClusterRevision>(), //
        make_unique<SubscribeAttributeAccountLoginClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAdministratorCommissioning(Commands & commands)
{
    const char * clusterName = "AdministratorCommissioning";

    commands_list clusterCommands = {
        make_unique<AdministratorCommissioningOpenBasicCommissioningWindow>(), //
        make_unique<AdministratorCommissioningOpenCommissioningWindow>(), //
        make_unique<AdministratorCommissioningRevokeCommissioning>(), //
        make_unique<ReadAdministratorCommissioningWindowStatus>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningWindowStatus>(), //
        make_unique<ReadAdministratorCommissioningAdminFabricIndex>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningAdminFabricIndex>(), //
        make_unique<ReadAdministratorCommissioningAdminVendorId>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningAdminVendorId>(), //
        make_unique<ReadAdministratorCommissioningServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningServerGeneratedCommandList>(), //
        make_unique<ReadAdministratorCommissioningClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningClientGeneratedCommandList>(), //
        make_unique<ReadAdministratorCommissioningAttributeList>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningAttributeList>(), //
        make_unique<ReadAdministratorCommissioningClusterRevision>(), //
        make_unique<SubscribeAttributeAdministratorCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationBasic(Commands & commands)
{
    const char * clusterName = "ApplicationBasic";

    commands_list clusterCommands = {
        make_unique<ReadApplicationBasicVendorName>(), //
        make_unique<SubscribeAttributeApplicationBasicVendorName>(), //
        make_unique<ReadApplicationBasicVendorID>(), //
        make_unique<SubscribeAttributeApplicationBasicVendorID>(), //
        make_unique<ReadApplicationBasicApplicationName>(), //
        make_unique<SubscribeAttributeApplicationBasicApplicationName>(), //
        make_unique<ReadApplicationBasicProductID>(), //
        make_unique<SubscribeAttributeApplicationBasicProductID>(), //
        make_unique<ReadApplicationBasicStatus>(), //
        make_unique<SubscribeAttributeApplicationBasicStatus>(), //
        make_unique<ReadApplicationBasicApplicationVersion>(), //
        make_unique<SubscribeAttributeApplicationBasicApplicationVersion>(), //
        make_unique<ReadApplicationBasicAllowedVendorList>(), //
        make_unique<SubscribeAttributeApplicationBasicAllowedVendorList>(), //
        make_unique<ReadApplicationBasicServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeApplicationBasicServerGeneratedCommandList>(), //
        make_unique<ReadApplicationBasicClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeApplicationBasicClientGeneratedCommandList>(), //
        make_unique<ReadApplicationBasicAttributeList>(), //
        make_unique<SubscribeAttributeApplicationBasicAttributeList>(), //
        make_unique<ReadApplicationBasicClusterRevision>(), //
        make_unique<SubscribeAttributeApplicationBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationLauncher(Commands & commands)
{
    const char * clusterName = "ApplicationLauncher";

    commands_list clusterCommands = {
        make_unique<ApplicationLauncherHideApp>(), //
        make_unique<ApplicationLauncherLaunchApp>(), //
        make_unique<ApplicationLauncherStopApp>(), //
        make_unique<ReadApplicationLauncherCatalogList>(), //
        make_unique<SubscribeAttributeApplicationLauncherCatalogList>(), //
        make_unique<ReadApplicationLauncherServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeApplicationLauncherServerGeneratedCommandList>(), //
        make_unique<ReadApplicationLauncherClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeApplicationLauncherClientGeneratedCommandList>(), //
        make_unique<ReadApplicationLauncherAttributeList>(), //
        make_unique<SubscribeAttributeApplicationLauncherAttributeList>(), //
        make_unique<ReadApplicationLauncherClusterRevision>(), //
        make_unique<SubscribeAttributeApplicationLauncherClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAudioOutput(Commands & commands)
{
    const char * clusterName = "AudioOutput";

    commands_list clusterCommands = {
        make_unique<AudioOutputRenameOutput>(), //
        make_unique<AudioOutputSelectOutput>(), //
        make_unique<ReadAudioOutputOutputList>(), //
        make_unique<SubscribeAttributeAudioOutputOutputList>(), //
        make_unique<ReadAudioOutputCurrentOutput>(), //
        make_unique<SubscribeAttributeAudioOutputCurrentOutput>(), //
        make_unique<ReadAudioOutputServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAudioOutputServerGeneratedCommandList>(), //
        make_unique<ReadAudioOutputClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeAudioOutputClientGeneratedCommandList>(), //
        make_unique<ReadAudioOutputAttributeList>(), //
        make_unique<SubscribeAttributeAudioOutputAttributeList>(), //
        make_unique<ReadAudioOutputClusterRevision>(), //
        make_unique<SubscribeAttributeAudioOutputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBarrierControl(Commands & commands)
{
    const char * clusterName = "BarrierControl";

    commands_list clusterCommands = {
        make_unique<BarrierControlBarrierControlGoToPercent>(), //
        make_unique<BarrierControlBarrierControlStop>(), //
        make_unique<ReadBarrierControlBarrierMovingState>(), //
        make_unique<SubscribeAttributeBarrierControlBarrierMovingState>(), //
        make_unique<ReadBarrierControlBarrierSafetyStatus>(), //
        make_unique<SubscribeAttributeBarrierControlBarrierSafetyStatus>(), //
        make_unique<ReadBarrierControlBarrierCapabilities>(), //
        make_unique<SubscribeAttributeBarrierControlBarrierCapabilities>(), //
        make_unique<ReadBarrierControlBarrierPosition>(), //
        make_unique<SubscribeAttributeBarrierControlBarrierPosition>(), //
        make_unique<ReadBarrierControlServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBarrierControlServerGeneratedCommandList>(), //
        make_unique<ReadBarrierControlClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBarrierControlClientGeneratedCommandList>(), //
        make_unique<ReadBarrierControlAttributeList>(), //
        make_unique<SubscribeAttributeBarrierControlAttributeList>(), //
        make_unique<ReadBarrierControlClusterRevision>(), //
        make_unique<SubscribeAttributeBarrierControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBasic(Commands & commands)
{
    const char * clusterName = "Basic";

    commands_list clusterCommands = {
        make_unique<ReadBasicDataModelRevision>(), //
        make_unique<SubscribeAttributeBasicDataModelRevision>(), //
        make_unique<ReadBasicVendorName>(), //
        make_unique<SubscribeAttributeBasicVendorName>(), //
        make_unique<ReadBasicVendorID>(), //
        make_unique<SubscribeAttributeBasicVendorID>(), //
        make_unique<ReadBasicProductName>(), //
        make_unique<SubscribeAttributeBasicProductName>(), //
        make_unique<ReadBasicProductID>(), //
        make_unique<SubscribeAttributeBasicProductID>(), //
        make_unique<ReadBasicNodeLabel>(), //
        make_unique<WriteBasicNodeLabel>(), //
        make_unique<SubscribeAttributeBasicNodeLabel>(), //
        make_unique<ReadBasicLocation>(), //
        make_unique<WriteBasicLocation>(), //
        make_unique<SubscribeAttributeBasicLocation>(), //
        make_unique<ReadBasicHardwareVersion>(), //
        make_unique<SubscribeAttributeBasicHardwareVersion>(), //
        make_unique<ReadBasicHardwareVersionString>(), //
        make_unique<SubscribeAttributeBasicHardwareVersionString>(), //
        make_unique<ReadBasicSoftwareVersion>(), //
        make_unique<SubscribeAttributeBasicSoftwareVersion>(), //
        make_unique<ReadBasicSoftwareVersionString>(), //
        make_unique<SubscribeAttributeBasicSoftwareVersionString>(), //
        make_unique<ReadBasicManufacturingDate>(), //
        make_unique<SubscribeAttributeBasicManufacturingDate>(), //
        make_unique<ReadBasicPartNumber>(), //
        make_unique<SubscribeAttributeBasicPartNumber>(), //
        make_unique<ReadBasicProductURL>(), //
        make_unique<SubscribeAttributeBasicProductURL>(), //
        make_unique<ReadBasicProductLabel>(), //
        make_unique<SubscribeAttributeBasicProductLabel>(), //
        make_unique<ReadBasicSerialNumber>(), //
        make_unique<SubscribeAttributeBasicSerialNumber>(), //
        make_unique<ReadBasicLocalConfigDisabled>(), //
        make_unique<WriteBasicLocalConfigDisabled>(), //
        make_unique<SubscribeAttributeBasicLocalConfigDisabled>(), //
        make_unique<ReadBasicReachable>(), //
        make_unique<SubscribeAttributeBasicReachable>(), //
        make_unique<ReadBasicUniqueID>(), //
        make_unique<SubscribeAttributeBasicUniqueID>(), //
        make_unique<ReadBasicServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBasicServerGeneratedCommandList>(), //
        make_unique<ReadBasicClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBasicClientGeneratedCommandList>(), //
        make_unique<ReadBasicAttributeList>(), //
        make_unique<SubscribeAttributeBasicAttributeList>(), //
        make_unique<ReadBasicClusterRevision>(), //
        make_unique<SubscribeAttributeBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinaryInputBasic(Commands & commands)
{
    const char * clusterName = "BinaryInputBasic";

    commands_list clusterCommands = {
        make_unique<ReadBinaryInputBasicOutOfService>(), //
        make_unique<WriteBinaryInputBasicOutOfService>(), //
        make_unique<SubscribeAttributeBinaryInputBasicOutOfService>(), //
        make_unique<ReadBinaryInputBasicPresentValue>(), //
        make_unique<WriteBinaryInputBasicPresentValue>(), //
        make_unique<SubscribeAttributeBinaryInputBasicPresentValue>(), //
        make_unique<ReadBinaryInputBasicStatusFlags>(), //
        make_unique<SubscribeAttributeBinaryInputBasicStatusFlags>(), //
        make_unique<ReadBinaryInputBasicServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBinaryInputBasicServerGeneratedCommandList>(), //
        make_unique<ReadBinaryInputBasicClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBinaryInputBasicClientGeneratedCommandList>(), //
        make_unique<ReadBinaryInputBasicAttributeList>(), //
        make_unique<SubscribeAttributeBinaryInputBasicAttributeList>(), //
        make_unique<ReadBinaryInputBasicClusterRevision>(), //
        make_unique<SubscribeAttributeBinaryInputBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinding(Commands & commands)
{
    const char * clusterName = "Binding";

    commands_list clusterCommands = {
        make_unique<ReadBindingBinding>(), //
        make_unique<SubscribeAttributeBindingBinding>(), //
        make_unique<ReadBindingServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBindingServerGeneratedCommandList>(), //
        make_unique<ReadBindingClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBindingClientGeneratedCommandList>(), //
        make_unique<ReadBindingAttributeList>(), //
        make_unique<SubscribeAttributeBindingAttributeList>(), //
        make_unique<ReadBindingClusterRevision>(), //
        make_unique<SubscribeAttributeBindingClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBooleanState(Commands & commands)
{
    const char * clusterName = "BooleanState";

    commands_list clusterCommands = {
        make_unique<ReadBooleanStateStateValue>(), //
        make_unique<SubscribeAttributeBooleanStateStateValue>(), //
        make_unique<ReadBooleanStateServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBooleanStateServerGeneratedCommandList>(), //
        make_unique<ReadBooleanStateClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBooleanStateClientGeneratedCommandList>(), //
        make_unique<ReadBooleanStateAttributeList>(), //
        make_unique<SubscribeAttributeBooleanStateAttributeList>(), //
        make_unique<ReadBooleanStateClusterRevision>(), //
        make_unique<SubscribeAttributeBooleanStateClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedActions(Commands & commands)
{
    const char * clusterName = "BridgedActions";

    commands_list clusterCommands = {
        make_unique<BridgedActionsDisableAction>(), //
        make_unique<BridgedActionsDisableActionWithDuration>(), //
        make_unique<BridgedActionsEnableAction>(), //
        make_unique<BridgedActionsEnableActionWithDuration>(), //
        make_unique<BridgedActionsInstantAction>(), //
        make_unique<BridgedActionsInstantActionWithTransition>(), //
        make_unique<BridgedActionsPauseAction>(), //
        make_unique<BridgedActionsPauseActionWithDuration>(), //
        make_unique<BridgedActionsResumeAction>(), //
        make_unique<BridgedActionsStartAction>(), //
        make_unique<BridgedActionsStartActionWithDuration>(), //
        make_unique<BridgedActionsStopAction>(), //
        make_unique<ReadBridgedActionsActionList>(), //
        make_unique<SubscribeAttributeBridgedActionsActionList>(), //
        make_unique<ReadBridgedActionsEndpointList>(), //
        make_unique<SubscribeAttributeBridgedActionsEndpointList>(), //
        make_unique<ReadBridgedActionsSetupUrl>(), //
        make_unique<SubscribeAttributeBridgedActionsSetupUrl>(), //
        make_unique<ReadBridgedActionsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBridgedActionsServerGeneratedCommandList>(), //
        make_unique<ReadBridgedActionsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBridgedActionsClientGeneratedCommandList>(), //
        make_unique<ReadBridgedActionsAttributeList>(), //
        make_unique<SubscribeAttributeBridgedActionsAttributeList>(), //
        make_unique<ReadBridgedActionsClusterRevision>(), //
        make_unique<SubscribeAttributeBridgedActionsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedDeviceBasic(Commands & commands)
{
    const char * clusterName = "BridgedDeviceBasic";

    commands_list clusterCommands = {
        make_unique<ReadBridgedDeviceBasicVendorName>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicVendorName>(), //
        make_unique<ReadBridgedDeviceBasicVendorID>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicVendorID>(), //
        make_unique<ReadBridgedDeviceBasicProductName>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicProductName>(), //
        make_unique<ReadBridgedDeviceBasicNodeLabel>(), //
        make_unique<WriteBridgedDeviceBasicNodeLabel>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicNodeLabel>(), //
        make_unique<ReadBridgedDeviceBasicHardwareVersion>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicHardwareVersion>(), //
        make_unique<ReadBridgedDeviceBasicHardwareVersionString>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicHardwareVersionString>(), //
        make_unique<ReadBridgedDeviceBasicSoftwareVersion>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicSoftwareVersion>(), //
        make_unique<ReadBridgedDeviceBasicSoftwareVersionString>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicSoftwareVersionString>(), //
        make_unique<ReadBridgedDeviceBasicManufacturingDate>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicManufacturingDate>(), //
        make_unique<ReadBridgedDeviceBasicPartNumber>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicPartNumber>(), //
        make_unique<ReadBridgedDeviceBasicProductURL>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicProductURL>(), //
        make_unique<ReadBridgedDeviceBasicProductLabel>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicProductLabel>(), //
        make_unique<ReadBridgedDeviceBasicSerialNumber>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicSerialNumber>(), //
        make_unique<ReadBridgedDeviceBasicReachable>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicReachable>(), //
        make_unique<ReadBridgedDeviceBasicUniqueID>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicUniqueID>(), //
        make_unique<ReadBridgedDeviceBasicServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicServerGeneratedCommandList>(), //
        make_unique<ReadBridgedDeviceBasicClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicClientGeneratedCommandList>(), //
        make_unique<ReadBridgedDeviceBasicAttributeList>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicAttributeList>(), //
        make_unique<ReadBridgedDeviceBasicClusterRevision>(), //
        make_unique<SubscribeAttributeBridgedDeviceBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterChannel(Commands & commands)
{
    const char * clusterName = "Channel";

    commands_list clusterCommands = {
        make_unique<ChannelChangeChannel>(), //
        make_unique<ChannelChangeChannelByNumber>(), //
        make_unique<ChannelSkipChannel>(), //
        make_unique<ReadChannelChannelList>(), //
        make_unique<SubscribeAttributeChannelChannelList>(), //
        make_unique<ReadChannelServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeChannelServerGeneratedCommandList>(), //
        make_unique<ReadChannelClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeChannelClientGeneratedCommandList>(), //
        make_unique<ReadChannelAttributeList>(), //
        make_unique<SubscribeAttributeChannelAttributeList>(), //
        make_unique<ReadChannelClusterRevision>(), //
        make_unique<SubscribeAttributeChannelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterColorControl(Commands & commands)
{
    const char * clusterName = "ColorControl";

    commands_list clusterCommands = {
        make_unique<ColorControlColorLoopSet>(), //
        make_unique<ColorControlEnhancedMoveHue>(), //
        make_unique<ColorControlEnhancedMoveToHue>(), //
        make_unique<ColorControlEnhancedMoveToHueAndSaturation>(), //
        make_unique<ColorControlEnhancedStepHue>(), //
        make_unique<ColorControlMoveColor>(), //
        make_unique<ColorControlMoveColorTemperature>(), //
        make_unique<ColorControlMoveHue>(), //
        make_unique<ColorControlMoveSaturation>(), //
        make_unique<ColorControlMoveToColor>(), //
        make_unique<ColorControlMoveToColorTemperature>(), //
        make_unique<ColorControlMoveToHue>(), //
        make_unique<ColorControlMoveToHueAndSaturation>(), //
        make_unique<ColorControlMoveToSaturation>(), //
        make_unique<ColorControlStepColor>(), //
        make_unique<ColorControlStepColorTemperature>(), //
        make_unique<ColorControlStepHue>(), //
        make_unique<ColorControlStepSaturation>(), //
        make_unique<ColorControlStopMoveStep>(), //
        make_unique<ReadColorControlCurrentHue>(), //
        make_unique<SubscribeAttributeColorControlCurrentHue>(), //
        make_unique<ReadColorControlCurrentSaturation>(), //
        make_unique<SubscribeAttributeColorControlCurrentSaturation>(), //
        make_unique<ReadColorControlRemainingTime>(), //
        make_unique<SubscribeAttributeColorControlRemainingTime>(), //
        make_unique<ReadColorControlCurrentX>(), //
        make_unique<SubscribeAttributeColorControlCurrentX>(), //
        make_unique<ReadColorControlCurrentY>(), //
        make_unique<SubscribeAttributeColorControlCurrentY>(), //
        make_unique<ReadColorControlDriftCompensation>(), //
        make_unique<SubscribeAttributeColorControlDriftCompensation>(), //
        make_unique<ReadColorControlCompensationText>(), //
        make_unique<SubscribeAttributeColorControlCompensationText>(), //
        make_unique<ReadColorControlColorTemperature>(), //
        make_unique<SubscribeAttributeColorControlColorTemperature>(), //
        make_unique<ReadColorControlColorMode>(), //
        make_unique<SubscribeAttributeColorControlColorMode>(), //
        make_unique<ReadColorControlColorControlOptions>(), //
        make_unique<WriteColorControlColorControlOptions>(), //
        make_unique<SubscribeAttributeColorControlColorControlOptions>(), //
        make_unique<ReadColorControlNumberOfPrimaries>(), //
        make_unique<SubscribeAttributeColorControlNumberOfPrimaries>(), //
        make_unique<ReadColorControlPrimary1X>(), //
        make_unique<SubscribeAttributeColorControlPrimary1X>(), //
        make_unique<ReadColorControlPrimary1Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary1Y>(), //
        make_unique<ReadColorControlPrimary1Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary1Intensity>(), //
        make_unique<ReadColorControlPrimary2X>(), //
        make_unique<SubscribeAttributeColorControlPrimary2X>(), //
        make_unique<ReadColorControlPrimary2Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary2Y>(), //
        make_unique<ReadColorControlPrimary2Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary2Intensity>(), //
        make_unique<ReadColorControlPrimary3X>(), //
        make_unique<SubscribeAttributeColorControlPrimary3X>(), //
        make_unique<ReadColorControlPrimary3Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary3Y>(), //
        make_unique<ReadColorControlPrimary3Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary3Intensity>(), //
        make_unique<ReadColorControlPrimary4X>(), //
        make_unique<SubscribeAttributeColorControlPrimary4X>(), //
        make_unique<ReadColorControlPrimary4Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary4Y>(), //
        make_unique<ReadColorControlPrimary4Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary4Intensity>(), //
        make_unique<ReadColorControlPrimary5X>(), //
        make_unique<SubscribeAttributeColorControlPrimary5X>(), //
        make_unique<ReadColorControlPrimary5Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary5Y>(), //
        make_unique<ReadColorControlPrimary5Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary5Intensity>(), //
        make_unique<ReadColorControlPrimary6X>(), //
        make_unique<SubscribeAttributeColorControlPrimary6X>(), //
        make_unique<ReadColorControlPrimary6Y>(), //
        make_unique<SubscribeAttributeColorControlPrimary6Y>(), //
        make_unique<ReadColorControlPrimary6Intensity>(), //
        make_unique<SubscribeAttributeColorControlPrimary6Intensity>(), //
        make_unique<ReadColorControlWhitePointX>(), //
        make_unique<WriteColorControlWhitePointX>(), //
        make_unique<SubscribeAttributeColorControlWhitePointX>(), //
        make_unique<ReadColorControlWhitePointY>(), //
        make_unique<WriteColorControlWhitePointY>(), //
        make_unique<SubscribeAttributeColorControlWhitePointY>(), //
        make_unique<ReadColorControlColorPointRX>(), //
        make_unique<WriteColorControlColorPointRX>(), //
        make_unique<SubscribeAttributeColorControlColorPointRX>(), //
        make_unique<ReadColorControlColorPointRY>(), //
        make_unique<WriteColorControlColorPointRY>(), //
        make_unique<SubscribeAttributeColorControlColorPointRY>(), //
        make_unique<ReadColorControlColorPointRIntensity>(), //
        make_unique<WriteColorControlColorPointRIntensity>(), //
        make_unique<SubscribeAttributeColorControlColorPointRIntensity>(), //
        make_unique<ReadColorControlColorPointGX>(), //
        make_unique<WriteColorControlColorPointGX>(), //
        make_unique<SubscribeAttributeColorControlColorPointGX>(), //
        make_unique<ReadColorControlColorPointGY>(), //
        make_unique<WriteColorControlColorPointGY>(), //
        make_unique<SubscribeAttributeColorControlColorPointGY>(), //
        make_unique<ReadColorControlColorPointGIntensity>(), //
        make_unique<WriteColorControlColorPointGIntensity>(), //
        make_unique<SubscribeAttributeColorControlColorPointGIntensity>(), //
        make_unique<ReadColorControlColorPointBX>(), //
        make_unique<WriteColorControlColorPointBX>(), //
        make_unique<SubscribeAttributeColorControlColorPointBX>(), //
        make_unique<ReadColorControlColorPointBY>(), //
        make_unique<WriteColorControlColorPointBY>(), //
        make_unique<SubscribeAttributeColorControlColorPointBY>(), //
        make_unique<ReadColorControlColorPointBIntensity>(), //
        make_unique<WriteColorControlColorPointBIntensity>(), //
        make_unique<SubscribeAttributeColorControlColorPointBIntensity>(), //
        make_unique<ReadColorControlEnhancedCurrentHue>(), //
        make_unique<SubscribeAttributeColorControlEnhancedCurrentHue>(), //
        make_unique<ReadColorControlEnhancedColorMode>(), //
        make_unique<SubscribeAttributeColorControlEnhancedColorMode>(), //
        make_unique<ReadColorControlColorLoopActive>(), //
        make_unique<SubscribeAttributeColorControlColorLoopActive>(), //
        make_unique<ReadColorControlColorLoopDirection>(), //
        make_unique<SubscribeAttributeColorControlColorLoopDirection>(), //
        make_unique<ReadColorControlColorLoopTime>(), //
        make_unique<SubscribeAttributeColorControlColorLoopTime>(), //
        make_unique<ReadColorControlColorLoopStartEnhancedHue>(), //
        make_unique<SubscribeAttributeColorControlColorLoopStartEnhancedHue>(), //
        make_unique<ReadColorControlColorLoopStoredEnhancedHue>(), //
        make_unique<SubscribeAttributeColorControlColorLoopStoredEnhancedHue>(), //
        make_unique<ReadColorControlColorCapabilities>(), //
        make_unique<SubscribeAttributeColorControlColorCapabilities>(), //
        make_unique<ReadColorControlColorTempPhysicalMin>(), //
        make_unique<SubscribeAttributeColorControlColorTempPhysicalMin>(), //
        make_unique<ReadColorControlColorTempPhysicalMax>(), //
        make_unique<SubscribeAttributeColorControlColorTempPhysicalMax>(), //
        make_unique<ReadColorControlCoupleColorTempToLevelMinMireds>(), //
        make_unique<SubscribeAttributeColorControlCoupleColorTempToLevelMinMireds>(), //
        make_unique<ReadColorControlStartUpColorTemperatureMireds>(), //
        make_unique<WriteColorControlStartUpColorTemperatureMireds>(), //
        make_unique<SubscribeAttributeColorControlStartUpColorTemperatureMireds>(), //
        make_unique<ReadColorControlServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeColorControlServerGeneratedCommandList>(), //
        make_unique<ReadColorControlClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeColorControlClientGeneratedCommandList>(), //
        make_unique<ReadColorControlAttributeList>(), //
        make_unique<SubscribeAttributeColorControlAttributeList>(), //
        make_unique<ReadColorControlClusterRevision>(), //
        make_unique<SubscribeAttributeColorControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterContentLauncher(Commands & commands)
{
    const char * clusterName = "ContentLauncher";

    commands_list clusterCommands = {
        make_unique<ContentLauncherLaunchContent>(), //
        make_unique<ContentLauncherLaunchURL>(), //
        make_unique<ReadContentLauncherAcceptHeader>(), //
        make_unique<SubscribeAttributeContentLauncherAcceptHeader>(), //
        make_unique<ReadContentLauncherSupportedStreamingProtocols>(), //
        make_unique<WriteContentLauncherSupportedStreamingProtocols>(), //
        make_unique<SubscribeAttributeContentLauncherSupportedStreamingProtocols>(), //
        make_unique<ReadContentLauncherServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeContentLauncherServerGeneratedCommandList>(), //
        make_unique<ReadContentLauncherClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeContentLauncherClientGeneratedCommandList>(), //
        make_unique<ReadContentLauncherAttributeList>(), //
        make_unique<SubscribeAttributeContentLauncherAttributeList>(), //
        make_unique<ReadContentLauncherClusterRevision>(), //
        make_unique<SubscribeAttributeContentLauncherClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDescriptor(Commands & commands)
{
    const char * clusterName = "Descriptor";

    commands_list clusterCommands = {
        make_unique<ReadDescriptorDeviceList>(), //
        make_unique<SubscribeAttributeDescriptorDeviceList>(), //
        make_unique<ReadDescriptorServerList>(), //
        make_unique<SubscribeAttributeDescriptorServerList>(), //
        make_unique<ReadDescriptorClientList>(), //
        make_unique<SubscribeAttributeDescriptorClientList>(), //
        make_unique<ReadDescriptorPartsList>(), //
        make_unique<SubscribeAttributeDescriptorPartsList>(), //
        make_unique<ReadDescriptorServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDescriptorServerGeneratedCommandList>(), //
        make_unique<ReadDescriptorClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDescriptorClientGeneratedCommandList>(), //
        make_unique<ReadDescriptorAttributeList>(), //
        make_unique<SubscribeAttributeDescriptorAttributeList>(), //
        make_unique<ReadDescriptorClusterRevision>(), //
        make_unique<SubscribeAttributeDescriptorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDiagnosticLogs(Commands & commands)
{
    const char * clusterName = "DiagnosticLogs";

    commands_list clusterCommands = {
        make_unique<DiagnosticLogsRetrieveLogsRequest>(), //
        make_unique<ReadDiagnosticLogsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDiagnosticLogsServerGeneratedCommandList>(), //
        make_unique<ReadDiagnosticLogsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDiagnosticLogsClientGeneratedCommandList>(), //
        make_unique<ReadDiagnosticLogsAttributeList>(), //
        make_unique<SubscribeAttributeDiagnosticLogsAttributeList>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDoorLock(Commands & commands)
{
    const char * clusterName = "DoorLock";

    commands_list clusterCommands = {
        make_unique<DoorLockClearCredential>(), //
        make_unique<DoorLockClearUser>(), //
        make_unique<DoorLockClearWeekDaySchedule>(), //
        make_unique<DoorLockClearYearDaySchedule>(), //
        make_unique<DoorLockGetCredentialStatus>(), //
        make_unique<DoorLockGetUser>(), //
        make_unique<DoorLockGetWeekDaySchedule>(), //
        make_unique<DoorLockGetYearDaySchedule>(), //
        make_unique<DoorLockLockDoor>(), //
        make_unique<DoorLockSetCredential>(), //
        make_unique<DoorLockSetUser>(), //
        make_unique<DoorLockSetWeekDaySchedule>(), //
        make_unique<DoorLockSetYearDaySchedule>(), //
        make_unique<DoorLockUnlockDoor>(), //
        make_unique<DoorLockUnlockWithTimeout>(), //
        make_unique<ReadDoorLockLockState>(), //
        make_unique<SubscribeAttributeDoorLockLockState>(), //
        make_unique<ReadDoorLockLockType>(), //
        make_unique<SubscribeAttributeDoorLockLockType>(), //
        make_unique<ReadDoorLockActuatorEnabled>(), //
        make_unique<SubscribeAttributeDoorLockActuatorEnabled>(), //
        make_unique<ReadDoorLockDoorState>(), //
        make_unique<SubscribeAttributeDoorLockDoorState>(), //
        make_unique<ReadDoorLockNumberOfTotalUsersSupported>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfTotalUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfPINUsersSupported>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfPINUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfRFIDUsersSupported>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfRFIDUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfWeekDaySchedulesSupportedPerUser>(), //
        make_unique<ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser>(), //
        make_unique<SubscribeAttributeDoorLockNumberOfYearDaySchedulesSupportedPerUser>(), //
        make_unique<ReadDoorLockMaxPINCodeLength>(), //
        make_unique<SubscribeAttributeDoorLockMaxPINCodeLength>(), //
        make_unique<ReadDoorLockMinPINCodeLength>(), //
        make_unique<SubscribeAttributeDoorLockMinPINCodeLength>(), //
        make_unique<ReadDoorLockMaxRFIDCodeLength>(), //
        make_unique<SubscribeAttributeDoorLockMaxRFIDCodeLength>(), //
        make_unique<ReadDoorLockMinRFIDCodeLength>(), //
        make_unique<SubscribeAttributeDoorLockMinRFIDCodeLength>(), //
        make_unique<ReadDoorLockLanguage>(), //
        make_unique<WriteDoorLockLanguage>(), //
        make_unique<SubscribeAttributeDoorLockLanguage>(), //
        make_unique<ReadDoorLockAutoRelockTime>(), //
        make_unique<WriteDoorLockAutoRelockTime>(), //
        make_unique<SubscribeAttributeDoorLockAutoRelockTime>(), //
        make_unique<ReadDoorLockSoundVolume>(), //
        make_unique<WriteDoorLockSoundVolume>(), //
        make_unique<SubscribeAttributeDoorLockSoundVolume>(), //
        make_unique<ReadDoorLockOperatingMode>(), //
        make_unique<WriteDoorLockOperatingMode>(), //
        make_unique<SubscribeAttributeDoorLockOperatingMode>(), //
        make_unique<ReadDoorLockSupportedOperatingModes>(), //
        make_unique<SubscribeAttributeDoorLockSupportedOperatingModes>(), //
        make_unique<ReadDoorLockEnableOneTouchLocking>(), //
        make_unique<WriteDoorLockEnableOneTouchLocking>(), //
        make_unique<SubscribeAttributeDoorLockEnableOneTouchLocking>(), //
        make_unique<ReadDoorLockEnablePrivacyModeButton>(), //
        make_unique<WriteDoorLockEnablePrivacyModeButton>(), //
        make_unique<SubscribeAttributeDoorLockEnablePrivacyModeButton>(), //
        make_unique<ReadDoorLockWrongCodeEntryLimit>(), //
        make_unique<WriteDoorLockWrongCodeEntryLimit>(), //
        make_unique<SubscribeAttributeDoorLockWrongCodeEntryLimit>(), //
        make_unique<ReadDoorLockServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDoorLockServerGeneratedCommandList>(), //
        make_unique<ReadDoorLockClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeDoorLockClientGeneratedCommandList>(), //
        make_unique<ReadDoorLockAttributeList>(), //
        make_unique<SubscribeAttributeDoorLockAttributeList>(), //
        make_unique<ReadDoorLockClusterRevision>(), //
        make_unique<SubscribeAttributeDoorLockClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterElectricalMeasurement(Commands & commands)
{
    const char * clusterName = "ElectricalMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadElectricalMeasurementMeasurementType>(), //
        make_unique<SubscribeAttributeElectricalMeasurementMeasurementType>(), //
        make_unique<ReadElectricalMeasurementTotalActivePower>(), //
        make_unique<SubscribeAttributeElectricalMeasurementTotalActivePower>(), //
        make_unique<ReadElectricalMeasurementRmsVoltage>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsVoltage>(), //
        make_unique<ReadElectricalMeasurementRmsVoltageMin>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsVoltageMin>(), //
        make_unique<ReadElectricalMeasurementRmsVoltageMax>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsVoltageMax>(), //
        make_unique<ReadElectricalMeasurementRmsCurrent>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsCurrent>(), //
        make_unique<ReadElectricalMeasurementRmsCurrentMin>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsCurrentMin>(), //
        make_unique<ReadElectricalMeasurementRmsCurrentMax>(), //
        make_unique<SubscribeAttributeElectricalMeasurementRmsCurrentMax>(), //
        make_unique<ReadElectricalMeasurementActivePower>(), //
        make_unique<SubscribeAttributeElectricalMeasurementActivePower>(), //
        make_unique<ReadElectricalMeasurementActivePowerMin>(), //
        make_unique<SubscribeAttributeElectricalMeasurementActivePowerMin>(), //
        make_unique<ReadElectricalMeasurementActivePowerMax>(), //
        make_unique<SubscribeAttributeElectricalMeasurementActivePowerMax>(), //
        make_unique<ReadElectricalMeasurementServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeElectricalMeasurementServerGeneratedCommandList>(), //
        make_unique<ReadElectricalMeasurementClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeElectricalMeasurementClientGeneratedCommandList>(), //
        make_unique<ReadElectricalMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeElectricalMeasurementAttributeList>(), //
        make_unique<ReadElectricalMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeElectricalMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterEthernetNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "EthernetNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<EthernetNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPHYRate>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsPHYRate>(), //
        make_unique<ReadEthernetNetworkDiagnosticsFullDuplex>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsFullDuplex>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPacketRxCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsPacketRxCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPacketTxCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsPacketTxCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsTxErrCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsTxErrCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsCollisionCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsCollisionCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsOverrunCount>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsCarrierDetect>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsCarrierDetect>(), //
        make_unique<ReadEthernetNetworkDiagnosticsTimeSinceReset>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsTimeSinceReset>(), //
        make_unique<ReadEthernetNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsFeatureMap>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadEthernetNetworkDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeEthernetNetworkDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFixedLabel(Commands & commands)
{
    const char * clusterName = "FixedLabel";

    commands_list clusterCommands = {
        make_unique<ReadFixedLabelLabelList>(), //
        make_unique<SubscribeAttributeFixedLabelLabelList>(), //
        make_unique<ReadFixedLabelServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeFixedLabelServerGeneratedCommandList>(), //
        make_unique<ReadFixedLabelClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeFixedLabelClientGeneratedCommandList>(), //
        make_unique<ReadFixedLabelAttributeList>(), //
        make_unique<SubscribeAttributeFixedLabelAttributeList>(), //
        make_unique<ReadFixedLabelClusterRevision>(), //
        make_unique<SubscribeAttributeFixedLabelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFlowMeasurement(Commands & commands)
{
    const char * clusterName = "FlowMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadFlowMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributeFlowMeasurementMeasuredValue>(), //
        make_unique<ReadFlowMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributeFlowMeasurementMinMeasuredValue>(), //
        make_unique<ReadFlowMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributeFlowMeasurementMaxMeasuredValue>(), //
        make_unique<ReadFlowMeasurementTolerance>(), //
        make_unique<SubscribeAttributeFlowMeasurementTolerance>(), //
        make_unique<ReadFlowMeasurementServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeFlowMeasurementServerGeneratedCommandList>(), //
        make_unique<ReadFlowMeasurementClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeFlowMeasurementClientGeneratedCommandList>(), //
        make_unique<ReadFlowMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeFlowMeasurementAttributeList>(), //
        make_unique<ReadFlowMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeFlowMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralCommissioning(Commands & commands)
{
    const char * clusterName = "GeneralCommissioning";

    commands_list clusterCommands = {
        make_unique<GeneralCommissioningArmFailSafe>(), //
        make_unique<GeneralCommissioningCommissioningComplete>(), //
        make_unique<GeneralCommissioningSetRegulatoryConfig>(), //
        make_unique<ReadGeneralCommissioningBreadcrumb>(), //
        make_unique<WriteGeneralCommissioningBreadcrumb>(), //
        make_unique<SubscribeAttributeGeneralCommissioningBreadcrumb>(), //
        make_unique<ReadGeneralCommissioningRegulatoryConfig>(), //
        make_unique<SubscribeAttributeGeneralCommissioningRegulatoryConfig>(), //
        make_unique<ReadGeneralCommissioningLocationCapability>(), //
        make_unique<SubscribeAttributeGeneralCommissioningLocationCapability>(), //
        make_unique<ReadGeneralCommissioningServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGeneralCommissioningServerGeneratedCommandList>(), //
        make_unique<ReadGeneralCommissioningClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGeneralCommissioningClientGeneratedCommandList>(), //
        make_unique<ReadGeneralCommissioningAttributeList>(), //
        make_unique<SubscribeAttributeGeneralCommissioningAttributeList>(), //
        make_unique<ReadGeneralCommissioningClusterRevision>(), //
        make_unique<SubscribeAttributeGeneralCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralDiagnostics(Commands & commands)
{
    const char * clusterName = "GeneralDiagnostics";

    commands_list clusterCommands = {
        make_unique<ReadGeneralDiagnosticsNetworkInterfaces>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsNetworkInterfaces>(), //
        make_unique<ReadGeneralDiagnosticsRebootCount>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsRebootCount>(), //
        make_unique<ReadGeneralDiagnosticsUpTime>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsUpTime>(), //
        make_unique<ReadGeneralDiagnosticsTotalOperationalHours>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsTotalOperationalHours>(), //
        make_unique<ReadGeneralDiagnosticsBootReasons>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsBootReasons>(), //
        make_unique<ReadGeneralDiagnosticsActiveHardwareFaults>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsActiveHardwareFaults>(), //
        make_unique<ReadGeneralDiagnosticsActiveRadioFaults>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsActiveRadioFaults>(), //
        make_unique<ReadGeneralDiagnosticsActiveNetworkFaults>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsActiveNetworkFaults>(), //
        make_unique<ReadGeneralDiagnosticsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadGeneralDiagnosticsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadGeneralDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsAttributeList>(), //
        make_unique<ReadGeneralDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeGeneralDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroupKeyManagement(Commands & commands)
{
    const char * clusterName = "GroupKeyManagement";

    commands_list clusterCommands = {
        make_unique<GroupKeyManagementKeySetRead>(), //
        make_unique<GroupKeyManagementKeySetReadAllIndices>(), //
        make_unique<GroupKeyManagementKeySetRemove>(), //
        make_unique<GroupKeyManagementKeySetWrite>(), //
        make_unique<ReadGroupKeyManagementGroupKeyMap>(), //
        make_unique<SubscribeAttributeGroupKeyManagementGroupKeyMap>(), //
        make_unique<ReadGroupKeyManagementGroupTable>(), //
        make_unique<SubscribeAttributeGroupKeyManagementGroupTable>(), //
        make_unique<ReadGroupKeyManagementMaxGroupsPerFabric>(), //
        make_unique<SubscribeAttributeGroupKeyManagementMaxGroupsPerFabric>(), //
        make_unique<ReadGroupKeyManagementMaxGroupKeysPerFabric>(), //
        make_unique<SubscribeAttributeGroupKeyManagementMaxGroupKeysPerFabric>(), //
        make_unique<ReadGroupKeyManagementServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGroupKeyManagementServerGeneratedCommandList>(), //
        make_unique<ReadGroupKeyManagementClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGroupKeyManagementClientGeneratedCommandList>(), //
        make_unique<ReadGroupKeyManagementAttributeList>(), //
        make_unique<SubscribeAttributeGroupKeyManagementAttributeList>(), //
        make_unique<ReadGroupKeyManagementClusterRevision>(), //
        make_unique<SubscribeAttributeGroupKeyManagementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroups(Commands & commands)
{
    const char * clusterName = "Groups";

    commands_list clusterCommands = {
        make_unique<GroupsAddGroup>(), //
        make_unique<GroupsAddGroupIfIdentifying>(), //
        make_unique<GroupsGetGroupMembership>(), //
        make_unique<GroupsRemoveAllGroups>(), //
        make_unique<GroupsRemoveGroup>(), //
        make_unique<GroupsViewGroup>(), //
        make_unique<ReadGroupsNameSupport>(), //
        make_unique<SubscribeAttributeGroupsNameSupport>(), //
        make_unique<ReadGroupsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGroupsServerGeneratedCommandList>(), //
        make_unique<ReadGroupsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeGroupsClientGeneratedCommandList>(), //
        make_unique<ReadGroupsAttributeList>(), //
        make_unique<SubscribeAttributeGroupsAttributeList>(), //
        make_unique<ReadGroupsClusterRevision>(), //
        make_unique<SubscribeAttributeGroupsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIdentify(Commands & commands)
{
    const char * clusterName = "Identify";

    commands_list clusterCommands = {
        make_unique<IdentifyIdentify>(), //
        make_unique<IdentifyIdentifyQuery>(), //
        make_unique<IdentifyTriggerEffect>(), //
        make_unique<ReadIdentifyIdentifyTime>(), //
        make_unique<WriteIdentifyIdentifyTime>(), //
        make_unique<SubscribeAttributeIdentifyIdentifyTime>(), //
        make_unique<ReadIdentifyIdentifyType>(), //
        make_unique<SubscribeAttributeIdentifyIdentifyType>(), //
        make_unique<ReadIdentifyServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeIdentifyServerGeneratedCommandList>(), //
        make_unique<ReadIdentifyClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeIdentifyClientGeneratedCommandList>(), //
        make_unique<ReadIdentifyAttributeList>(), //
        make_unique<SubscribeAttributeIdentifyAttributeList>(), //
        make_unique<ReadIdentifyClusterRevision>(), //
        make_unique<SubscribeAttributeIdentifyClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIlluminanceMeasurement(Commands & commands)
{
    const char * clusterName = "IlluminanceMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadIlluminanceMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementMinMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementMaxMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementTolerance>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementTolerance>(), //
        make_unique<ReadIlluminanceMeasurementLightSensorType>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementLightSensorType>(), //
        make_unique<ReadIlluminanceMeasurementServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementServerGeneratedCommandList>(), //
        make_unique<ReadIlluminanceMeasurementClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementClientGeneratedCommandList>(), //
        make_unique<ReadIlluminanceMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementAttributeList>(), //
        make_unique<ReadIlluminanceMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeIlluminanceMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterKeypadInput(Commands & commands)
{
    const char * clusterName = "KeypadInput";

    commands_list clusterCommands = {
        make_unique<KeypadInputSendKey>(), //
        make_unique<ReadKeypadInputServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeKeypadInputServerGeneratedCommandList>(), //
        make_unique<ReadKeypadInputClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeKeypadInputClientGeneratedCommandList>(), //
        make_unique<ReadKeypadInputAttributeList>(), //
        make_unique<SubscribeAttributeKeypadInputAttributeList>(), //
        make_unique<ReadKeypadInputClusterRevision>(), //
        make_unique<SubscribeAttributeKeypadInputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLevelControl(Commands & commands)
{
    const char * clusterName = "LevelControl";

    commands_list clusterCommands = {
        make_unique<LevelControlMove>(), //
        make_unique<LevelControlMoveToLevel>(), //
        make_unique<LevelControlMoveToLevelWithOnOff>(), //
        make_unique<LevelControlMoveWithOnOff>(), //
        make_unique<LevelControlStep>(), //
        make_unique<LevelControlStepWithOnOff>(), //
        make_unique<LevelControlStop>(), //
        make_unique<LevelControlStopWithOnOff>(), //
        make_unique<ReadLevelControlCurrentLevel>(), //
        make_unique<SubscribeAttributeLevelControlCurrentLevel>(), //
        make_unique<ReadLevelControlRemainingTime>(), //
        make_unique<SubscribeAttributeLevelControlRemainingTime>(), //
        make_unique<ReadLevelControlMinLevel>(), //
        make_unique<SubscribeAttributeLevelControlMinLevel>(), //
        make_unique<ReadLevelControlMaxLevel>(), //
        make_unique<SubscribeAttributeLevelControlMaxLevel>(), //
        make_unique<ReadLevelControlCurrentFrequency>(), //
        make_unique<SubscribeAttributeLevelControlCurrentFrequency>(), //
        make_unique<ReadLevelControlMinFrequency>(), //
        make_unique<SubscribeAttributeLevelControlMinFrequency>(), //
        make_unique<ReadLevelControlMaxFrequency>(), //
        make_unique<SubscribeAttributeLevelControlMaxFrequency>(), //
        make_unique<ReadLevelControlOptions>(), //
        make_unique<WriteLevelControlOptions>(), //
        make_unique<SubscribeAttributeLevelControlOptions>(), //
        make_unique<ReadLevelControlOnOffTransitionTime>(), //
        make_unique<WriteLevelControlOnOffTransitionTime>(), //
        make_unique<SubscribeAttributeLevelControlOnOffTransitionTime>(), //
        make_unique<ReadLevelControlOnLevel>(), //
        make_unique<WriteLevelControlOnLevel>(), //
        make_unique<SubscribeAttributeLevelControlOnLevel>(), //
        make_unique<ReadLevelControlOnTransitionTime>(), //
        make_unique<WriteLevelControlOnTransitionTime>(), //
        make_unique<SubscribeAttributeLevelControlOnTransitionTime>(), //
        make_unique<ReadLevelControlOffTransitionTime>(), //
        make_unique<WriteLevelControlOffTransitionTime>(), //
        make_unique<SubscribeAttributeLevelControlOffTransitionTime>(), //
        make_unique<ReadLevelControlDefaultMoveRate>(), //
        make_unique<WriteLevelControlDefaultMoveRate>(), //
        make_unique<SubscribeAttributeLevelControlDefaultMoveRate>(), //
        make_unique<ReadLevelControlStartUpCurrentLevel>(), //
        make_unique<WriteLevelControlStartUpCurrentLevel>(), //
        make_unique<SubscribeAttributeLevelControlStartUpCurrentLevel>(), //
        make_unique<ReadLevelControlServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLevelControlServerGeneratedCommandList>(), //
        make_unique<ReadLevelControlClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLevelControlClientGeneratedCommandList>(), //
        make_unique<ReadLevelControlAttributeList>(), //
        make_unique<SubscribeAttributeLevelControlAttributeList>(), //
        make_unique<ReadLevelControlFeatureMap>(), //
        make_unique<SubscribeAttributeLevelControlFeatureMap>(), //
        make_unique<ReadLevelControlClusterRevision>(), //
        make_unique<SubscribeAttributeLevelControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLocalizationConfiguration(Commands & commands)
{
    const char * clusterName = "LocalizationConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadLocalizationConfigurationActiveLocale>(), //
        make_unique<WriteLocalizationConfigurationActiveLocale>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationActiveLocale>(), //
        make_unique<ReadLocalizationConfigurationSupportedLocales>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationSupportedLocales>(), //
        make_unique<ReadLocalizationConfigurationServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationServerGeneratedCommandList>(), //
        make_unique<ReadLocalizationConfigurationClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationClientGeneratedCommandList>(), //
        make_unique<ReadLocalizationConfigurationClusterRevision>(), //
        make_unique<SubscribeAttributeLocalizationConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLowPower(Commands & commands)
{
    const char * clusterName = "LowPower";

    commands_list clusterCommands = {
        make_unique<LowPowerSleep>(), //
        make_unique<ReadLowPowerServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLowPowerServerGeneratedCommandList>(), //
        make_unique<ReadLowPowerClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeLowPowerClientGeneratedCommandList>(), //
        make_unique<ReadLowPowerAttributeList>(), //
        make_unique<SubscribeAttributeLowPowerAttributeList>(), //
        make_unique<ReadLowPowerClusterRevision>(), //
        make_unique<SubscribeAttributeLowPowerClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaInput(Commands & commands)
{
    const char * clusterName = "MediaInput";

    commands_list clusterCommands = {
        make_unique<MediaInputHideInputStatus>(), //
        make_unique<MediaInputRenameInput>(), //
        make_unique<MediaInputSelectInput>(), //
        make_unique<MediaInputShowInputStatus>(), //
        make_unique<ReadMediaInputInputList>(), //
        make_unique<SubscribeAttributeMediaInputInputList>(), //
        make_unique<ReadMediaInputCurrentInput>(), //
        make_unique<SubscribeAttributeMediaInputCurrentInput>(), //
        make_unique<ReadMediaInputServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeMediaInputServerGeneratedCommandList>(), //
        make_unique<ReadMediaInputClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeMediaInputClientGeneratedCommandList>(), //
        make_unique<ReadMediaInputAttributeList>(), //
        make_unique<SubscribeAttributeMediaInputAttributeList>(), //
        make_unique<ReadMediaInputClusterRevision>(), //
        make_unique<SubscribeAttributeMediaInputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaPlayback(Commands & commands)
{
    const char * clusterName = "MediaPlayback";

    commands_list clusterCommands = {
        make_unique<MediaPlaybackFastForward>(), //
        make_unique<MediaPlaybackNext>(), //
        make_unique<MediaPlaybackPause>(), //
        make_unique<MediaPlaybackPlay>(), //
        make_unique<MediaPlaybackPrevious>(), //
        make_unique<MediaPlaybackRewind>(), //
        make_unique<MediaPlaybackSeek>(), //
        make_unique<MediaPlaybackSkipBackward>(), //
        make_unique<MediaPlaybackSkipForward>(), //
        make_unique<MediaPlaybackStartOver>(), //
        make_unique<MediaPlaybackStopPlayback>(), //
        make_unique<ReadMediaPlaybackCurrentState>(), //
        make_unique<SubscribeAttributeMediaPlaybackCurrentState>(), //
        make_unique<ReadMediaPlaybackStartTime>(), //
        make_unique<SubscribeAttributeMediaPlaybackStartTime>(), //
        make_unique<ReadMediaPlaybackDuration>(), //
        make_unique<SubscribeAttributeMediaPlaybackDuration>(), //
        make_unique<ReadMediaPlaybackPlaybackSpeed>(), //
        make_unique<SubscribeAttributeMediaPlaybackPlaybackSpeed>(), //
        make_unique<ReadMediaPlaybackSeekRangeEnd>(), //
        make_unique<SubscribeAttributeMediaPlaybackSeekRangeEnd>(), //
        make_unique<ReadMediaPlaybackSeekRangeStart>(), //
        make_unique<SubscribeAttributeMediaPlaybackSeekRangeStart>(), //
        make_unique<ReadMediaPlaybackServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeMediaPlaybackServerGeneratedCommandList>(), //
        make_unique<ReadMediaPlaybackClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeMediaPlaybackClientGeneratedCommandList>(), //
        make_unique<ReadMediaPlaybackAttributeList>(), //
        make_unique<SubscribeAttributeMediaPlaybackAttributeList>(), //
        make_unique<ReadMediaPlaybackClusterRevision>(), //
        make_unique<SubscribeAttributeMediaPlaybackClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterModeSelect(Commands & commands)
{
    const char * clusterName = "ModeSelect";

    commands_list clusterCommands = {
        make_unique<ModeSelectChangeToMode>(), //
        make_unique<ReadModeSelectCurrentMode>(), //
        make_unique<SubscribeAttributeModeSelectCurrentMode>(), //
        make_unique<ReadModeSelectSupportedModes>(), //
        make_unique<SubscribeAttributeModeSelectSupportedModes>(), //
        make_unique<ReadModeSelectOnMode>(), //
        make_unique<WriteModeSelectOnMode>(), //
        make_unique<SubscribeAttributeModeSelectOnMode>(), //
        make_unique<ReadModeSelectStartUpMode>(), //
        make_unique<SubscribeAttributeModeSelectStartUpMode>(), //
        make_unique<ReadModeSelectDescription>(), //
        make_unique<SubscribeAttributeModeSelectDescription>(), //
        make_unique<ReadModeSelectServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeModeSelectServerGeneratedCommandList>(), //
        make_unique<ReadModeSelectClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeModeSelectClientGeneratedCommandList>(), //
        make_unique<ReadModeSelectAttributeList>(), //
        make_unique<SubscribeAttributeModeSelectAttributeList>(), //
        make_unique<ReadModeSelectClusterRevision>(), //
        make_unique<SubscribeAttributeModeSelectClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterNetworkCommissioning(Commands & commands)
{
    const char * clusterName = "NetworkCommissioning";

    commands_list clusterCommands = {
        make_unique<NetworkCommissioningAddOrUpdateThreadNetwork>(), //
        make_unique<NetworkCommissioningAddOrUpdateWiFiNetwork>(), //
        make_unique<NetworkCommissioningConnectNetwork>(), //
        make_unique<NetworkCommissioningRemoveNetwork>(), //
        make_unique<NetworkCommissioningReorderNetwork>(), //
        make_unique<NetworkCommissioningScanNetworks>(), //
        make_unique<ReadNetworkCommissioningMaxNetworks>(), //
        make_unique<SubscribeAttributeNetworkCommissioningMaxNetworks>(), //
        make_unique<ReadNetworkCommissioningNetworks>(), //
        make_unique<SubscribeAttributeNetworkCommissioningNetworks>(), //
        make_unique<ReadNetworkCommissioningScanMaxTimeSeconds>(), //
        make_unique<SubscribeAttributeNetworkCommissioningScanMaxTimeSeconds>(), //
        make_unique<ReadNetworkCommissioningConnectMaxTimeSeconds>(), //
        make_unique<SubscribeAttributeNetworkCommissioningConnectMaxTimeSeconds>(), //
        make_unique<ReadNetworkCommissioningInterfaceEnabled>(), //
        make_unique<WriteNetworkCommissioningInterfaceEnabled>(), //
        make_unique<SubscribeAttributeNetworkCommissioningInterfaceEnabled>(), //
        make_unique<ReadNetworkCommissioningLastNetworkingStatus>(), //
        make_unique<SubscribeAttributeNetworkCommissioningLastNetworkingStatus>(), //
        make_unique<ReadNetworkCommissioningLastNetworkID>(), //
        make_unique<SubscribeAttributeNetworkCommissioningLastNetworkID>(), //
        make_unique<ReadNetworkCommissioningLastConnectErrorValue>(), //
        make_unique<SubscribeAttributeNetworkCommissioningLastConnectErrorValue>(), //
        make_unique<ReadNetworkCommissioningServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeNetworkCommissioningServerGeneratedCommandList>(), //
        make_unique<ReadNetworkCommissioningClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeNetworkCommissioningClientGeneratedCommandList>(), //
        make_unique<ReadNetworkCommissioningFeatureMap>(), //
        make_unique<SubscribeAttributeNetworkCommissioningFeatureMap>(), //
        make_unique<ReadNetworkCommissioningClusterRevision>(), //
        make_unique<SubscribeAttributeNetworkCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateProvider(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateProvider";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateProviderApplyUpdateRequest>(), //
        make_unique<OtaSoftwareUpdateProviderNotifyUpdateApplied>(), //
        make_unique<OtaSoftwareUpdateProviderQueryImage>(), //
        make_unique<ReadOtaSoftwareUpdateProviderAttributeList>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateProviderAttributeList>(), //
        make_unique<ReadOtaSoftwareUpdateProviderClusterRevision>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateProviderClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateRequestor(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateRequestor";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateRequestorAnnounceOtaProvider>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorDefaultOtaProviders>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorDefaultOtaProviders>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdatePossible>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorUpdatePossible>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdateState>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorUpdateState>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdateStateProgress>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorUpdateStateProgress>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorAttributeList>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorAttributeList>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorClusterRevision>(), //
        make_unique<SubscribeAttributeOtaSoftwareUpdateRequestorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOccupancySensing(Commands & commands)
{
    const char * clusterName = "OccupancySensing";

    commands_list clusterCommands = {
        make_unique<ReadOccupancySensingOccupancy>(), //
        make_unique<SubscribeAttributeOccupancySensingOccupancy>(), //
        make_unique<ReadOccupancySensingOccupancySensorType>(), //
        make_unique<SubscribeAttributeOccupancySensingOccupancySensorType>(), //
        make_unique<ReadOccupancySensingOccupancySensorTypeBitmap>(), //
        make_unique<SubscribeAttributeOccupancySensingOccupancySensorTypeBitmap>(), //
        make_unique<ReadOccupancySensingServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOccupancySensingServerGeneratedCommandList>(), //
        make_unique<ReadOccupancySensingClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOccupancySensingClientGeneratedCommandList>(), //
        make_unique<ReadOccupancySensingAttributeList>(), //
        make_unique<SubscribeAttributeOccupancySensingAttributeList>(), //
        make_unique<ReadOccupancySensingClusterRevision>(), //
        make_unique<SubscribeAttributeOccupancySensingClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOff(Commands & commands)
{
    const char * clusterName = "OnOff";

    commands_list clusterCommands = {
        make_unique<OnOffOff>(), //
        make_unique<OnOffOffWithEffect>(), //
        make_unique<OnOffOn>(), //
        make_unique<OnOffOnWithRecallGlobalScene>(), //
        make_unique<OnOffOnWithTimedOff>(), //
        make_unique<OnOffToggle>(), //
        make_unique<ReadOnOffOnOff>(), //
        make_unique<SubscribeAttributeOnOffOnOff>(), //
        make_unique<ReadOnOffGlobalSceneControl>(), //
        make_unique<SubscribeAttributeOnOffGlobalSceneControl>(), //
        make_unique<ReadOnOffOnTime>(), //
        make_unique<WriteOnOffOnTime>(), //
        make_unique<SubscribeAttributeOnOffOnTime>(), //
        make_unique<ReadOnOffOffWaitTime>(), //
        make_unique<WriteOnOffOffWaitTime>(), //
        make_unique<SubscribeAttributeOnOffOffWaitTime>(), //
        make_unique<ReadOnOffStartUpOnOff>(), //
        make_unique<WriteOnOffStartUpOnOff>(), //
        make_unique<SubscribeAttributeOnOffStartUpOnOff>(), //
        make_unique<ReadOnOffServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOnOffServerGeneratedCommandList>(), //
        make_unique<ReadOnOffClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOnOffClientGeneratedCommandList>(), //
        make_unique<ReadOnOffAttributeList>(), //
        make_unique<SubscribeAttributeOnOffAttributeList>(), //
        make_unique<ReadOnOffFeatureMap>(), //
        make_unique<SubscribeAttributeOnOffFeatureMap>(), //
        make_unique<ReadOnOffClusterRevision>(), //
        make_unique<SubscribeAttributeOnOffClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOffSwitchConfiguration(Commands & commands)
{
    const char * clusterName = "OnOffSwitchConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadOnOffSwitchConfigurationSwitchType>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationSwitchType>(), //
        make_unique<ReadOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<WriteOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<ReadOnOffSwitchConfigurationServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationServerGeneratedCommandList>(), //
        make_unique<ReadOnOffSwitchConfigurationClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationClientGeneratedCommandList>(), //
        make_unique<ReadOnOffSwitchConfigurationAttributeList>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationAttributeList>(), //
        make_unique<ReadOnOffSwitchConfigurationClusterRevision>(), //
        make_unique<SubscribeAttributeOnOffSwitchConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOperationalCredentials(Commands & commands)
{
    const char * clusterName = "OperationalCredentials";

    commands_list clusterCommands = {
        make_unique<OperationalCredentialsAddNOC>(), //
        make_unique<OperationalCredentialsAddTrustedRootCertificate>(), //
        make_unique<OperationalCredentialsAttestationRequest>(), //
        make_unique<OperationalCredentialsCSRRequest>(), //
        make_unique<OperationalCredentialsCertificateChainRequest>(), //
        make_unique<OperationalCredentialsRemoveFabric>(), //
        make_unique<OperationalCredentialsRemoveTrustedRootCertificate>(), //
        make_unique<OperationalCredentialsUpdateFabricLabel>(), //
        make_unique<OperationalCredentialsUpdateNOC>(), //
        make_unique<ReadOperationalCredentialsNOCs>(), //
        make_unique<SubscribeAttributeOperationalCredentialsNOCs>(), //
        make_unique<ReadOperationalCredentialsFabrics>(), //
        make_unique<SubscribeAttributeOperationalCredentialsFabrics>(), //
        make_unique<ReadOperationalCredentialsSupportedFabrics>(), //
        make_unique<SubscribeAttributeOperationalCredentialsSupportedFabrics>(), //
        make_unique<ReadOperationalCredentialsCommissionedFabrics>(), //
        make_unique<SubscribeAttributeOperationalCredentialsCommissionedFabrics>(), //
        make_unique<ReadOperationalCredentialsTrustedRootCertificates>(), //
        make_unique<SubscribeAttributeOperationalCredentialsTrustedRootCertificates>(), //
        make_unique<ReadOperationalCredentialsCurrentFabricIndex>(), //
        make_unique<SubscribeAttributeOperationalCredentialsCurrentFabricIndex>(), //
        make_unique<ReadOperationalCredentialsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOperationalCredentialsServerGeneratedCommandList>(), //
        make_unique<ReadOperationalCredentialsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeOperationalCredentialsClientGeneratedCommandList>(), //
        make_unique<ReadOperationalCredentialsAttributeList>(), //
        make_unique<SubscribeAttributeOperationalCredentialsAttributeList>(), //
        make_unique<ReadOperationalCredentialsClusterRevision>(), //
        make_unique<SubscribeAttributeOperationalCredentialsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSource(Commands & commands)
{
    const char * clusterName = "PowerSource";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceStatus>(), //
        make_unique<SubscribeAttributePowerSourceStatus>(), //
        make_unique<ReadPowerSourceOrder>(), //
        make_unique<SubscribeAttributePowerSourceOrder>(), //
        make_unique<ReadPowerSourceDescription>(), //
        make_unique<SubscribeAttributePowerSourceDescription>(), //
        make_unique<ReadPowerSourceBatteryVoltage>(), //
        make_unique<SubscribeAttributePowerSourceBatteryVoltage>(), //
        make_unique<ReadPowerSourceBatteryPercentRemaining>(), //
        make_unique<SubscribeAttributePowerSourceBatteryPercentRemaining>(), //
        make_unique<ReadPowerSourceBatteryTimeRemaining>(), //
        make_unique<SubscribeAttributePowerSourceBatteryTimeRemaining>(), //
        make_unique<ReadPowerSourceBatteryChargeLevel>(), //
        make_unique<SubscribeAttributePowerSourceBatteryChargeLevel>(), //
        make_unique<ReadPowerSourceActiveBatteryFaults>(), //
        make_unique<SubscribeAttributePowerSourceActiveBatteryFaults>(), //
        make_unique<ReadPowerSourceBatteryChargeState>(), //
        make_unique<SubscribeAttributePowerSourceBatteryChargeState>(), //
        make_unique<ReadPowerSourceServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributePowerSourceServerGeneratedCommandList>(), //
        make_unique<ReadPowerSourceClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributePowerSourceClientGeneratedCommandList>(), //
        make_unique<ReadPowerSourceAttributeList>(), //
        make_unique<SubscribeAttributePowerSourceAttributeList>(), //
        make_unique<ReadPowerSourceFeatureMap>(), //
        make_unique<SubscribeAttributePowerSourceFeatureMap>(), //
        make_unique<ReadPowerSourceClusterRevision>(), //
        make_unique<SubscribeAttributePowerSourceClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSourceConfiguration(Commands & commands)
{
    const char * clusterName = "PowerSourceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceConfigurationSources>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationSources>(), //
        make_unique<ReadPowerSourceConfigurationServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationServerGeneratedCommandList>(), //
        make_unique<ReadPowerSourceConfigurationClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationClientGeneratedCommandList>(), //
        make_unique<ReadPowerSourceConfigurationAttributeList>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationAttributeList>(), //
        make_unique<ReadPowerSourceConfigurationClusterRevision>(), //
        make_unique<SubscribeAttributePowerSourceConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPressureMeasurement(Commands & commands)
{
    const char * clusterName = "PressureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadPressureMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributePressureMeasurementMeasuredValue>(), //
        make_unique<ReadPressureMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributePressureMeasurementMinMeasuredValue>(), //
        make_unique<ReadPressureMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributePressureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadPressureMeasurementAttributeList>(), //
        make_unique<SubscribeAttributePressureMeasurementAttributeList>(), //
        make_unique<ReadPressureMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributePressureMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPumpConfigurationAndControl(Commands & commands)
{
    const char * clusterName = "PumpConfigurationAndControl";

    commands_list clusterCommands = {
        make_unique<ReadPumpConfigurationAndControlMaxPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxSpeed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMaxFlow>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinConstPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxConstPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMinCompPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinCompPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxCompPressure>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxCompPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstSpeed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinConstSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstSpeed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxConstSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstFlow>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinConstFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstFlow>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxConstFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstTemp>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMinConstTemp>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstTemp>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlMaxConstTemp>(), //
        make_unique<ReadPumpConfigurationAndControlPumpStatus>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlPumpStatus>(), //
        make_unique<ReadPumpConfigurationAndControlEffectiveOperationMode>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlEffectiveOperationMode>(), //
        make_unique<ReadPumpConfigurationAndControlEffectiveControlMode>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlEffectiveControlMode>(), //
        make_unique<ReadPumpConfigurationAndControlCapacity>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlCapacity>(), //
        make_unique<ReadPumpConfigurationAndControlSpeed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<WritePumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<ReadPumpConfigurationAndControlPower>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlPower>(), //
        make_unique<ReadPumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<WritePumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<ReadPumpConfigurationAndControlOperationMode>(), //
        make_unique<WritePumpConfigurationAndControlOperationMode>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlOperationMode>(), //
        make_unique<ReadPumpConfigurationAndControlControlMode>(), //
        make_unique<WritePumpConfigurationAndControlControlMode>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlControlMode>(), //
        make_unique<ReadPumpConfigurationAndControlAlarmMask>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlAlarmMask>(), //
        make_unique<ReadPumpConfigurationAndControlServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlServerGeneratedCommandList>(), //
        make_unique<ReadPumpConfigurationAndControlClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlClientGeneratedCommandList>(), //
        make_unique<ReadPumpConfigurationAndControlAttributeList>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlAttributeList>(), //
        make_unique<ReadPumpConfigurationAndControlFeatureMap>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlFeatureMap>(), //
        make_unique<ReadPumpConfigurationAndControlClusterRevision>(), //
        make_unique<SubscribeAttributePumpConfigurationAndControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterRelativeHumidityMeasurement(Commands & commands)
{
    const char * clusterName = "RelativeHumidityMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadRelativeHumidityMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementMinMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementMaxMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementTolerance>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementTolerance>(), //
        make_unique<ReadRelativeHumidityMeasurementServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementServerGeneratedCommandList>(), //
        make_unique<ReadRelativeHumidityMeasurementClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementClientGeneratedCommandList>(), //
        make_unique<ReadRelativeHumidityMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementAttributeList>(), //
        make_unique<ReadRelativeHumidityMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeRelativeHumidityMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterScenes(Commands & commands)
{
    const char * clusterName = "Scenes";

    commands_list clusterCommands = {
        make_unique<ScenesAddScene>(), //
        make_unique<ScenesGetSceneMembership>(), //
        make_unique<ScenesRecallScene>(), //
        make_unique<ScenesRemoveAllScenes>(), //
        make_unique<ScenesRemoveScene>(), //
        make_unique<ScenesStoreScene>(), //
        make_unique<ScenesViewScene>(), //
        make_unique<ReadScenesSceneCount>(), //
        make_unique<SubscribeAttributeScenesSceneCount>(), //
        make_unique<ReadScenesCurrentScene>(), //
        make_unique<SubscribeAttributeScenesCurrentScene>(), //
        make_unique<ReadScenesCurrentGroup>(), //
        make_unique<SubscribeAttributeScenesCurrentGroup>(), //
        make_unique<ReadScenesSceneValid>(), //
        make_unique<SubscribeAttributeScenesSceneValid>(), //
        make_unique<ReadScenesNameSupport>(), //
        make_unique<SubscribeAttributeScenesNameSupport>(), //
        make_unique<ReadScenesServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeScenesServerGeneratedCommandList>(), //
        make_unique<ReadScenesClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeScenesClientGeneratedCommandList>(), //
        make_unique<ReadScenesAttributeList>(), //
        make_unique<SubscribeAttributeScenesAttributeList>(), //
        make_unique<ReadScenesClusterRevision>(), //
        make_unique<SubscribeAttributeScenesClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSoftwareDiagnostics(Commands & commands)
{
    const char * clusterName = "SoftwareDiagnostics";

    commands_list clusterCommands = {
        make_unique<SoftwareDiagnosticsResetWatermarks>(), //
        make_unique<ReadSoftwareDiagnosticsThreadMetrics>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsThreadMetrics>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapFree>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsCurrentHeapFree>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapUsed>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsCurrentHeapUsed>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapHighWatermark>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsCurrentHeapHighWatermark>(), //
        make_unique<ReadSoftwareDiagnosticsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadSoftwareDiagnosticsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadSoftwareDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsAttributeList>(), //
        make_unique<ReadSoftwareDiagnosticsFeatureMap>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsFeatureMap>(), //
        make_unique<ReadSoftwareDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeSoftwareDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSwitch(Commands & commands)
{
    const char * clusterName = "Switch";

    commands_list clusterCommands = {
        make_unique<ReadSwitchNumberOfPositions>(), //
        make_unique<SubscribeAttributeSwitchNumberOfPositions>(), //
        make_unique<ReadSwitchCurrentPosition>(), //
        make_unique<SubscribeAttributeSwitchCurrentPosition>(), //
        make_unique<ReadSwitchMultiPressMax>(), //
        make_unique<SubscribeAttributeSwitchMultiPressMax>(), //
        make_unique<ReadSwitchServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeSwitchServerGeneratedCommandList>(), //
        make_unique<ReadSwitchClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeSwitchClientGeneratedCommandList>(), //
        make_unique<ReadSwitchAttributeList>(), //
        make_unique<SubscribeAttributeSwitchAttributeList>(), //
        make_unique<ReadSwitchFeatureMap>(), //
        make_unique<SubscribeAttributeSwitchFeatureMap>(), //
        make_unique<ReadSwitchClusterRevision>(), //
        make_unique<SubscribeAttributeSwitchClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTargetNavigator(Commands & commands)
{
    const char * clusterName = "TargetNavigator";

    commands_list clusterCommands = {
        make_unique<TargetNavigatorNavigateTarget>(), //
        make_unique<ReadTargetNavigatorTargetList>(), //
        make_unique<SubscribeAttributeTargetNavigatorTargetList>(), //
        make_unique<ReadTargetNavigatorCurrentTarget>(), //
        make_unique<SubscribeAttributeTargetNavigatorCurrentTarget>(), //
        make_unique<ReadTargetNavigatorServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTargetNavigatorServerGeneratedCommandList>(), //
        make_unique<ReadTargetNavigatorClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTargetNavigatorClientGeneratedCommandList>(), //
        make_unique<ReadTargetNavigatorAttributeList>(), //
        make_unique<SubscribeAttributeTargetNavigatorAttributeList>(), //
        make_unique<ReadTargetNavigatorClusterRevision>(), //
        make_unique<SubscribeAttributeTargetNavigatorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTemperatureMeasurement(Commands & commands)
{
    const char * clusterName = "TemperatureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadTemperatureMeasurementMeasuredValue>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementMinMeasuredValue>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementMinMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementMaxMeasuredValue>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementTolerance>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementTolerance>(), //
        make_unique<ReadTemperatureMeasurementAttributeList>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementAttributeList>(), //
        make_unique<ReadTemperatureMeasurementClusterRevision>(), //
        make_unique<SubscribeAttributeTemperatureMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTestCluster(Commands & commands)
{
    const char * clusterName = "TestCluster";

    commands_list clusterCommands = {
        make_unique<TestClusterSimpleStructEchoRequest>(), //
        make_unique<TestClusterTest>(), //
        make_unique<TestClusterTestAddArguments>(), //
        make_unique<TestClusterTestEmitTestEventRequest>(), //
        make_unique<TestClusterTestEnumsRequest>(), //
        make_unique<TestClusterTestListInt8UArgumentRequest>(), //
        make_unique<TestClusterTestListInt8UReverseRequest>(), //
        make_unique<TestClusterTestListNestedStructListArgumentRequest>(), //
        make_unique<TestClusterTestListStructArgumentRequest>(), //
        make_unique<TestClusterTestNestedStructArgumentRequest>(), //
        make_unique<TestClusterTestNestedStructListArgumentRequest>(), //
        make_unique<TestClusterTestNotHandled>(), //
        make_unique<TestClusterTestNullableOptionalRequest>(), //
        make_unique<TestClusterTestSimpleOptionalArgumentRequest>(), //
        make_unique<TestClusterTestSpecific>(), //
        make_unique<TestClusterTestStructArgumentRequest>(), //
        make_unique<TestClusterTestUnknownCommand>(), //
        make_unique<TestClusterTimedInvokeRequest>(), //
        make_unique<ReadTestClusterBoolean>(), //
        make_unique<WriteTestClusterBoolean>(), //
        make_unique<SubscribeAttributeTestClusterBoolean>(), //
        make_unique<ReadTestClusterBitmap8>(), //
        make_unique<WriteTestClusterBitmap8>(), //
        make_unique<SubscribeAttributeTestClusterBitmap8>(), //
        make_unique<ReadTestClusterBitmap16>(), //
        make_unique<WriteTestClusterBitmap16>(), //
        make_unique<SubscribeAttributeTestClusterBitmap16>(), //
        make_unique<ReadTestClusterBitmap32>(), //
        make_unique<WriteTestClusterBitmap32>(), //
        make_unique<SubscribeAttributeTestClusterBitmap32>(), //
        make_unique<ReadTestClusterBitmap64>(), //
        make_unique<WriteTestClusterBitmap64>(), //
        make_unique<SubscribeAttributeTestClusterBitmap64>(), //
        make_unique<ReadTestClusterInt8u>(), //
        make_unique<WriteTestClusterInt8u>(), //
        make_unique<SubscribeAttributeTestClusterInt8u>(), //
        make_unique<ReadTestClusterInt16u>(), //
        make_unique<WriteTestClusterInt16u>(), //
        make_unique<SubscribeAttributeTestClusterInt16u>(), //
        make_unique<ReadTestClusterInt24u>(), //
        make_unique<WriteTestClusterInt24u>(), //
        make_unique<SubscribeAttributeTestClusterInt24u>(), //
        make_unique<ReadTestClusterInt32u>(), //
        make_unique<WriteTestClusterInt32u>(), //
        make_unique<SubscribeAttributeTestClusterInt32u>(), //
        make_unique<ReadTestClusterInt40u>(), //
        make_unique<WriteTestClusterInt40u>(), //
        make_unique<SubscribeAttributeTestClusterInt40u>(), //
        make_unique<ReadTestClusterInt48u>(), //
        make_unique<WriteTestClusterInt48u>(), //
        make_unique<SubscribeAttributeTestClusterInt48u>(), //
        make_unique<ReadTestClusterInt56u>(), //
        make_unique<WriteTestClusterInt56u>(), //
        make_unique<SubscribeAttributeTestClusterInt56u>(), //
        make_unique<ReadTestClusterInt64u>(), //
        make_unique<WriteTestClusterInt64u>(), //
        make_unique<SubscribeAttributeTestClusterInt64u>(), //
        make_unique<ReadTestClusterInt8s>(), //
        make_unique<WriteTestClusterInt8s>(), //
        make_unique<SubscribeAttributeTestClusterInt8s>(), //
        make_unique<ReadTestClusterInt16s>(), //
        make_unique<WriteTestClusterInt16s>(), //
        make_unique<SubscribeAttributeTestClusterInt16s>(), //
        make_unique<ReadTestClusterInt24s>(), //
        make_unique<WriteTestClusterInt24s>(), //
        make_unique<SubscribeAttributeTestClusterInt24s>(), //
        make_unique<ReadTestClusterInt32s>(), //
        make_unique<WriteTestClusterInt32s>(), //
        make_unique<SubscribeAttributeTestClusterInt32s>(), //
        make_unique<ReadTestClusterInt40s>(), //
        make_unique<WriteTestClusterInt40s>(), //
        make_unique<SubscribeAttributeTestClusterInt40s>(), //
        make_unique<ReadTestClusterInt48s>(), //
        make_unique<WriteTestClusterInt48s>(), //
        make_unique<SubscribeAttributeTestClusterInt48s>(), //
        make_unique<ReadTestClusterInt56s>(), //
        make_unique<WriteTestClusterInt56s>(), //
        make_unique<SubscribeAttributeTestClusterInt56s>(), //
        make_unique<ReadTestClusterInt64s>(), //
        make_unique<WriteTestClusterInt64s>(), //
        make_unique<SubscribeAttributeTestClusterInt64s>(), //
        make_unique<ReadTestClusterEnum8>(), //
        make_unique<WriteTestClusterEnum8>(), //
        make_unique<SubscribeAttributeTestClusterEnum8>(), //
        make_unique<ReadTestClusterEnum16>(), //
        make_unique<WriteTestClusterEnum16>(), //
        make_unique<SubscribeAttributeTestClusterEnum16>(), //
        make_unique<ReadTestClusterFloatSingle>(), //
        make_unique<WriteTestClusterFloatSingle>(), //
        make_unique<SubscribeAttributeTestClusterFloatSingle>(), //
        make_unique<ReadTestClusterFloatDouble>(), //
        make_unique<WriteTestClusterFloatDouble>(), //
        make_unique<SubscribeAttributeTestClusterFloatDouble>(), //
        make_unique<ReadTestClusterOctetString>(), //
        make_unique<WriteTestClusterOctetString>(), //
        make_unique<SubscribeAttributeTestClusterOctetString>(), //
        make_unique<ReadTestClusterListInt8u>(), //
        make_unique<SubscribeAttributeTestClusterListInt8u>(), //
        make_unique<ReadTestClusterListOctetString>(), //
        make_unique<SubscribeAttributeTestClusterListOctetString>(), //
        make_unique<ReadTestClusterListStructOctetString>(), //
        make_unique<SubscribeAttributeTestClusterListStructOctetString>(), //
        make_unique<ReadTestClusterLongOctetString>(), //
        make_unique<WriteTestClusterLongOctetString>(), //
        make_unique<SubscribeAttributeTestClusterLongOctetString>(), //
        make_unique<ReadTestClusterCharString>(), //
        make_unique<WriteTestClusterCharString>(), //
        make_unique<SubscribeAttributeTestClusterCharString>(), //
        make_unique<ReadTestClusterLongCharString>(), //
        make_unique<WriteTestClusterLongCharString>(), //
        make_unique<SubscribeAttributeTestClusterLongCharString>(), //
        make_unique<ReadTestClusterEpochUs>(), //
        make_unique<WriteTestClusterEpochUs>(), //
        make_unique<SubscribeAttributeTestClusterEpochUs>(), //
        make_unique<ReadTestClusterEpochS>(), //
        make_unique<WriteTestClusterEpochS>(), //
        make_unique<SubscribeAttributeTestClusterEpochS>(), //
        make_unique<ReadTestClusterVendorId>(), //
        make_unique<WriteTestClusterVendorId>(), //
        make_unique<SubscribeAttributeTestClusterVendorId>(), //
        make_unique<ReadTestClusterListNullablesAndOptionalsStruct>(), //
        make_unique<SubscribeAttributeTestClusterListNullablesAndOptionalsStruct>(), //
        make_unique<ReadTestClusterEnumAttr>(), //
        make_unique<WriteTestClusterEnumAttr>(), //
        make_unique<SubscribeAttributeTestClusterEnumAttr>(), //
        make_unique<ReadTestClusterRangeRestrictedInt8u>(), //
        make_unique<WriteTestClusterRangeRestrictedInt8u>(), //
        make_unique<SubscribeAttributeTestClusterRangeRestrictedInt8u>(), //
        make_unique<ReadTestClusterRangeRestrictedInt8s>(), //
        make_unique<WriteTestClusterRangeRestrictedInt8s>(), //
        make_unique<SubscribeAttributeTestClusterRangeRestrictedInt8s>(), //
        make_unique<ReadTestClusterRangeRestrictedInt16u>(), //
        make_unique<WriteTestClusterRangeRestrictedInt16u>(), //
        make_unique<SubscribeAttributeTestClusterRangeRestrictedInt16u>(), //
        make_unique<ReadTestClusterRangeRestrictedInt16s>(), //
        make_unique<WriteTestClusterRangeRestrictedInt16s>(), //
        make_unique<SubscribeAttributeTestClusterRangeRestrictedInt16s>(), //
        make_unique<ReadTestClusterListLongOctetString>(), //
        make_unique<SubscribeAttributeTestClusterListLongOctetString>(), //
        make_unique<ReadTestClusterTimedWriteBoolean>(), //
        make_unique<WriteTestClusterTimedWriteBoolean>(), //
        make_unique<SubscribeAttributeTestClusterTimedWriteBoolean>(), //
        make_unique<ReadTestClusterGeneralErrorBoolean>(), //
        make_unique<WriteTestClusterGeneralErrorBoolean>(), //
        make_unique<SubscribeAttributeTestClusterGeneralErrorBoolean>(), //
        make_unique<ReadTestClusterClusterErrorBoolean>(), //
        make_unique<WriteTestClusterClusterErrorBoolean>(), //
        make_unique<SubscribeAttributeTestClusterClusterErrorBoolean>(), //
        make_unique<ReadTestClusterUnsupported>(), //
        make_unique<WriteTestClusterUnsupported>(), //
        make_unique<SubscribeAttributeTestClusterUnsupported>(), //
        make_unique<ReadTestClusterNullableBoolean>(), //
        make_unique<WriteTestClusterNullableBoolean>(), //
        make_unique<SubscribeAttributeTestClusterNullableBoolean>(), //
        make_unique<ReadTestClusterNullableBitmap8>(), //
        make_unique<WriteTestClusterNullableBitmap8>(), //
        make_unique<SubscribeAttributeTestClusterNullableBitmap8>(), //
        make_unique<ReadTestClusterNullableBitmap16>(), //
        make_unique<WriteTestClusterNullableBitmap16>(), //
        make_unique<SubscribeAttributeTestClusterNullableBitmap16>(), //
        make_unique<ReadTestClusterNullableBitmap32>(), //
        make_unique<WriteTestClusterNullableBitmap32>(), //
        make_unique<SubscribeAttributeTestClusterNullableBitmap32>(), //
        make_unique<ReadTestClusterNullableBitmap64>(), //
        make_unique<WriteTestClusterNullableBitmap64>(), //
        make_unique<SubscribeAttributeTestClusterNullableBitmap64>(), //
        make_unique<ReadTestClusterNullableInt8u>(), //
        make_unique<WriteTestClusterNullableInt8u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt8u>(), //
        make_unique<ReadTestClusterNullableInt16u>(), //
        make_unique<WriteTestClusterNullableInt16u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt16u>(), //
        make_unique<ReadTestClusterNullableInt24u>(), //
        make_unique<WriteTestClusterNullableInt24u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt24u>(), //
        make_unique<ReadTestClusterNullableInt32u>(), //
        make_unique<WriteTestClusterNullableInt32u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt32u>(), //
        make_unique<ReadTestClusterNullableInt40u>(), //
        make_unique<WriteTestClusterNullableInt40u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt40u>(), //
        make_unique<ReadTestClusterNullableInt48u>(), //
        make_unique<WriteTestClusterNullableInt48u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt48u>(), //
        make_unique<ReadTestClusterNullableInt56u>(), //
        make_unique<WriteTestClusterNullableInt56u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt56u>(), //
        make_unique<ReadTestClusterNullableInt64u>(), //
        make_unique<WriteTestClusterNullableInt64u>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt64u>(), //
        make_unique<ReadTestClusterNullableInt8s>(), //
        make_unique<WriteTestClusterNullableInt8s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt8s>(), //
        make_unique<ReadTestClusterNullableInt16s>(), //
        make_unique<WriteTestClusterNullableInt16s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt16s>(), //
        make_unique<ReadTestClusterNullableInt24s>(), //
        make_unique<WriteTestClusterNullableInt24s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt24s>(), //
        make_unique<ReadTestClusterNullableInt32s>(), //
        make_unique<WriteTestClusterNullableInt32s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt32s>(), //
        make_unique<ReadTestClusterNullableInt40s>(), //
        make_unique<WriteTestClusterNullableInt40s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt40s>(), //
        make_unique<ReadTestClusterNullableInt48s>(), //
        make_unique<WriteTestClusterNullableInt48s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt48s>(), //
        make_unique<ReadTestClusterNullableInt56s>(), //
        make_unique<WriteTestClusterNullableInt56s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt56s>(), //
        make_unique<ReadTestClusterNullableInt64s>(), //
        make_unique<WriteTestClusterNullableInt64s>(), //
        make_unique<SubscribeAttributeTestClusterNullableInt64s>(), //
        make_unique<ReadTestClusterNullableEnum8>(), //
        make_unique<WriteTestClusterNullableEnum8>(), //
        make_unique<SubscribeAttributeTestClusterNullableEnum8>(), //
        make_unique<ReadTestClusterNullableEnum16>(), //
        make_unique<WriteTestClusterNullableEnum16>(), //
        make_unique<SubscribeAttributeTestClusterNullableEnum16>(), //
        make_unique<ReadTestClusterNullableFloatSingle>(), //
        make_unique<WriteTestClusterNullableFloatSingle>(), //
        make_unique<SubscribeAttributeTestClusterNullableFloatSingle>(), //
        make_unique<ReadTestClusterNullableFloatDouble>(), //
        make_unique<WriteTestClusterNullableFloatDouble>(), //
        make_unique<SubscribeAttributeTestClusterNullableFloatDouble>(), //
        make_unique<ReadTestClusterNullableOctetString>(), //
        make_unique<WriteTestClusterNullableOctetString>(), //
        make_unique<SubscribeAttributeTestClusterNullableOctetString>(), //
        make_unique<ReadTestClusterNullableCharString>(), //
        make_unique<WriteTestClusterNullableCharString>(), //
        make_unique<SubscribeAttributeTestClusterNullableCharString>(), //
        make_unique<ReadTestClusterNullableEnumAttr>(), //
        make_unique<WriteTestClusterNullableEnumAttr>(), //
        make_unique<SubscribeAttributeTestClusterNullableEnumAttr>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<SubscribeAttributeTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<SubscribeAttributeTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<SubscribeAttributeTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<SubscribeAttributeTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<ReadTestClusterServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTestClusterServerGeneratedCommandList>(), //
        make_unique<ReadTestClusterClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTestClusterClientGeneratedCommandList>(), //
        make_unique<ReadTestClusterAttributeList>(), //
        make_unique<SubscribeAttributeTestClusterAttributeList>(), //
        make_unique<ReadTestClusterClusterRevision>(), //
        make_unique<SubscribeAttributeTestClusterClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostat(Commands & commands)
{
    const char * clusterName = "Thermostat";

    commands_list clusterCommands = {
        make_unique<ThermostatClearWeeklySchedule>(), //
        make_unique<ThermostatGetRelayStatusLog>(), //
        make_unique<ThermostatGetWeeklySchedule>(), //
        make_unique<ThermostatSetWeeklySchedule>(), //
        make_unique<ThermostatSetpointRaiseLower>(), //
        make_unique<ReadThermostatLocalTemperature>(), //
        make_unique<SubscribeAttributeThermostatLocalTemperature>(), //
        make_unique<ReadThermostatAbsMinHeatSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatAbsMinHeatSetpointLimit>(), //
        make_unique<ReadThermostatAbsMaxHeatSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatAbsMaxHeatSetpointLimit>(), //
        make_unique<ReadThermostatAbsMinCoolSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatAbsMinCoolSetpointLimit>(), //
        make_unique<ReadThermostatAbsMaxCoolSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatAbsMaxCoolSetpointLimit>(), //
        make_unique<ReadThermostatOccupiedCoolingSetpoint>(), //
        make_unique<WriteThermostatOccupiedCoolingSetpoint>(), //
        make_unique<SubscribeAttributeThermostatOccupiedCoolingSetpoint>(), //
        make_unique<ReadThermostatOccupiedHeatingSetpoint>(), //
        make_unique<WriteThermostatOccupiedHeatingSetpoint>(), //
        make_unique<SubscribeAttributeThermostatOccupiedHeatingSetpoint>(), //
        make_unique<ReadThermostatMinHeatSetpointLimit>(), //
        make_unique<WriteThermostatMinHeatSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatMinHeatSetpointLimit>(), //
        make_unique<ReadThermostatMaxHeatSetpointLimit>(), //
        make_unique<WriteThermostatMaxHeatSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatMaxHeatSetpointLimit>(), //
        make_unique<ReadThermostatMinCoolSetpointLimit>(), //
        make_unique<WriteThermostatMinCoolSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatMinCoolSetpointLimit>(), //
        make_unique<ReadThermostatMaxCoolSetpointLimit>(), //
        make_unique<WriteThermostatMaxCoolSetpointLimit>(), //
        make_unique<SubscribeAttributeThermostatMaxCoolSetpointLimit>(), //
        make_unique<ReadThermostatMinSetpointDeadBand>(), //
        make_unique<WriteThermostatMinSetpointDeadBand>(), //
        make_unique<SubscribeAttributeThermostatMinSetpointDeadBand>(), //
        make_unique<ReadThermostatControlSequenceOfOperation>(), //
        make_unique<WriteThermostatControlSequenceOfOperation>(), //
        make_unique<SubscribeAttributeThermostatControlSequenceOfOperation>(), //
        make_unique<ReadThermostatSystemMode>(), //
        make_unique<WriteThermostatSystemMode>(), //
        make_unique<SubscribeAttributeThermostatSystemMode>(), //
        make_unique<ReadThermostatStartOfWeek>(), //
        make_unique<SubscribeAttributeThermostatStartOfWeek>(), //
        make_unique<ReadThermostatNumberOfWeeklyTransitions>(), //
        make_unique<SubscribeAttributeThermostatNumberOfWeeklyTransitions>(), //
        make_unique<ReadThermostatNumberOfDailyTransitions>(), //
        make_unique<SubscribeAttributeThermostatNumberOfDailyTransitions>(), //
        make_unique<ReadThermostatAttributeList>(), //
        make_unique<SubscribeAttributeThermostatAttributeList>(), //
        make_unique<ReadThermostatFeatureMap>(), //
        make_unique<SubscribeAttributeThermostatFeatureMap>(), //
        make_unique<ReadThermostatClusterRevision>(), //
        make_unique<SubscribeAttributeThermostatClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostatUserInterfaceConfiguration(Commands & commands)
{
    const char * clusterName = "ThermostatUserInterfaceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationServerGeneratedCommandList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationClientGeneratedCommandList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationAttributeList>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationAttributeList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationClusterRevision>(), //
        make_unique<SubscribeAttributeThermostatUserInterfaceConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThreadNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "ThreadNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<ThreadNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadThreadNetworkDiagnosticsChannel>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsChannel>(), //
        make_unique<ReadThreadNetworkDiagnosticsRoutingRole>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRoutingRole>(), //
        make_unique<ReadThreadNetworkDiagnosticsNetworkName>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsNetworkName>(), //
        make_unique<ReadThreadNetworkDiagnosticsPanId>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsPanId>(), //
        make_unique<ReadThreadNetworkDiagnosticsExtendedPanId>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsExtendedPanId>(), //
        make_unique<ReadThreadNetworkDiagnosticsMeshLocalPrefix>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsMeshLocalPrefix>(), //
        make_unique<ReadThreadNetworkDiagnosticsOverrunCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsNeighborTableList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsNeighborTableList>(), //
        make_unique<ReadThreadNetworkDiagnosticsRouteTableList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRouteTableList>(), //
        make_unique<ReadThreadNetworkDiagnosticsPartitionId>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsPartitionId>(), //
        make_unique<ReadThreadNetworkDiagnosticsWeighting>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsWeighting>(), //
        make_unique<ReadThreadNetworkDiagnosticsDataVersion>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsDataVersion>(), //
        make_unique<ReadThreadNetworkDiagnosticsStableDataVersion>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsStableDataVersion>(), //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRouterId>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsLeaderRouterId>(), //
        make_unique<ReadThreadNetworkDiagnosticsDetachedRoleCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsDetachedRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsChildRoleCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsChildRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRouterRoleCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRouterRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRoleCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsLeaderRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsAttachAttemptCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsAttachAttemptCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsPartitionIdChangeCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsPartitionIdChangeCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsParentChangeCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsParentChangeCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxTotalCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxTotalCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxUnicastCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxUnicastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBroadcastCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxBroadcastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxAckRequestedCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxAckRequestedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxAckedCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxAckedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxNoAckRequestedCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxNoAckRequestedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDataCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxDataCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDataPollCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxDataPollCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxBeaconCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconRequestCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxBeaconRequestCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxOtherCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxRetryCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxRetryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrCcaCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxErrCcaCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrAbortCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxErrAbortCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrBusyChannelCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsTxErrBusyChannelCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxTotalCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxTotalCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxUnicastCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxUnicastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBroadcastCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxBroadcastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDataCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxDataCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDataPollCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxDataPollCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxBeaconCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconRequestCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxBeaconRequestCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxOtherCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxAddressFilteredCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxAddressFilteredCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxDestAddrFilteredCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDuplicatedCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxDuplicatedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrNoFrameCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrNoFrameCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrSecCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrSecCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrFcsCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrFcsCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrOtherCount>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsRxErrOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsActiveTimestamp>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsActiveTimestamp>(), //
        make_unique<ReadThreadNetworkDiagnosticsPendingTimestamp>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsPendingTimestamp>(), //
        make_unique<ReadThreadNetworkDiagnosticsDelay>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsDelay>(), //
        make_unique<ReadThreadNetworkDiagnosticsSecurityPolicy>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsSecurityPolicy>(), //
        make_unique<ReadThreadNetworkDiagnosticsChannelMask>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsChannelMask>(), //
        make_unique<ReadThreadNetworkDiagnosticsOperationalDatasetComponents>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsOperationalDatasetComponents>(), //
        make_unique<ReadThreadNetworkDiagnosticsActiveNetworkFaultsList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsActiveNetworkFaultsList>(), //
        make_unique<ReadThreadNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadThreadNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadThreadNetworkDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadThreadNetworkDiagnosticsFeatureMap>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadThreadNetworkDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeThreadNetworkDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTimeFormatLocalization(Commands & commands)
{
    const char * clusterName = "TimeFormatLocalization";

    commands_list clusterCommands = {
        make_unique<ReadTimeFormatLocalizationHourFormat>(), //
        make_unique<WriteTimeFormatLocalizationHourFormat>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationHourFormat>(), //
        make_unique<ReadTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<WriteTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<ReadTimeFormatLocalizationSupportedCalendarTypes>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationSupportedCalendarTypes>(), //
        make_unique<ReadTimeFormatLocalizationServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationServerGeneratedCommandList>(), //
        make_unique<ReadTimeFormatLocalizationClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationClientGeneratedCommandList>(), //
        make_unique<ReadTimeFormatLocalizationClusterRevision>(), //
        make_unique<SubscribeAttributeTimeFormatLocalizationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterUnitLocalization(Commands & commands)
{
    const char * clusterName = "UnitLocalization";

    commands_list clusterCommands = {
        make_unique<ReadUnitLocalizationTemperatureUnit>(), //
        make_unique<WriteUnitLocalizationTemperatureUnit>(), //
        make_unique<SubscribeAttributeUnitLocalizationTemperatureUnit>(), //
        make_unique<ReadUnitLocalizationAttributeList>(), //
        make_unique<SubscribeAttributeUnitLocalizationAttributeList>(), //
        make_unique<ReadUnitLocalizationFeatureMap>(), //
        make_unique<SubscribeAttributeUnitLocalizationFeatureMap>(), //
        make_unique<ReadUnitLocalizationClusterRevision>(), //
        make_unique<SubscribeAttributeUnitLocalizationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterUserLabel(Commands & commands)
{
    const char * clusterName = "UserLabel";

    commands_list clusterCommands = {
        make_unique<ReadUserLabelLabelList>(), //
        make_unique<SubscribeAttributeUserLabelLabelList>(), //
        make_unique<ReadUserLabelServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeUserLabelServerGeneratedCommandList>(), //
        make_unique<ReadUserLabelClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeUserLabelClientGeneratedCommandList>(), //
        make_unique<ReadUserLabelClusterRevision>(), //
        make_unique<SubscribeAttributeUserLabelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWakeOnLan(Commands & commands)
{
    const char * clusterName = "WakeOnLan";

    commands_list clusterCommands = {
        make_unique<ReadWakeOnLanMACAddress>(), //
        make_unique<SubscribeAttributeWakeOnLanMACAddress>(), //
        make_unique<ReadWakeOnLanServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWakeOnLanServerGeneratedCommandList>(), //
        make_unique<ReadWakeOnLanClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWakeOnLanClientGeneratedCommandList>(), //
        make_unique<ReadWakeOnLanAttributeList>(), //
        make_unique<SubscribeAttributeWakeOnLanAttributeList>(), //
        make_unique<ReadWakeOnLanClusterRevision>(), //
        make_unique<SubscribeAttributeWakeOnLanClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWiFiNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "WiFiNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<WiFiNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBssid>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsBssid>(), //
        make_unique<ReadWiFiNetworkDiagnosticsSecurityType>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsSecurityType>(), //
        make_unique<ReadWiFiNetworkDiagnosticsWiFiVersion>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsWiFiVersion>(), //
        make_unique<ReadWiFiNetworkDiagnosticsChannelNumber>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsChannelNumber>(), //
        make_unique<ReadWiFiNetworkDiagnosticsRssi>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsRssi>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconLostCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsBeaconLostCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconRxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsBeaconRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastRxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastTxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsPacketMulticastTxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastRxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastTxCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsPacketUnicastTxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsCurrentMaxRate>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsCurrentMaxRate>(), //
        make_unique<ReadWiFiNetworkDiagnosticsOverrunCount>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsAttributeList>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsFeatureMap>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadWiFiNetworkDiagnosticsClusterRevision>(), //
        make_unique<SubscribeAttributeWiFiNetworkDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWindowCovering(Commands & commands)
{
    const char * clusterName = "WindowCovering";

    commands_list clusterCommands = {
        make_unique<WindowCoveringDownOrClose>(), //
        make_unique<WindowCoveringGoToLiftPercentage>(), //
        make_unique<WindowCoveringGoToLiftValue>(), //
        make_unique<WindowCoveringGoToTiltPercentage>(), //
        make_unique<WindowCoveringGoToTiltValue>(), //
        make_unique<WindowCoveringStopMotion>(), //
        make_unique<WindowCoveringUpOrOpen>(), //
        make_unique<ReadWindowCoveringType>(), //
        make_unique<SubscribeAttributeWindowCoveringType>(), //
        make_unique<ReadWindowCoveringCurrentPositionLift>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionLift>(), //
        make_unique<ReadWindowCoveringCurrentPositionTilt>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionTilt>(), //
        make_unique<ReadWindowCoveringConfigStatus>(), //
        make_unique<SubscribeAttributeWindowCoveringConfigStatus>(), //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercentage>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionLiftPercentage>(), //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercentage>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionTiltPercentage>(), //
        make_unique<ReadWindowCoveringOperationalStatus>(), //
        make_unique<SubscribeAttributeWindowCoveringOperationalStatus>(), //
        make_unique<ReadWindowCoveringTargetPositionLiftPercent100ths>(), //
        make_unique<SubscribeAttributeWindowCoveringTargetPositionLiftPercent100ths>(), //
        make_unique<ReadWindowCoveringTargetPositionTiltPercent100ths>(), //
        make_unique<SubscribeAttributeWindowCoveringTargetPositionTiltPercent100ths>(), //
        make_unique<ReadWindowCoveringEndProductType>(), //
        make_unique<SubscribeAttributeWindowCoveringEndProductType>(), //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercent100ths>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionLiftPercent100ths>(), //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercent100ths>(), //
        make_unique<SubscribeAttributeWindowCoveringCurrentPositionTiltPercent100ths>(), //
        make_unique<ReadWindowCoveringInstalledOpenLimitLift>(), //
        make_unique<SubscribeAttributeWindowCoveringInstalledOpenLimitLift>(), //
        make_unique<ReadWindowCoveringInstalledClosedLimitLift>(), //
        make_unique<SubscribeAttributeWindowCoveringInstalledClosedLimitLift>(), //
        make_unique<ReadWindowCoveringInstalledOpenLimitTilt>(), //
        make_unique<SubscribeAttributeWindowCoveringInstalledOpenLimitTilt>(), //
        make_unique<ReadWindowCoveringInstalledClosedLimitTilt>(), //
        make_unique<SubscribeAttributeWindowCoveringInstalledClosedLimitTilt>(), //
        make_unique<ReadWindowCoveringMode>(), //
        make_unique<WriteWindowCoveringMode>(), //
        make_unique<SubscribeAttributeWindowCoveringMode>(), //
        make_unique<ReadWindowCoveringSafetyStatus>(), //
        make_unique<SubscribeAttributeWindowCoveringSafetyStatus>(), //
        make_unique<ReadWindowCoveringServerGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWindowCoveringServerGeneratedCommandList>(), //
        make_unique<ReadWindowCoveringClientGeneratedCommandList>(), //
        make_unique<SubscribeAttributeWindowCoveringClientGeneratedCommandList>(), //
        make_unique<ReadWindowCoveringAttributeList>(), //
        make_unique<SubscribeAttributeWindowCoveringAttributeList>(), //
        make_unique<ReadWindowCoveringFeatureMap>(), //
        make_unique<SubscribeAttributeWindowCoveringFeatureMap>(), //
        make_unique<ReadWindowCoveringClusterRevision>(), //
        make_unique<SubscribeAttributeWindowCoveringClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusters(Commands & commands)
{
    registerClusterAccessControl(commands);
    registerClusterAccountLogin(commands);
    registerClusterAdministratorCommissioning(commands);
    registerClusterApplicationBasic(commands);
    registerClusterApplicationLauncher(commands);
    registerClusterAudioOutput(commands);
    registerClusterBarrierControl(commands);
    registerClusterBasic(commands);
    registerClusterBinaryInputBasic(commands);
    registerClusterBinding(commands);
    registerClusterBooleanState(commands);
    registerClusterBridgedActions(commands);
    registerClusterBridgedDeviceBasic(commands);
    registerClusterChannel(commands);
    registerClusterColorControl(commands);
    registerClusterContentLauncher(commands);
    registerClusterDescriptor(commands);
    registerClusterDiagnosticLogs(commands);
    registerClusterDoorLock(commands);
    registerClusterElectricalMeasurement(commands);
    registerClusterEthernetNetworkDiagnostics(commands);
    registerClusterFixedLabel(commands);
    registerClusterFlowMeasurement(commands);
    registerClusterGeneralCommissioning(commands);
    registerClusterGeneralDiagnostics(commands);
    registerClusterGroupKeyManagement(commands);
    registerClusterGroups(commands);
    registerClusterIdentify(commands);
    registerClusterIlluminanceMeasurement(commands);
    registerClusterKeypadInput(commands);
    registerClusterLevelControl(commands);
    registerClusterLocalizationConfiguration(commands);
    registerClusterLowPower(commands);
    registerClusterMediaInput(commands);
    registerClusterMediaPlayback(commands);
    registerClusterModeSelect(commands);
    registerClusterNetworkCommissioning(commands);
    registerClusterOtaSoftwareUpdateProvider(commands);
    registerClusterOtaSoftwareUpdateRequestor(commands);
    registerClusterOccupancySensing(commands);
    registerClusterOnOff(commands);
    registerClusterOnOffSwitchConfiguration(commands);
    registerClusterOperationalCredentials(commands);
    registerClusterPowerSource(commands);
    registerClusterPowerSourceConfiguration(commands);
    registerClusterPressureMeasurement(commands);
    registerClusterPumpConfigurationAndControl(commands);
    registerClusterRelativeHumidityMeasurement(commands);
    registerClusterScenes(commands);
    registerClusterSoftwareDiagnostics(commands);
    registerClusterSwitch(commands);
    registerClusterTargetNavigator(commands);
    registerClusterTemperatureMeasurement(commands);
    registerClusterTestCluster(commands);
    registerClusterThermostat(commands);
    registerClusterThermostatUserInterfaceConfiguration(commands);
    registerClusterThreadNetworkDiagnostics(commands);
    registerClusterTimeFormatLocalization(commands);
    registerClusterUnitLocalization(commands);
    registerClusterUserLabel(commands);
    registerClusterWakeOnLan(commands);
    registerClusterWiFiNetworkDiagnostics(commands);
    registerClusterWindowCovering(commands);
}
